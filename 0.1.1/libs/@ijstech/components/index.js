/*!-----------------------------------------------------------
* Copyright (c) IJS Technologies. All rights reserved.
* Released under dual BUSL-1.1/commercial license
* https://ijs.network
*-----------------------------------------------------------*/
//https://github.com/microsoft/vscode-loader
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _amdLoaderGlobal = this;
var _currentDefineModule;
var _defined = {};
var _commonjsGlobal = typeof global === 'object' ? global : {};
var AMDLoader;
(function (AMDLoader) {
    AMDLoader.global = _amdLoaderGlobal;
    var Environment = /** @class */ (function () {
        function Environment() {
            this._detected = false;
            this._isWindows = false;
            this._isNode = false;
            this._isElectronRenderer = false;
            this._isWebWorker = false;
            this._isElectronNodeIntegrationWebWorker = false;
        }
        Object.defineProperty(Environment.prototype, "isWindows", {
            get: function () {
                this._detect();
                return this._isWindows;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isNode", {
            get: function () {
                this._detect();
                return this._isNode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isElectronRenderer", {
            get: function () {
                this._detect();
                return this._isElectronRenderer;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isWebWorker", {
            get: function () {
                this._detect();
                return this._isWebWorker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isElectronNodeIntegrationWebWorker", {
            get: function () {
                this._detect();
                return this._isElectronNodeIntegrationWebWorker;
            },
            enumerable: false,
            configurable: true
        });
        Environment.prototype._detect = function () {
            if (this._detected) {
                return;
            }
            this._detected = true;
            this._isWindows = Environment._isWindows();
            this._isNode = (typeof module !== 'undefined' && !!module.exports);
            this._isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');
            this._isWebWorker = (typeof AMDLoader.global.importScripts === 'function');
            this._isElectronNodeIntegrationWebWorker = this._isWebWorker && (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'worker');
        };
        Environment._isWindows = function () {
            if (typeof navigator !== 'undefined') {
                if (navigator.userAgent && navigator.userAgent.indexOf('Windows') >= 0) {
                    return true;
                }
            }
            if (typeof process !== 'undefined') {
                return (process.platform === 'win32');
            }
            return false;
        };
        return Environment;
    }());
    AMDLoader.Environment = Environment;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    var LoaderEvent = /** @class */ (function () {
        function LoaderEvent(type, detail, timestamp) {
            this.type = type;
            this.detail = detail;
            this.timestamp = timestamp;
        }
        return LoaderEvent;
    }());
    AMDLoader.LoaderEvent = LoaderEvent;
    var LoaderEventRecorder = /** @class */ (function () {
        function LoaderEventRecorder(loaderAvailableTimestamp) {
            this._events = [new LoaderEvent(1 /* LoaderAvailable */, '', loaderAvailableTimestamp)];
        }
        LoaderEventRecorder.prototype.record = function (type, detail) {
            this._events.push(new LoaderEvent(type, detail, AMDLoader.Utilities.getHighPerformanceTimestamp()));
        };
        LoaderEventRecorder.prototype.getEvents = function () {
            return this._events;
        };
        return LoaderEventRecorder;
    }());
    AMDLoader.LoaderEventRecorder = LoaderEventRecorder;
    var NullLoaderEventRecorder = /** @class */ (function () {
        function NullLoaderEventRecorder() {
        }
        NullLoaderEventRecorder.prototype.record = function (type, detail) {
            // Nothing to do
        };
        NullLoaderEventRecorder.prototype.getEvents = function () {
            return [];
        };
        NullLoaderEventRecorder.INSTANCE = new NullLoaderEventRecorder();
        return NullLoaderEventRecorder;
    }());
    AMDLoader.NullLoaderEventRecorder = NullLoaderEventRecorder;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    var Utilities = /** @class */ (function () {
        function Utilities() {
        }
        /**
         * This method does not take care of / vs \
         */
        Utilities.fileUriToFilePath = function (isWindows, uri) {
            uri = decodeURI(uri).replace(/%23/g, '#');
            if (isWindows) {
                if (/^file:\/\/\//.test(uri)) {
                    // This is a URI without a hostname => return only the path segment
                    return uri.substr(8);
                }
                if (/^file:\/\//.test(uri)) {
                    return uri.substr(5);
                }
            }
            else {
                if (/^file:\/\//.test(uri)) {
                    return uri.substr(7);
                }
            }
            // Not sure...
            return uri;
        };
        Utilities.startsWith = function (haystack, needle) {
            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;
        };
        Utilities.endsWith = function (haystack, needle) {
            return haystack.length >= needle.length && haystack.substr(haystack.length - needle.length) === needle;
        };
        // only check for "?" before "#" to ensure that there is a real Query-String
        Utilities.containsQueryString = function (url) {
            return /^[^\#]*\?/gi.test(url);
        };
        /**
         * Does `url` start with http:// or https:// or file:// or / ?
         */
        Utilities.isAbsolutePath = function (url) {
            return /^((http:\/\/)|(https:\/\/)|(file:\/\/)|(\/))/.test(url);
        };
        Utilities.forEachProperty = function (obj, callback) {
            if (obj) {
                var key = void 0;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        callback(key, obj[key]);
                    }
                }
            }
        };
        Utilities.isEmpty = function (obj) {
            var isEmpty = true;
            Utilities.forEachProperty(obj, function () {
                isEmpty = false;
            });
            return isEmpty;
        };
        Utilities.recursiveClone = function (obj) {
            if (!obj || typeof obj !== 'object' || obj instanceof RegExp) {
                return obj;
            }
            if (!Array.isArray(obj) && Object.getPrototypeOf(obj) !== Object.prototype) {
                // only clone "simple" objects
                return obj;
            }
            var result = Array.isArray(obj) ? [] : {};
            Utilities.forEachProperty(obj, function (key, value) {
                if (value && typeof value === 'object') {
                    result[key] = Utilities.recursiveClone(value);
                }
                else {
                    result[key] = value;
                }
            });
            return result;
        };
        Utilities.generateAnonymousModule = function () {
            return '===anonymous' + (Utilities.NEXT_ANONYMOUS_ID++) + '===';
        };
        Utilities.isAnonymousModule = function (id) {
            return Utilities.startsWith(id, '===anonymous');
        };
        Utilities.getHighPerformanceTimestamp = function () {
            if (!this.PERFORMANCE_NOW_PROBED) {
                this.PERFORMANCE_NOW_PROBED = true;
                this.HAS_PERFORMANCE_NOW = (AMDLoader.global.performance && typeof AMDLoader.global.performance.now === 'function');
            }
            return (this.HAS_PERFORMANCE_NOW ? AMDLoader.global.performance.now() : Date.now());
        };
        Utilities.NEXT_ANONYMOUS_ID = 1;
        Utilities.PERFORMANCE_NOW_PROBED = false;
        Utilities.HAS_PERFORMANCE_NOW = false;
        return Utilities;
    }());
    AMDLoader.Utilities = Utilities;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    function ensureError(err) {
        if (err instanceof Error) {
            return err;
        }
        var result = new Error(err.message || String(err) || 'Unknown Error');
        if (err.stack) {
            result.stack = err.stack;
        }
        return result;
    }
    AMDLoader.ensureError = ensureError;
    ;
    var ConfigurationOptionsUtil = /** @class */ (function () {
        function ConfigurationOptionsUtil() {
        }
        /**
         * Ensure configuration options make sense
         */
        ConfigurationOptionsUtil.validateConfigurationOptions = function (options) {
            function defaultOnError(err) {
                if (err.phase === 'loading') {
                    console.error('Loading "' + err.moduleId + '" failed');
                    console.error(err);
                    console.error('Here are the modules that depend on it:');
                    console.error(err.neededBy);
                    return;
                }
                if (err.phase === 'factory') {
                    console.error('The factory method of "' + err.moduleId + '" has thrown an exception');
                    console.error(err);
                    return;
                }
            }
            options = options || {};
            if (typeof options.baseUrl !== 'string') {
                options.baseUrl = '';
            }
            if (typeof options.isBuild !== 'boolean') {
                options.isBuild = false;
            }
            if (typeof options.paths !== 'object') {
                options.paths = {};
            }
            if (typeof options.config !== 'object') {
                options.config = {};
            }
            if (typeof options.catchError === 'undefined') {
                options.catchError = false;
            }
            if (typeof options.recordStats === 'undefined') {
                options.recordStats = false;
            }
            if (typeof options.urlArgs !== 'string') {
                options.urlArgs = '';
            }
            if (typeof options.onError !== 'function') {
                options.onError = defaultOnError;
            }
            if (!Array.isArray(options.ignoreDuplicateModules)) {
                options.ignoreDuplicateModules = [];
            }
            if (options.baseUrl.length > 0) {
                if (!AMDLoader.Utilities.endsWith(options.baseUrl, '/')) {
                    options.baseUrl += '/';
                }
            }
            if (typeof options.cspNonce !== 'string') {
                options.cspNonce = '';
            }
            if (typeof options.preferScriptTags === 'undefined') {
                options.preferScriptTags = false;
            }
            if (!Array.isArray(options.nodeModules)) {
                options.nodeModules = [];
            }
            if (options.nodeCachedData && typeof options.nodeCachedData === 'object') {
                if (typeof options.nodeCachedData.seed !== 'string') {
                    options.nodeCachedData.seed = 'seed';
                }
                if (typeof options.nodeCachedData.writeDelay !== 'number' || options.nodeCachedData.writeDelay < 0) {
                    options.nodeCachedData.writeDelay = 1000 * 7;
                }
                if (!options.nodeCachedData.path || typeof options.nodeCachedData.path !== 'string') {
                    var err = ensureError(new Error('INVALID cached data configuration, \'path\' MUST be set'));
                    err.phase = 'configuration';
                    options.onError(err);
                    options.nodeCachedData = undefined;
                }
            }
            return options;
        };
        ConfigurationOptionsUtil.mergeConfigurationOptions = function (overwrite, base) {
            if (overwrite === void 0) { overwrite = null; }
            if (base === void 0) { base = null; }
            var result = AMDLoader.Utilities.recursiveClone(base || {});
            // Merge known properties and overwrite the unknown ones
            AMDLoader.Utilities.forEachProperty(overwrite, function (key, value) {
                if (key === 'ignoreDuplicateModules' && typeof result.ignoreDuplicateModules !== 'undefined') {
                    result.ignoreDuplicateModules = result.ignoreDuplicateModules.concat(value);
                }
                else if (key === 'paths' && typeof result.paths !== 'undefined') {
                    AMDLoader.Utilities.forEachProperty(value, function (key2, value2) { return result.paths[key2] = value2; });
                }
                else if (key === 'config' && typeof result.config !== 'undefined') {
                    AMDLoader.Utilities.forEachProperty(value, function (key2, value2) { return result.config[key2] = value2; });
                }
                else {
                    result[key] = AMDLoader.Utilities.recursiveClone(value);
                }
            });
            return ConfigurationOptionsUtil.validateConfigurationOptions(result);
        };
        return ConfigurationOptionsUtil;
    }());
    AMDLoader.ConfigurationOptionsUtil = ConfigurationOptionsUtil;
    var Configuration = /** @class */ (function () {
        function Configuration(env, options) {
            this._env = env;
            this.options = ConfigurationOptionsUtil.mergeConfigurationOptions(options);
            this._createIgnoreDuplicateModulesMap();
            this._createNodeModulesMap();
            this._createSortedPathsRules();
            if (this.options.baseUrl === '') {
                if (this.options.nodeRequire && this.options.nodeRequire.main && this.options.nodeRequire.main.filename && this._env.isNode) {
                    var nodeMain = this.options.nodeRequire.main.filename;
                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\'));
                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);
                }
                if (this.options.nodeMain && this._env.isNode) {
                    var nodeMain = this.options.nodeMain;
                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\'));
                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);
                }
            }
        }
        Configuration.prototype._createIgnoreDuplicateModulesMap = function () {
            // Build a map out of the ignoreDuplicateModules array
            this.ignoreDuplicateModulesMap = {};
            for (var i = 0; i < this.options.ignoreDuplicateModules.length; i++) {
                this.ignoreDuplicateModulesMap[this.options.ignoreDuplicateModules[i]] = true;
            }
        };
        Configuration.prototype._createNodeModulesMap = function () {
            // Build a map out of nodeModules array
            this.nodeModulesMap = Object.create(null);
            for (var _i = 0, _a = this.options.nodeModules; _i < _a.length; _i++) {
                var nodeModule = _a[_i];
                this.nodeModulesMap[nodeModule] = true;
            }
        };
        Configuration.prototype._createSortedPathsRules = function () {
            var _this = this;
            // Create an array our of the paths rules, sorted descending by length to
            // result in a more specific -> less specific order
            this.sortedPathsRules = [];
            AMDLoader.Utilities.forEachProperty(this.options.paths, function (from, to) {
                if (!Array.isArray(to)) {
                    _this.sortedPathsRules.push({
                        from: from,
                        to: [to]
                    });
                }
                else {
                    _this.sortedPathsRules.push({
                        from: from,
                        to: to
                    });
                }
            });
            this.sortedPathsRules.sort(function (a, b) {
                return b.from.length - a.from.length;
            });
        };
        /**
         * Clone current configuration and overwrite options selectively.
         * @param options The selective options to overwrite with.
         * @result A new configuration
         */
        Configuration.prototype.cloneAndMerge = function (options) {
            return new Configuration(this._env, ConfigurationOptionsUtil.mergeConfigurationOptions(options, this.options));
        };
        /**
         * Get current options bag. Useful for passing it forward to plugins.
         */
        Configuration.prototype.getOptionsLiteral = function () {
            return this.options;
        };
        Configuration.prototype._applyPaths = function (moduleId) {
            var pathRule;
            for (var i = 0, len = this.sortedPathsRules.length; i < len; i++) {
                pathRule = this.sortedPathsRules[i];
                if (AMDLoader.Utilities.startsWith(moduleId, pathRule.from)) {
                    var result = [];
                    for (var j = 0, lenJ = pathRule.to.length; j < lenJ; j++) {
                        result.push(pathRule.to[j] + moduleId.substr(pathRule.from.length));
                    }
                    return result;
                }
            }
            return [moduleId];
        };
        Configuration.prototype._addUrlArgsToUrl = function (url) {
            if (AMDLoader.Utilities.containsQueryString(url)) {
                return url + '&' + this.options.urlArgs;
            }
            else {
                return url + '?' + this.options.urlArgs;
            }
        };
        Configuration.prototype._addUrlArgsIfNecessaryToUrl = function (url) {
            if (this.options.urlArgs) {
                return this._addUrlArgsToUrl(url);
            }
            return url;
        };
        Configuration.prototype._addUrlArgsIfNecessaryToUrls = function (urls) {
            if (this.options.urlArgs) {
                for (var i = 0, len = urls.length; i < len; i++) {
                    urls[i] = this._addUrlArgsToUrl(urls[i]);
                }
            }
            return urls;
        };
        /**
         * Transform a module id to a location. Appends .js to module ids
         */
        Configuration.prototype.moduleIdToPaths = function (moduleId) {
            if (this._env.isNode) {
                var isNodeModule = ((this.nodeModulesMap[moduleId] === true)
                    || (this.options.amdModulesPattern instanceof RegExp && !this.options.amdModulesPattern.test(moduleId)));
                if (isNodeModule) {
                    // This is a node module...
                    if (this.isBuild()) {
                        // ...and we are at build time, drop it
                        return ['empty:'];
                    }
                    else {
                        // ...and at runtime we create a `shortcut`-path
                        return ['node|' + moduleId];
                    }
                }
            }
            var result = moduleId;
            var results;
            if (!AMDLoader.Utilities.endsWith(result, '.js') && !AMDLoader.Utilities.isAbsolutePath(result)) {
                results = this._applyPaths(result);
                for (var i = 0, len = results.length; i < len; i++) {
                    if (this.isBuild() && results[i] === 'empty:') {
                        continue;
                    }
                    if (!AMDLoader.Utilities.isAbsolutePath(results[i])) {
                        results[i] = this.options.baseUrl + results[i];
                    }
                    if (!AMDLoader.Utilities.endsWith(results[i], '.js') && !AMDLoader.Utilities.containsQueryString(results[i])) {
                        results[i] = results[i] + '.js';
                    }
                }
            }
            else {
                if (!AMDLoader.Utilities.endsWith(result, '.js') && !AMDLoader.Utilities.containsQueryString(result)) {
                    result = result + '.js';
                }
                results = [result];
            }
            return this._addUrlArgsIfNecessaryToUrls(results);
        };
        /**
         * Transform a module id or url to a location.
         */
        Configuration.prototype.requireToUrl = function (url) {
            var result = url;
            if (!AMDLoader.Utilities.isAbsolutePath(result)) {
                result = this._applyPaths(result)[0];
                if (!AMDLoader.Utilities.isAbsolutePath(result)) {
                    result = this.options.baseUrl + result;
                }
            }
            return this._addUrlArgsIfNecessaryToUrl(result);
        };
        /**
         * Flag to indicate if current execution is as part of a build.
         */
        Configuration.prototype.isBuild = function () {
            return this.options.isBuild;
        };
        /**
         * Test if module `moduleId` is expected to be defined multiple times
         */
        Configuration.prototype.isDuplicateMessageIgnoredFor = function (moduleId) {
            return this.ignoreDuplicateModulesMap.hasOwnProperty(moduleId);
        };
        /**
         * Get the configuration settings for the provided module id
         */
        Configuration.prototype.getConfigForModule = function (moduleId) {
            if (this.options.config) {
                return this.options.config[moduleId];
            }
        };
        /**
         * Should errors be caught when executing module factories?
         */
        Configuration.prototype.shouldCatchError = function () {
            return this.options.catchError;
        };
        /**
         * Should statistics be recorded?
         */
        Configuration.prototype.shouldRecordStats = function () {
            return this.options.recordStats;
        };
        /**
         * Forward an error to the error handler.
         */
        Configuration.prototype.onError = function (err) {
            this.options.onError(err);
        };
        return Configuration;
    }());
    AMDLoader.Configuration = Configuration;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    /**
     * Load `scriptSrc` only once (avoid multiple <script> tags)
     */
    var OnlyOnceScriptLoader = /** @class */ (function () {
        function OnlyOnceScriptLoader(env) {
            this._env = env;
            this._scriptLoader = null;
            this._callbackMap = {};
        }
        OnlyOnceScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            var _this = this;
            if (!this._scriptLoader) {
                if (this._env.isWebWorker) {
                    this._scriptLoader = new WorkerScriptLoader();
                }
                else if (this._env.isElectronRenderer) {
                    var preferScriptTags = moduleManager.getConfig().getOptionsLiteral().preferScriptTags;
                    if (preferScriptTags) {
                        this._scriptLoader = new BrowserScriptLoader();
                    }
                    else {
                        this._scriptLoader = new NodeScriptLoader(this._env);
                    }
                }
                else if (this._env.isNode) {
                    this._scriptLoader = new NodeScriptLoader(this._env);
                }
                else {
                    this._scriptLoader = new BrowserScriptLoader();
                }
            }
            var scriptCallbacks = {
                callback: callback,
                errorback: errorback
            };
            if (this._callbackMap.hasOwnProperty(scriptSrc)) {
                this._callbackMap[scriptSrc].push(scriptCallbacks);
                return;
            }
            this._callbackMap[scriptSrc] = [scriptCallbacks];
            this._scriptLoader.load(moduleManager, scriptSrc, function () { return _this.triggerCallback(scriptSrc); }, function (err) { return _this.triggerErrorback(scriptSrc, err); });
        };
        OnlyOnceScriptLoader.prototype.triggerCallback = function (scriptSrc) {
            var scriptCallbacks = this._callbackMap[scriptSrc];
            delete this._callbackMap[scriptSrc];
            for (var i = 0; i < scriptCallbacks.length; i++) {
                scriptCallbacks[i].callback();
            }
        };
        OnlyOnceScriptLoader.prototype.triggerErrorback = function (scriptSrc, err) {
            var scriptCallbacks = this._callbackMap[scriptSrc];
            delete this._callbackMap[scriptSrc];
            for (var i = 0; i < scriptCallbacks.length; i++) {
                scriptCallbacks[i].errorback(err);
            }
        };
        return OnlyOnceScriptLoader;
    }());
    var BrowserScriptLoader = /** @class */ (function () {
        function BrowserScriptLoader() {
        }
        /**
         * Attach load / error listeners to a script element and remove them when either one has fired.
         * Implemented for browsers supporting HTML5 standard 'load' and 'error' events.
         */
        BrowserScriptLoader.prototype.attachListeners = function (script, callback, errorback) {
            var unbind = function () {
                script.removeEventListener('load', loadEventListener);
                script.removeEventListener('error', errorEventListener);
            };
            var loadEventListener = function (e) {
                unbind();
                callback();
            };
            var errorEventListener = function (e) {
                unbind();
                errorback(e);
            };
            script.addEventListener('load', loadEventListener);
            script.addEventListener('error', errorEventListener);
        };
        BrowserScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            if (/^node\|/.test(scriptSrc)) {
                var opts = moduleManager.getConfig().getOptionsLiteral();
                var nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || AMDLoader.global.nodeRequire));
                var pieces = scriptSrc.split('|');
                var moduleExports_1 = null;
                try {
                    moduleExports_1 = nodeRequire(pieces[1]);
                }
                catch (err) {
                    errorback(err);
                    return;
                }
                moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports_1; });
                callback();
            }
            else {
                var script = document.createElement('script');
                script.setAttribute('async', 'async');
                script.setAttribute('type', 'text/javascript');
                this.attachListeners(script, callback, errorback);
                var trustedTypesPolicy = moduleManager.getConfig().getOptionsLiteral().trustedTypesPolicy;
                if (trustedTypesPolicy) {
                    scriptSrc = trustedTypesPolicy.createScriptURL(scriptSrc);
                }
                script.setAttribute('src', scriptSrc);
                // Propagate CSP nonce to dynamically created script tag.
                var cspNonce = moduleManager.getConfig().getOptionsLiteral().cspNonce;
                if (cspNonce) {
                    script.setAttribute('nonce', cspNonce);
                }
                document.getElementsByTagName('head')[0].appendChild(script);
            }
        };
        return BrowserScriptLoader;
    }());
    function canUseEval(moduleManager) {
        var trustedTypesPolicy = moduleManager.getConfig().getOptionsLiteral().trustedTypesPolicy;
        try {
            var func = (trustedTypesPolicy
                ? self.eval(trustedTypesPolicy.createScript('', 'true'))
                : new Function('true'));
            func.call(self);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    var WorkerScriptLoader = /** @class */ (function () {
        function WorkerScriptLoader() {
            this._cachedCanUseEval = null;
        }
        WorkerScriptLoader.prototype._canUseEval = function (moduleManager) {
            if (this._cachedCanUseEval === null) {
                this._cachedCanUseEval = canUseEval(moduleManager);
            }
            return this._cachedCanUseEval;
        };
        WorkerScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            if (/^node\|/.test(scriptSrc)) {
                var opts = moduleManager.getConfig().getOptionsLiteral();
                var nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || AMDLoader.global.nodeRequire));
                var pieces = scriptSrc.split('|');
                var moduleExports_2 = null;
                try {
                    moduleExports_2 = nodeRequire(pieces[1]);
                }
                catch (err) {
                    errorback(err);
                    return;
                }
                moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports_2; });
                callback();
            }
            else {
                var trustedTypesPolicy_1 = moduleManager.getConfig().getOptionsLiteral().trustedTypesPolicy;
                var isCrossOrigin = (/^((http:)|(https:)|(file:))/.test(scriptSrc) && scriptSrc.substring(0, self.origin.length) !== self.origin);
                if (!isCrossOrigin && this._canUseEval(moduleManager)) {
                    // use `fetch` if possible because `importScripts`
                    // is synchronous and can lead to deadlocks on Safari
                    fetch(scriptSrc).then(function (response) {
                        if (response.status !== 200) {
                            throw new Error(response.statusText);
                        }
                        return response.text();
                    }).then(function (text) {
                        text = text + "\n//# sourceURL=" + scriptSrc;
                        var func = (trustedTypesPolicy_1
                            ? self.eval(trustedTypesPolicy_1.createScript('', text))
                            : new Function(text));
                        func.call(self);
                        callback();
                    }).then(undefined, errorback);
                    return;
                }
                try {
                    if (trustedTypesPolicy_1) {
                        scriptSrc = trustedTypesPolicy_1.createScriptURL(scriptSrc);
                    }
                    importScripts(scriptSrc);
                    callback();
                }
                catch (e) {
                    errorback(e);
                }
            }
        };
        return WorkerScriptLoader;
    }());
    var NodeScriptLoader = /** @class */ (function () {
        function NodeScriptLoader(env) {
            this._env = env;
            this._didInitialize = false;
            this._didPatchNodeRequire = false;
        }
        NodeScriptLoader.prototype._init = function (nodeRequire) {
            if (this._didInitialize) {
                return;
            }
            this._didInitialize = true;
            // capture node modules
            this._fs = nodeRequire('fs');
            this._vm = nodeRequire('vm');
            this._path = nodeRequire('path');
            this._crypto = nodeRequire('crypto');
        };
        // patch require-function of nodejs such that we can manually create a script
        // from cached data. this is done by overriding the `Module._compile` function
        NodeScriptLoader.prototype._initNodeRequire = function (nodeRequire, moduleManager) {
            // It is important to check for `nodeCachedData` first and then set `_didPatchNodeRequire`.
            // That's because `nodeCachedData` is set _after_ calling this for the first time...
            var nodeCachedData = moduleManager.getConfig().getOptionsLiteral().nodeCachedData;
            if (!nodeCachedData) {
                return;
            }
            if (this._didPatchNodeRequire) {
                return;
            }
            this._didPatchNodeRequire = true;
            var that = this;
            var Module = nodeRequire('module');
            function makeRequireFunction(mod) {
                var Module = mod.constructor;
                var require = function require(path) {
                    try {
                        return mod.require(path);
                    }
                    finally {
                        // nothing
                    }
                };
                require.resolve = function resolve(request, options) {
                    return Module._resolveFilename(request, mod, false, options);
                };
                require.resolve.paths = function paths(request) {
                    return Module._resolveLookupPaths(request, mod);
                };
                require.main = process.mainModule;
                require.extensions = Module._extensions;
                require.cache = Module._cache;
                return require;
            }
            Module.prototype._compile = function (content, filename) {
                // remove shebang and create wrapper function
                var scriptSource = Module.wrap(content.replace(/^#!.*/, ''));
                // create script
                var recorder = moduleManager.getRecorder();
                var cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);
                var options = { filename: filename };
                var hashData;
                try {
                    var data = that._fs.readFileSync(cachedDataPath);
                    hashData = data.slice(0, 16);
                    options.cachedData = data.slice(16);
                    recorder.record(60 /* CachedDataFound */, cachedDataPath);
                }
                catch (_e) {
                    recorder.record(61 /* CachedDataMissed */, cachedDataPath);
                }
                var script = new that._vm.Script(scriptSource, options);
                var compileWrapper = script.runInThisContext(options);
                // run script
                var dirname = that._path.dirname(filename);
                var require = makeRequireFunction(this);
                var args = [this.exports, require, this, filename, dirname, process, _commonjsGlobal, Buffer];
                var result = compileWrapper.apply(this.exports, args);
                // cached data aftermath
                that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);
                that._verifyCachedData(script, scriptSource, cachedDataPath, hashData, moduleManager);
                return result;
            };
        };
        NodeScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            var _this = this;
            var opts = moduleManager.getConfig().getOptionsLiteral();
            var nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || AMDLoader.global.nodeRequire));
            var nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });
            this._init(nodeRequire);
            this._initNodeRequire(nodeRequire, moduleManager);
            var recorder = moduleManager.getRecorder();
            if (/^node\|/.test(scriptSrc)) {
                var pieces = scriptSrc.split('|');
                var moduleExports_3 = null;
                try {
                    moduleExports_3 = nodeRequire(pieces[1]);
                }
                catch (err) {
                    errorback(err);
                    return;
                }
                moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports_3; });
                callback();
            }
            else {
                scriptSrc = AMDLoader.Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);
                var normalizedScriptSrc_1 = this._path.normalize(scriptSrc);
                var vmScriptPathOrUri_1 = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc_1);
                var wantsCachedData_1 = Boolean(opts.nodeCachedData);
                var cachedDataPath_1 = wantsCachedData_1 ? this._getCachedDataPath(opts.nodeCachedData, scriptSrc) : undefined;
                this._readSourceAndCachedData(normalizedScriptSrc_1, cachedDataPath_1, recorder, function (err, data, cachedData, hashData) {
                    if (err) {
                        errorback(err);
                        return;
                    }
                    var scriptSource;
                    if (data.charCodeAt(0) === NodeScriptLoader._BOM) {
                        scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;
                    }
                    else {
                        scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;
                    }
                    scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc_1);
                    var scriptOpts = { filename: vmScriptPathOrUri_1, cachedData: cachedData };
                    var script = _this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);
                    _this._handleCachedData(script, scriptSource, cachedDataPath_1, wantsCachedData_1 && !cachedData, moduleManager);
                    _this._verifyCachedData(script, scriptSource, cachedDataPath_1, hashData, moduleManager);
                });
            }
        };
        NodeScriptLoader.prototype._createAndEvalScript = function (moduleManager, contents, options, callback, errorback) {
            var recorder = moduleManager.getRecorder();
            recorder.record(31 /* NodeBeginEvaluatingScript */, options.filename);
            var script = new this._vm.Script(contents, options);
            var ret = script.runInThisContext(options);
            var globalDefineFunc = moduleManager.getGlobalAMDDefineFunc();
            var receivedDefineCall = false;
            var localDefineFunc = function () {
                receivedDefineCall = true;
                return globalDefineFunc.apply(null, arguments);
            };
            localDefineFunc.amd = globalDefineFunc.amd;
            ret.call(AMDLoader.global, moduleManager.getGlobalAMDRequireFunc(), localDefineFunc, options.filename, this._path.dirname(options.filename));
            recorder.record(32 /* NodeEndEvaluatingScript */, options.filename);
            if (receivedDefineCall) {
                callback();
            }
            else {
                errorback(new Error("Didn't receive define call in " + options.filename + "!"));
            }
            return script;
        };
        NodeScriptLoader.prototype._getElectronRendererScriptPathOrUri = function (path) {
            if (!this._env.isElectronRenderer) {
                return path;
            }
            var driveLetterMatch = path.match(/^([a-z])\:(.*)/i);
            if (driveLetterMatch) {
                // windows
                return "file:///" + (driveLetterMatch[1].toUpperCase() + ':' + driveLetterMatch[2]).replace(/\\/g, '/');
            }
            else {
                // nix
                return "file://" + path;
            }
        };
        NodeScriptLoader.prototype._getCachedDataPath = function (config, filename) {
            var hash = this._crypto.createHash('md5').update(filename, 'utf8').update(config.seed, 'utf8').update(process.arch, '').digest('hex');
            var basename = this._path.basename(filename).replace(/\.js$/, '');
            return this._path.join(config.path, basename + "-" + hash + ".code");
        };
        NodeScriptLoader.prototype._handleCachedData = function (script, scriptSource, cachedDataPath, createCachedData, moduleManager) {
            var _this = this;
            if (script.cachedDataRejected) {
                // cached data got rejected -> delete and re-create
                this._fs.unlink(cachedDataPath, function (err) {
                    moduleManager.getRecorder().record(62 /* CachedDataRejected */, cachedDataPath);
                    _this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
                    if (err) {
                        moduleManager.getConfig().onError(err);
                    }
                });
            }
            else if (createCachedData) {
                // no cached data, but wanted
                this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
            }
        };
        // Cached data format: | SOURCE_HASH | V8_CACHED_DATA |
        // -SOURCE_HASH is the md5 hash of the JS source (always 16 bytes)
        // -V8_CACHED_DATA is what v8 produces
        NodeScriptLoader.prototype._createAndWriteCachedData = function (script, scriptSource, cachedDataPath, moduleManager) {
            var _this = this;
            var timeout = Math.ceil(moduleManager.getConfig().getOptionsLiteral().nodeCachedData.writeDelay * (1 + Math.random()));
            var lastSize = -1;
            var iteration = 0;
            var hashData = undefined;
            var createLoop = function () {
                setTimeout(function () {
                    if (!hashData) {
                        hashData = _this._crypto.createHash('md5').update(scriptSource, 'utf8').digest();
                    }
                    var cachedData = script.createCachedData();
                    if (cachedData.length === 0 || cachedData.length === lastSize || iteration >= 5) {
                        // done
                        return;
                    }
                    if (cachedData.length < lastSize) {
                        // less data than before: skip, try again next round
                        createLoop();
                        return;
                    }
                    lastSize = cachedData.length;
                    _this._fs.writeFile(cachedDataPath, Buffer.concat([hashData, cachedData]), function (err) {
                        if (err) {
                            moduleManager.getConfig().onError(err);
                        }
                        moduleManager.getRecorder().record(63 /* CachedDataCreated */, cachedDataPath);
                        createLoop();
                    });
                }, timeout * (Math.pow(4, iteration++)));
            };
            // with some delay (`timeout`) create cached data
            // and repeat that (with backoff delay) until the
            // data seems to be not changing anymore
            createLoop();
        };
        NodeScriptLoader.prototype._readSourceAndCachedData = function (sourcePath, cachedDataPath, recorder, callback) {
            if (!cachedDataPath) {
                // no cached data case
                this._fs.readFile(sourcePath, { encoding: 'utf8' }, callback);
            }
            else {
                // cached data case: read both files in parallel
                var source_1 = undefined;
                var cachedData_1 = undefined;
                var hashData_1 = undefined;
                var steps_1 = 2;
                var step_1 = function (err) {
                    if (err) {
                        callback(err);
                    }
                    else if (--steps_1 === 0) {
                        callback(undefined, source_1, cachedData_1, hashData_1);
                    }
                };
                this._fs.readFile(sourcePath, { encoding: 'utf8' }, function (err, data) {
                    source_1 = data;
                    step_1(err);
                });
                this._fs.readFile(cachedDataPath, function (err, data) {
                    if (!err && data && data.length > 0) {
                        hashData_1 = data.slice(0, 16);
                        cachedData_1 = data.slice(16);
                        recorder.record(60 /* CachedDataFound */, cachedDataPath);
                    }
                    else {
                        recorder.record(61 /* CachedDataMissed */, cachedDataPath);
                    }
                    step_1(); // ignored: cached data is optional
                });
            }
        };
        NodeScriptLoader.prototype._verifyCachedData = function (script, scriptSource, cachedDataPath, hashData, moduleManager) {
            var _this = this;
            if (!hashData) {
                // nothing to do
                return;
            }
            if (script.cachedDataRejected) {
                // invalid anyways
                return;
            }
            setTimeout(function () {
                // check source hash - the contract is that file paths change when file content
                // change (e.g use the commit or version id as cache path). this check is
                // for violations of this contract.
                var hashDataNow = _this._crypto.createHash('md5').update(scriptSource, 'utf8').digest();
                if (!hashData.equals(hashDataNow)) {
                    moduleManager.getConfig().onError(new Error("FAILED TO VERIFY CACHED DATA, deleting stale '" + cachedDataPath + "' now, but a RESTART IS REQUIRED"));
                    _this._fs.unlink(cachedDataPath, function (err) {
                        if (err) {
                            moduleManager.getConfig().onError(err);
                        }
                    });
                }
            }, Math.ceil(5000 * (1 + Math.random())));
        };
        NodeScriptLoader._BOM = 0xFEFF;
        NodeScriptLoader._PREFIX = '(function (require, define, __filename, __dirname) { ';
        NodeScriptLoader._SUFFIX = '\n});';
        return NodeScriptLoader;
    }());
    function ensureRecordedNodeRequire(recorder, _nodeRequire) {
        if (_nodeRequire.__$__isRecorded) {
            // it is already recorded
            return _nodeRequire;
        }
        var nodeRequire = function nodeRequire(what) {
            recorder.record(33 /* NodeBeginNativeRequire */, what);
            try {
                return _nodeRequire(what);
            }
            finally {
                recorder.record(34 /* NodeEndNativeRequire */, what);
            }
        };
        nodeRequire.__$__isRecorded = true;
        return nodeRequire;
    }
    AMDLoader.ensureRecordedNodeRequire = ensureRecordedNodeRequire;
    function createScriptLoader(env) {
        return new OnlyOnceScriptLoader(env);
    }
    AMDLoader.createScriptLoader = createScriptLoader;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    // ------------------------------------------------------------------------
    // ModuleIdResolver
    var ModuleIdResolver = /** @class */ (function () {
        function ModuleIdResolver(fromModuleId) {
            var lastSlash = fromModuleId.lastIndexOf('/');
            if (lastSlash !== -1) {
                this.fromModulePath = fromModuleId.substr(0, lastSlash + 1);
            }
            else {
                this.fromModulePath = '';
            }
        }
        /**
         * Normalize 'a/../name' to 'name', etc.
         */
        ModuleIdResolver._normalizeModuleId = function (moduleId) {
            var r = moduleId, pattern;
            // replace /./ => /
            pattern = /\/\.\//;
            while (pattern.test(r)) {
                r = r.replace(pattern, '/');
            }
            // replace ^./ => nothing
            r = r.replace(/^\.\//g, '');
            // replace /aa/../ => / (BUT IGNORE /../../)
            pattern = /\/(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//;
            while (pattern.test(r)) {
                r = r.replace(pattern, '/');
            }
            // replace ^aa/../ => nothing (BUT IGNORE ../../)
            r = r.replace(/^(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//, '');
            return r;
        };
        /**
         * Resolve relative module ids
         */
        ModuleIdResolver.prototype.resolveModule = function (moduleId) {
            var result = moduleId;
            if (!AMDLoader.Utilities.isAbsolutePath(result)) {
                if (AMDLoader.Utilities.startsWith(result, './') || AMDLoader.Utilities.startsWith(result, '../')) {
                    result = ModuleIdResolver._normalizeModuleId(this.fromModulePath + result);
                }
            }
            return result;
        };
        ModuleIdResolver.ROOT = new ModuleIdResolver('');
        return ModuleIdResolver;
    }());
    AMDLoader.ModuleIdResolver = ModuleIdResolver;
    // ------------------------------------------------------------------------
    // Module
    var Module = /** @class */ (function () {
        function Module(id, strId, dependencies, callback, errorback, moduleIdResolver) {
            this.id = id;
            this.strId = strId;
            this.dependencies = dependencies;
            this._callback = callback;
            this._errorback = errorback;
            this.moduleIdResolver = moduleIdResolver;
            this.exports = {};
            this.error = null;
            this.exportsPassedIn = false;
            this.unresolvedDependenciesCount = this.dependencies.length;
            this._isComplete = false;
        }
        Module._safeInvokeFunction = function (callback, args) {
            try {
                return {
                    returnedValue: callback.apply(AMDLoader.global, args),
                    producedError: null
                };
            }
            catch (e) {
                return {
                    returnedValue: null,
                    producedError: e
                };
            }
        };
        Module._invokeFactory = function (config, strModuleId, callback, dependenciesValues) {
            if (config.isBuild() && !AMDLoader.Utilities.isAnonymousModule(strModuleId)) {
                return {
                    returnedValue: null,
                    producedError: null
                };
            }
            if (config.shouldCatchError()) {
                return this._safeInvokeFunction(callback, dependenciesValues);
            }
            return {
                returnedValue: callback.apply(AMDLoader.global, dependenciesValues),
                producedError: null
            };
        };
        Module.prototype.complete = function (recorder, config, dependenciesValues) {
            this._isComplete = true;
            var producedError = null;
            if (this._callback) {
                if (typeof this._callback === 'function') {
                    recorder.record(21 /* BeginInvokeFactory */, this.strId);
                    var r = Module._invokeFactory(config, this.strId, this._callback, dependenciesValues);
                    producedError = r.producedError;
                    recorder.record(22 /* EndInvokeFactory */, this.strId);
                    if (!producedError && typeof r.returnedValue !== 'undefined' && (!this.exportsPassedIn || AMDLoader.Utilities.isEmpty(this.exports))) {
                        this.exports = r.returnedValue;
                    }
                }
                else {
                    this.exports = this._callback;
                }
            }
            if (producedError) {
                var err = AMDLoader.ensureError(producedError);
                err.phase = 'factory';
                err.moduleId = this.strId;
                this.error = err;
                config.onError(err);
            }
            this.dependencies = null;
            this._callback = null;
            this._errorback = null;
            this.moduleIdResolver = null;
        };
        /**
         * One of the direct dependencies or a transitive dependency has failed to load.
         */
        Module.prototype.onDependencyError = function (err) {
            this._isComplete = true;
            this.error = err;
            if (this._errorback) {
                this._errorback(err);
                return true;
            }
            return false;
        };
        /**
         * Is the current module complete?
         */
        Module.prototype.isComplete = function () {
            return this._isComplete;
        };
        return Module;
    }());
    AMDLoader.Module = Module;
    var ModuleIdProvider = /** @class */ (function () {
        function ModuleIdProvider() {
            this._nextId = 0;
            this._strModuleIdToIntModuleId = new Map();
            this._intModuleIdToStrModuleId = [];
            // Ensure values 0, 1, 2 are assigned accordingly with ModuleId
            this.getModuleId('exports');
            this.getModuleId('module');
            this.getModuleId('require');
        }
        ModuleIdProvider.prototype.getMaxModuleId = function () {
            return this._nextId;
        };
        ModuleIdProvider.prototype.getModuleId = function (strModuleId) {
            var id = this._strModuleIdToIntModuleId.get(strModuleId);
            if (typeof id === 'undefined') {
                id = this._nextId++;
                this._strModuleIdToIntModuleId.set(strModuleId, id);
                this._intModuleIdToStrModuleId[id] = strModuleId;
            }
            return id;
        };
        ModuleIdProvider.prototype.getStrModuleId = function (moduleId) {
            return this._intModuleIdToStrModuleId[moduleId];
        };
        return ModuleIdProvider;
    }());
    var RegularDependency = /** @class */ (function () {
        function RegularDependency(id) {
            this.id = id;
        }
        RegularDependency.EXPORTS = new RegularDependency(0 /* EXPORTS */);
        RegularDependency.MODULE = new RegularDependency(1 /* MODULE */);
        RegularDependency.REQUIRE = new RegularDependency(2 /* REQUIRE */);
        return RegularDependency;
    }());
    AMDLoader.RegularDependency = RegularDependency;
    var PluginDependency = /** @class */ (function () {
        function PluginDependency(id, pluginId, pluginParam) {
            this.id = id;
            this.pluginId = pluginId;
            this.pluginParam = pluginParam;
        }
        return PluginDependency;
    }());
    AMDLoader.PluginDependency = PluginDependency;
    var ModuleManager = /** @class */ (function () {
        function ModuleManager(env, scriptLoader, defineFunc, requireFunc, loaderAvailableTimestamp) {
            if (loaderAvailableTimestamp === void 0) { loaderAvailableTimestamp = 0; }
            this._env = env;
            this._scriptLoader = scriptLoader;
            this._loaderAvailableTimestamp = loaderAvailableTimestamp;
            this._defineFunc = defineFunc;
            this._requireFunc = requireFunc;
            this._moduleIdProvider = new ModuleIdProvider();
            this._config = new AMDLoader.Configuration(this._env);
            this._hasDependencyCycle = false;
            this._modules2 = [];
            this._knownModules2 = [];
            this._inverseDependencies2 = [];
            this._inversePluginDependencies2 = new Map();
            this._currentAnonymousDefineCall = null;
            this._recorder = null;
            this._buildInfoPath = [];
            this._buildInfoDefineStack = [];
            this._buildInfoDependencies = [];
        }
        ModuleManager.prototype.reset = function () {
            return new ModuleManager(this._env, this._scriptLoader, this._defineFunc, this._requireFunc, this._loaderAvailableTimestamp);
        };
        ModuleManager.prototype.getGlobalAMDDefineFunc = function () {
            return this._defineFunc;
        };
        ModuleManager.prototype.getGlobalAMDRequireFunc = function () {
            return this._requireFunc;
        };
        ModuleManager._findRelevantLocationInStack = function (needle, stack) {
            var normalize = function (str) { return str.replace(/\\/g, '/'); };
            var normalizedPath = normalize(needle);
            var stackPieces = stack.split(/\n/);
            for (var i = 0; i < stackPieces.length; i++) {
                var m = stackPieces[i].match(/(.*):(\d+):(\d+)\)?$/);
                if (m) {
                    var stackPath = m[1];
                    var stackLine = m[2];
                    var stackColumn = m[3];
                    var trimPathOffset = Math.max(stackPath.lastIndexOf(' ') + 1, stackPath.lastIndexOf('(') + 1);
                    stackPath = stackPath.substr(trimPathOffset);
                    stackPath = normalize(stackPath);
                    if (stackPath === normalizedPath) {
                        var r = {
                            line: parseInt(stackLine, 10),
                            col: parseInt(stackColumn, 10)
                        };
                        if (r.line === 1) {
                            r.col -= '(function (require, define, __filename, __dirname) { '.length;
                        }
                        return r;
                    }
                }
            }
            throw new Error('Could not correlate define call site for needle ' + needle);
        };
        ModuleManager.prototype.getBuildInfo = function () {
            if (!this._config.isBuild()) {
                return null;
            }
            var result = [], resultLen = 0;
            for (var i = 0, len = this._modules2.length; i < len; i++) {
                var m = this._modules2[i];
                if (!m) {
                    continue;
                }
                var location_1 = this._buildInfoPath[m.id] || null;
                var defineStack = this._buildInfoDefineStack[m.id] || null;
                var dependencies = this._buildInfoDependencies[m.id];
                result[resultLen++] = {
                    id: m.strId,
                    path: location_1,
                    defineLocation: (location_1 && defineStack ? ModuleManager._findRelevantLocationInStack(location_1, defineStack) : null),
                    dependencies: dependencies,
                    shim: null,
                    exports: m.exports
                };
            }
            return result;
        };
        ModuleManager.prototype.getRecorder = function () {
            if (!this._recorder) {
                if (this._config.shouldRecordStats()) {
                    this._recorder = new AMDLoader.LoaderEventRecorder(this._loaderAvailableTimestamp);
                }
                else {
                    this._recorder = AMDLoader.NullLoaderEventRecorder.INSTANCE;
                }
            }
            return this._recorder;
        };
        ModuleManager.prototype.getLoaderEvents = function () {
            return this.getRecorder().getEvents();
        };
        /**
         * Defines an anonymous module (without an id). Its name will be resolved as we receive a callback from the scriptLoader.
         * @param dependencies @see defineModule
         * @param callback @see defineModule
         */
        ModuleManager.prototype.enqueueDefineAnonymousModule = function (dependencies, callback) {
            if (this._currentAnonymousDefineCall !== null) {
                throw new Error('Can only have one anonymous define call per script file');
            }
            var stack = null;
            if (this._config.isBuild()) {
                stack = new Error('StackLocation').stack || null;
            }
            this._currentAnonymousDefineCall = {
                stack: stack,
                dependencies: dependencies,
                callback: callback
            };
        };
        /**
         * Creates a module and stores it in _modules. The manager will immediately begin resolving its dependencies.
         * @param strModuleId An unique and absolute id of the module. This must not collide with another module's id
         * @param dependencies An array with the dependencies of the module. Special keys are: "require", "exports" and "module"
         * @param callback if callback is a function, it will be called with the resolved dependencies. if callback is an object, it will be considered as the exports of the module.
         */
        ModuleManager.prototype.defineModule = function (strModuleId, dependencies, callback, errorback, stack, moduleIdResolver) {
            var _this = this;
            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(strModuleId); }
            var moduleId = this._moduleIdProvider.getModuleId(strModuleId);
            // if (this._modules2[moduleId]) {
            //     if (!this._config.isDuplicateMessageIgnoredFor(strModuleId)) {
            //         console.warn('Duplicate definition of module \'' + strModuleId + '\'');
            //     }
            //     // Super important! Completely ignore duplicate module definition
            //     return;
            // }
            var m = new Module(moduleId, strModuleId, this._normalizeDependencies(dependencies, moduleIdResolver), callback, errorback, moduleIdResolver);
            this._modules2[moduleId] = m;
            if (this._config.isBuild()) {
                this._buildInfoDefineStack[moduleId] = stack;
                this._buildInfoDependencies[moduleId] = (m.dependencies || []).map(function (dep) { return _this._moduleIdProvider.getStrModuleId(dep.id); });
            }
            // Resolving of dependencies is immediate (not in a timeout). If there's a need to support a packer that concatenates in an
            // unordered manner, in order to finish processing the file, execute the following method in a timeout
            _currentDefineModule = m.exports;
            this._resolve(m);
        };
        ModuleManager.prototype._normalizeDependency = function (dependency, moduleIdResolver) {
            if (dependency === 'exports') {
                return RegularDependency.EXPORTS;
            }
            if (dependency === 'module') {
                return RegularDependency.MODULE;
            }
            if (dependency === 'require') {
                return RegularDependency.REQUIRE;
            }
            // Normalize dependency and then request it from the manager
            var bangIndex = dependency.indexOf('!');
            if (bangIndex >= 0) {
                var strPluginId = moduleIdResolver.resolveModule(dependency.substr(0, bangIndex));
                var pluginParam = moduleIdResolver.resolveModule(dependency.substr(bangIndex + 1));
                var dependencyId = this._moduleIdProvider.getModuleId(strPluginId + '!' + pluginParam);
                var pluginId = this._moduleIdProvider.getModuleId(strPluginId);
                return new PluginDependency(dependencyId, pluginId, pluginParam);
            }
            return new RegularDependency(this._moduleIdProvider.getModuleId(moduleIdResolver.resolveModule(dependency)));
        };
        ModuleManager.prototype._normalizeDependencies = function (dependencies, moduleIdResolver) {
            var result = [], resultLen = 0;
            for (var i = 0, len = dependencies.length; i < len; i++) {
                result[resultLen++] = this._normalizeDependency(dependencies[i], moduleIdResolver);
            }
            return result;
        };
        ModuleManager.prototype._relativeRequire = function (moduleIdResolver, dependencies, callback, errorback) {
            if (typeof dependencies === 'string') {
                return this.synchronousRequire(dependencies, moduleIdResolver);
            }
            this.defineModule(AMDLoader.Utilities.generateAnonymousModule(), dependencies, callback, errorback, null, moduleIdResolver);
        };
        /**
         * Require synchronously a module by its absolute id. If the module is not loaded, an exception will be thrown.
         * @param id The unique and absolute id of the required module
         * @return The exports of module 'id'
         */
        ModuleManager.prototype.synchronousRequire = function (_strModuleId, moduleIdResolver) {
            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(_strModuleId); }
            var dependency = this._normalizeDependency(_strModuleId, moduleIdResolver);
            var m = this._modules2[dependency.id];
            if (!m) {
                throw new Error('Check dependency list! Synchronous require cannot resolve module \'' + _strModuleId + '\'. This is the first mention of this module!');
            }
            if (!m.isComplete()) {
                throw new Error('Check dependency list! Synchronous require cannot resolve module \'' + _strModuleId + '\'. This module has not been resolved completely yet.');
            }
            if (m.error) {
                throw m.error;
            }
            return m.exports;
        };
        ModuleManager.prototype.configure = function (params, shouldOverwrite) {
            var oldShouldRecordStats = this._config.shouldRecordStats();
            if (shouldOverwrite) {
                this._config = new AMDLoader.Configuration(this._env, params);
            }
            else {
                this._config = this._config.cloneAndMerge(params);
            }
            if (this._config.shouldRecordStats() && !oldShouldRecordStats) {
                this._recorder = null;
            }
        };
        ModuleManager.prototype.getConfig = function () {
            return this._config;
        };
        /**
         * Callback from the scriptLoader when a module has been loaded.
         * This means its code is available and has been executed.
         */
        ModuleManager.prototype._onLoad = function (moduleId) {
            if (this._currentAnonymousDefineCall !== null) {
                var defineCall = this._currentAnonymousDefineCall;
                this._currentAnonymousDefineCall = null;
                // Hit an anonymous define call
                this.defineModule(this._moduleIdProvider.getStrModuleId(moduleId), defineCall.dependencies, defineCall.callback, null, defineCall.stack);
            }
        };
        ModuleManager.prototype._createLoadError = function (moduleId, _err) {
            var _this = this;
            var strModuleId = this._moduleIdProvider.getStrModuleId(moduleId);
            var neededBy = (this._inverseDependencies2[moduleId] || []).map(function (intModuleId) { return _this._moduleIdProvider.getStrModuleId(intModuleId); });
            var err = AMDLoader.ensureError(_err);
            err.phase = 'loading';
            err.moduleId = strModuleId;
            err.neededBy = neededBy;
            return err;
        };
        /**
         * Callback from the scriptLoader when a module hasn't been loaded.
         * This means that the script was not found (e.g. 404) or there was an error in the script.
         */
        ModuleManager.prototype._onLoadError = function (moduleId, err) {
            var error = this._createLoadError(moduleId, err);
            if (!this._modules2[moduleId]) {
                this._modules2[moduleId] = new Module(moduleId, this._moduleIdProvider.getStrModuleId(moduleId), [], function () { }, null, null);
            }
            // Find any 'local' error handlers, walk the entire chain of inverse dependencies if necessary.
            var seenModuleId = [];
            for (var i = 0, len = this._moduleIdProvider.getMaxModuleId(); i < len; i++) {
                seenModuleId[i] = false;
            }
            var someoneNotified = false;
            var queue = [];
            queue.push(moduleId);
            seenModuleId[moduleId] = true;
            while (queue.length > 0) {
                var queueElement = queue.shift();
                var m = this._modules2[queueElement];
                if (m) {
                    someoneNotified = m.onDependencyError(error) || someoneNotified;
                }
                var inverseDeps = this._inverseDependencies2[queueElement];
                if (inverseDeps) {
                    for (var i = 0, len = inverseDeps.length; i < len; i++) {
                        var inverseDep = inverseDeps[i];
                        if (!seenModuleId[inverseDep]) {
                            queue.push(inverseDep);
                            seenModuleId[inverseDep] = true;
                        }
                    }
                }
            }
            if (!someoneNotified) {
                this._config.onError(error);
            }
        };
        /**
         * Walks (recursively) the dependencies of 'from' in search of 'to'.
         * Returns true if there is such a path or false otherwise.
         * @param from Module id to start at
         * @param to Module id to look for
         */
        ModuleManager.prototype._hasDependencyPath = function (fromId, toId) {
            var from = this._modules2[fromId];
            if (!from) {
                return false;
            }
            var inQueue = [];
            for (var i = 0, len = this._moduleIdProvider.getMaxModuleId(); i < len; i++) {
                inQueue[i] = false;
            }
            var queue = [];
            // Insert 'from' in queue
            queue.push(from);
            inQueue[fromId] = true;
            while (queue.length > 0) {
                // Pop first inserted element of queue
                var element = queue.shift();
                var dependencies = element.dependencies;
                if (dependencies) {
                    // Walk the element's dependencies
                    for (var i = 0, len = dependencies.length; i < len; i++) {
                        var dependency = dependencies[i];
                        if (dependency.id === toId) {
                            // There is a path to 'to'
                            return true;
                        }
                        var dependencyModule = this._modules2[dependency.id];
                        if (dependencyModule && !inQueue[dependency.id]) {
                            // Insert 'dependency' in queue
                            inQueue[dependency.id] = true;
                            queue.push(dependencyModule);
                        }
                    }
                }
            }
            // There is no path to 'to'
            return false;
        };
        /**
         * Walks (recursively) the dependencies of 'from' in search of 'to'.
         * Returns cycle as array.
         * @param from Module id to start at
         * @param to Module id to look for
         */
        ModuleManager.prototype._findCyclePath = function (fromId, toId, depth) {
            if (fromId === toId || depth === 50) {
                return [fromId];
            }
            var from = this._modules2[fromId];
            if (!from) {
                return null;
            }
            // Walk the element's dependencies
            var dependencies = from.dependencies;
            if (dependencies) {
                for (var i = 0, len = dependencies.length; i < len; i++) {
                    var path = this._findCyclePath(dependencies[i].id, toId, depth + 1);
                    if (path !== null) {
                        path.push(fromId);
                        return path;
                    }
                }
            }
            return null;
        };
        /**
         * Create the local 'require' that is passed into modules
         */
        ModuleManager.prototype._createRequire = function (moduleIdResolver) {
            var _this = this;
            var result = (function (dependencies, callback, errorback) {
                return _this._relativeRequire(moduleIdResolver, dependencies, callback, errorback);
            });
            result.toUrl = function (id) {
                return _this._config.requireToUrl(moduleIdResolver.resolveModule(id));
            };
            result.getStats = function () {
                return _this.getLoaderEvents();
            };
            result.hasDependencyCycle = function () {
                return _this._hasDependencyCycle;
            };
            result.config = function (params, shouldOverwrite) {
                if (shouldOverwrite === void 0) { shouldOverwrite = false; }
                _this.configure(params, shouldOverwrite);
            };
            result.__$__nodeRequire = AMDLoader.global.nodeRequire;
            return result;
        };
        ModuleManager.prototype._loadModule = function (moduleId) {
            var _this = this;
            if (this._modules2[moduleId] || this._knownModules2[moduleId]) {
                // known module
                return;
            }
            this._knownModules2[moduleId] = true;
            var strModuleId = this._moduleIdProvider.getStrModuleId(moduleId);
            var paths = this._config.moduleIdToPaths(strModuleId);
            var scopedPackageRegex = /^@[^\/]+\/[^\/]+$/; // matches @scope/package-name
            if (this._env.isNode && (strModuleId.indexOf('/') === -1 || scopedPackageRegex.test(strModuleId))) {
                paths.push('node|' + strModuleId);
            }
            var lastPathIndex = -1;
            var loadNextPath = function (err) {
                lastPathIndex++;
                if (lastPathIndex >= paths.length) {
                    // No more paths to try
                    _this._onLoadError(moduleId, err);
                }
                else {
                    var currentPath_1 = paths[lastPathIndex];
                    var recorder_1 = _this.getRecorder();
                    if (_this._config.isBuild() && currentPath_1 === 'empty:') {
                        _this._buildInfoPath[moduleId] = currentPath_1;
                        _this.defineModule(_this._moduleIdProvider.getStrModuleId(moduleId), [], null, null, null);
                        _this._onLoad(moduleId);
                        return;
                    }
                    recorder_1.record(10 /* BeginLoadingScript */, currentPath_1);
                    _this._scriptLoader.load(_this, currentPath_1, function () {
                        if (_this._config.isBuild()) {
                            _this._buildInfoPath[moduleId] = currentPath_1;
                        }
                        recorder_1.record(11 /* EndLoadingScriptOK */, currentPath_1);
                        _this._onLoad(moduleId);
                    }, function (err) {
                        recorder_1.record(12 /* EndLoadingScriptError */, currentPath_1);
                        loadNextPath(err);
                    });
                }
            };
            loadNextPath(null);
        };
        /**
         * Resolve a plugin dependency with the plugin loaded & complete
         * @param module The module that has this dependency
         * @param pluginDependency The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized
         * @param plugin The plugin (what the plugin exports)
         */
        ModuleManager.prototype._loadPluginDependency = function (plugin, pluginDependency) {
            var _this = this;
            if (this._modules2[pluginDependency.id] || this._knownModules2[pluginDependency.id]) {
                // known module
                return;
            }
            this._knownModules2[pluginDependency.id] = true;
            // Delegate the loading of the resource to the plugin
            var load = (function (value) {
                _this.defineModule(_this._moduleIdProvider.getStrModuleId(pluginDependency.id), [], value, null, null);
            });
            load.error = function (err) {
                _this._config.onError(_this._createLoadError(pluginDependency.id, err));
            };
            plugin.load(pluginDependency.pluginParam, this._createRequire(ModuleIdResolver.ROOT), load, this._config.getOptionsLiteral());
        };
        /**
         * Examine the dependencies of module 'module' and resolve them as needed.
         */
        ModuleManager.prototype._resolve = function (module) {
            var _this = this;
            var dependencies = module.dependencies;
            if (dependencies) {
                for (var i = 0, len = dependencies.length; i < len; i++) {
                    var dependency = dependencies[i];
                    if (dependency === RegularDependency.EXPORTS) {
                        module.exportsPassedIn = true;
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    if (dependency === RegularDependency.MODULE) {
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    if (dependency === RegularDependency.REQUIRE) {
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    var dependencyModule = this._modules2[dependency.id];
                    if (dependencyModule && dependencyModule.isComplete()) {
                        if (dependencyModule.error) {
                            module.onDependencyError(dependencyModule.error);
                            return;
                        }
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    if (this._hasDependencyPath(dependency.id, module.id)) {
                        this._hasDependencyCycle = true;
                        console.warn('There is a dependency cycle between \'' + this._moduleIdProvider.getStrModuleId(dependency.id) + '\' and \'' + this._moduleIdProvider.getStrModuleId(module.id) + '\'. The cyclic path follows:');
                        var cyclePath = this._findCyclePath(dependency.id, module.id, 0) || [];
                        cyclePath.reverse();
                        cyclePath.push(dependency.id);
                        console.warn(cyclePath.map(function (id) { return _this._moduleIdProvider.getStrModuleId(id); }).join(' => \n'));
                        // Break the cycle
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    // record inverse dependency
                    this._inverseDependencies2[dependency.id] = this._inverseDependencies2[dependency.id] || [];
                    this._inverseDependencies2[dependency.id].push(module.id);
                    if (dependency instanceof PluginDependency) {
                        var plugin = this._modules2[dependency.pluginId];
                        if (plugin && plugin.isComplete()) {
                            this._loadPluginDependency(plugin.exports, dependency);
                            continue;
                        }
                        // Record dependency for when the plugin gets loaded
                        var inversePluginDeps = this._inversePluginDependencies2.get(dependency.pluginId);
                        if (!inversePluginDeps) {
                            inversePluginDeps = [];
                            this._inversePluginDependencies2.set(dependency.pluginId, inversePluginDeps);
                        }
                        inversePluginDeps.push(dependency);
                        this._loadModule(dependency.pluginId);
                        continue;
                    }
                    this._loadModule(dependency.id);
                }
            }
            if (module.unresolvedDependenciesCount === 0) {
                this._onModuleComplete(module);
            }
        };
        ModuleManager.prototype._onModuleComplete = function (module) {
            var _this = this;
            var recorder = this.getRecorder();
            if (module.isComplete()) {
                // already done
                return;
            }
            var dependencies = module.dependencies;
            var dependenciesValues = [];
            if (dependencies) {
                for (var i = 0, len = dependencies.length; i < len; i++) {
                    var dependency = dependencies[i];
                    if (dependency === RegularDependency.EXPORTS) {
                        dependenciesValues[i] = module.exports;
                        continue;
                    }
                    if (dependency === RegularDependency.MODULE) {
                        dependenciesValues[i] = {
                            id: module.strId,
                            config: function () {
                                return _this._config.getConfigForModule(module.strId);
                            }
                        };
                        continue;
                    }
                    if (dependency === RegularDependency.REQUIRE) {
                        dependenciesValues[i] = this._createRequire(module.moduleIdResolver);
                        continue;
                    }
                    var dependencyModule = this._modules2[dependency.id];
                    if (dependencyModule) {
                        dependenciesValues[i] = dependencyModule.exports;
                        continue;
                    }
                    dependenciesValues[i] = null;
                }
            }
            module.complete(recorder, this._config, dependenciesValues);
            // Fetch and clear inverse dependencies
            var inverseDeps = this._inverseDependencies2[module.id];
            this._inverseDependencies2[module.id] = null;
            if (inverseDeps) {
                // Resolve one inverse dependency at a time, always
                // on the lookout for a completed module.
                for (var i = 0, len = inverseDeps.length; i < len; i++) {
                    var inverseDependencyId = inverseDeps[i];
                    var inverseDependency = this._modules2[inverseDependencyId];
                    inverseDependency.unresolvedDependenciesCount--;
                    if (inverseDependency.unresolvedDependenciesCount === 0) {
                        this._onModuleComplete(inverseDependency);
                    }
                }
            }
            var inversePluginDeps = this._inversePluginDependencies2.get(module.id);
            if (inversePluginDeps) {
                // This module is used as a plugin at least once
                // Fetch and clear these inverse plugin dependencies
                this._inversePluginDependencies2.delete(module.id);
                // Resolve plugin dependencies one at a time
                for (var i = 0, len = inversePluginDeps.length; i < len; i++) {
                    this._loadPluginDependency(module.exports, inversePluginDeps[i]);
                }
            }
        };
        return ModuleManager;
    }());
    AMDLoader.ModuleManager = ModuleManager;
})(AMDLoader || (AMDLoader = {}));
var define;
var AMDLoader;
(function (AMDLoader) {
    var env = new AMDLoader.Environment();
    var moduleManager = null;
    var DefineFunc = function (id, dependencies, callback) {
        if (typeof id !== 'string') {
            callback = dependencies;
            dependencies = id;
            id = null;
        }
        if (typeof dependencies !== 'object' || !Array.isArray(dependencies)) {
            callback = dependencies;
            dependencies = null;
        }
        if (!dependencies) {
            dependencies = ['require', 'exports', 'module'];
        }
        if (id) {
            moduleManager.defineModule(id, dependencies, callback, null, null);
        }
        else {
            moduleManager.enqueueDefineAnonymousModule(dependencies, callback);
        }
    };
    DefineFunc.amd = true;
    var _requireFunc_config = function (params, shouldOverwrite) {
        if (shouldOverwrite === void 0) { shouldOverwrite = false; }
        moduleManager.configure(params, shouldOverwrite);
    };
    var RequireFunc = function () {
        if (arguments.length === 1) {
            if ((arguments[0] instanceof Object) && !Array.isArray(arguments[0])) {
                _requireFunc_config(arguments[0]);
                return;
            }
            if (typeof arguments[0] === 'string') {
                return moduleManager.synchronousRequire(arguments[0]);
            }
        }
        if (arguments.length === 2 || arguments.length === 3) {
            if (Array.isArray(arguments[0])) {
                moduleManager.defineModule(AMDLoader.Utilities.generateAnonymousModule(), arguments[0], arguments[1], arguments[2], null);
                return;
            }
        }
        throw new Error('Unrecognized require call');
    };
    RequireFunc.config = _requireFunc_config;
    RequireFunc.getConfig = function () {
        return moduleManager.getConfig().getOptionsLiteral();
    };
    RequireFunc.reset = function () {
        moduleManager = moduleManager.reset();
    };
    RequireFunc.getBuildInfo = function () {
        return moduleManager.getBuildInfo();
    };
    RequireFunc.getStats = function () {
        return moduleManager.getLoaderEvents();
    };
    RequireFunc.define = DefineFunc;
    RequireFunc.defined = function(module){
        let moduleId = moduleManager._moduleIdProvider.getModuleId(module);
        if (moduleManager._modules2[moduleId])
            return true;
        return false;
    };
    function init() {
        if (typeof AMDLoader.global.require !== 'undefined' || typeof require !== 'undefined') {
            var _nodeRequire = (AMDLoader.global.require || require);
            if (typeof _nodeRequire === 'function' && typeof _nodeRequire.resolve === 'function') {
                // re-expose node's require function
                var nodeRequire = AMDLoader.ensureRecordedNodeRequire(moduleManager.getRecorder(), _nodeRequire);
                AMDLoader.global.nodeRequire = nodeRequire;
                RequireFunc.nodeRequire = nodeRequire;
                RequireFunc.__$__nodeRequire = nodeRequire;
            }
        }
        if (env.isNode && !env.isElectronRenderer && !env.isElectronNodeIntegrationWebWorker) {
            module.exports = RequireFunc;
            require = RequireFunc;
        }
        else {
            if (!env.isElectronRenderer) {
                AMDLoader.global.define = DefineFunc;
            }
            AMDLoader.global.require = RequireFunc;
        }
    }
    AMDLoader.init = init;
    if (typeof AMDLoader.global.define !== 'function' || !AMDLoader.global.define.amd) {
        moduleManager = new AMDLoader.ModuleManager(env, AMDLoader.createScriptLoader(env), DefineFunc, RequireFunc, AMDLoader.Utilities.getHighPerformanceTimestamp());
        // The global variable require can configure the loader
        if (typeof AMDLoader.global.require !== 'undefined' && typeof AMDLoader.global.require !== 'function') {
            RequireFunc.config(AMDLoader.global.require);
        }
        // This define is for the local closure defined in node in the case that the loader is concatenated
        define = function () {
            return DefineFunc.apply(null, arguments);
        };
        define.amd = DefineFunc.amd;
        if (typeof doNotInitLoader === 'undefined') {
            init();
        }
    }
})(AMDLoader || (AMDLoader = {}));
/*!-----------------------------------------------------------
* Copyright (c) IJS Technologies. All rights reserved.
* Released under dual BUSL-1.1/commercial license
* https://ijs.network
*-----------------------------------------------------------*/

; (function (globalObject) {
  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multiformats/blob/master/LICENSE-MIT
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/digest.js#L66

  class Digest {
    constructor(code, size, digest, bytes) {
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  }

  const readonly = { writable: false, configurable: false, enumerable: true }
  const hidden = { writable: false, enumerable: false, configurable: false }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L78
  class Decoder {

    constructor(name, prefix, baseDecode) {
      this.name = name
      this.prefix = prefix
      this.baseDecode = baseDecode
    }

    decode(text) {
      if (typeof text === 'string') {
        switch (text[0]) {
          case this.prefix: {
            return this.baseDecode(text.slice(1))
          }
          default: {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)
          }
        }
      } else {
        throw Error('Can only multibase decode strings')
      }
    }

    or(decoder) {
      return or(this, decoder)
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L29
  class Encoder {

    constructor(name, prefix, baseEncode) {
      this.name = name
      this.prefix = prefix
      this.baseEncode = baseEncode
    }

    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`
      } else {
        throw Error('Unknown type, must be binary type')
      }
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L195
  class Codec {

    constructor(name, prefix, baseEncode, baseDecode) {
      this.name = name
      this.prefix = prefix
      this.baseEncode = baseEncode
      this.baseDecode = baseDecode
      this.encoder = new Encoder(name, prefix, baseEncode)
      this.decoder = new Decoder(name, prefix, baseDecode)
    }

    encode(input) {
      return this.encoder.encode(input)
    }

    decode(input) {
      return this.decoder.decode(input)
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L236
  const from_1 = ({ name, prefix, encode, decode }) =>
    new Codec(name, prefix, encode, decode)

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/base-x.js#L6
  function _basex(ALPHABET, name) {
    if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    function encode(source) {
      if (source instanceof Uint8Array); else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from_1(source);
      }
      if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
      if (source.length === 0) { return '' }
      // Skip & count leading zeroes.
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      // Allocate enough space in big-endian base58 representation.
      var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
      var b58 = new Uint8Array(size);
      // Process the bytes.
      while (pbegin !== pend) {
        var carry = source[pbegin];
        // Apply "b58 = b58 * 256 + ch".
        var i = 0;
        for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
          carry += (256 * b58[it1]) >>> 0;
          b58[it1] = (carry % BASE) >>> 0;
          carry = (carry / BASE) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        pbegin++;
      }
      // Skip leading zeroes in base58 result.
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      // Translate the result into a string.
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
      return str
    }
    function decodeUnsafe(source) {
      if (typeof source !== 'string') { throw new TypeError('Expected String') }
      if (source.length === 0) { return new Uint8Array() }
      var psz = 0;
      // Skip leading spaces.
      if (source[psz] === ' ') { return }
      // Skip and count leading '1's.
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      // Allocate enough space in big-endian base256 representation.
      var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
      var b256 = new Uint8Array(size);
      // Process the characters.
      while (source[psz]) {
        // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)];
        // Invalid character
        if (carry === 255) { return }
        var i = 0;
        for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
          carry += (BASE * b256[it3]) >>> 0;
          b256[it3] = (carry % 256) >>> 0;
          carry = (carry / 256) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        psz++;
      }
      // Skip trailing spaces.
      if (source[psz] === ' ') { return }
      // Skip leading zeroes in b256.
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j = zeroes;
      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }
      return vch
    }
    function decode(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) { return buffer }
      throw new Error(`Non-${name} character`)
    }
    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L248
  const baseX = ({ prefix, name, alphabet }) => {
    const { encode, decode } = _basex(alphabet, name)
    return from_1({
      prefix,
      name,
      encode,
      decode: text => coerce(decode(text))
    })
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L321
  const _encode = (data, alphabet, bitsPerChar) => {
    const pad = alphabet[alphabet.length - 1] === '='
    const mask = (1 << bitsPerChar) - 1
    let out = ''

    let bits = 0 // Number of bits currently in the buffer
    let buffer = 0 // Bits waiting to be written out, MSB first
    for (let i = 0; i < data.length; ++i) {
      // Slurp data into the buffer:
      buffer = (buffer << 8) | data[i]
      bits += 8

      // Write out as much as we can:
      while (bits > bitsPerChar) {
        bits -= bitsPerChar
        out += alphabet[mask & (buffer >> bits)]
      }
    }

    // Partial character:
    if (bits) {
      out += alphabet[mask & (buffer << (bitsPerChar - bits))]
    }

    // Add padding characters until we hit a byte boundary:
    if (pad) {
      while ((out.length * bitsPerChar) & 7) {
        out += '='
      }
    }

    return out
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L268
  const _decode = (string, alphabet, bitsPerChar, name) => {
    const codes = {}
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i
    }

    // Count the padding bytes:
    let end = string.length
    while (string[end - 1] === '=') {
      --end
    }

    const out = new Uint8Array((end * bitsPerChar / 8) | 0)

    let bits = 0
    let buffer = 0
    let written = 0
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]]
      if (value === undefined) {
        throw new SyntaxError(`Non-${name} character`)
      }

      buffer = (buffer << bitsPerChar) | value
      bits += bitsPerChar

      if (bits >= 8) {
        bits -= 8
        out[written++] = 0xff & (buffer >> bits)
      }
    }

    if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
      throw new SyntaxError('Unexpected end of data')
    }

    return out
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L366
  const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
    return from_1({
      prefix,
      name,
      encode(input) {
        return _encode(input, alphabet, bitsPerChar)
      },
      decode(input) {
        return _decode(input, alphabet, bitsPerChar, name)
      }
    })
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base58.js#L3
  const base58btc = baseX({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  })

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base32.js#L3
  const base32 = rfc4648({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  })

  const CODE_DAG_PB = 0x70
  const CODE_RAW = 0x55

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L58
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L68
  var encodingLength_2 = function (value) {
    return (
      value < N1 ? 1
        : value < N2 ? 2
          : value < N3 ? 3
            : value < N4 ? 4
              : value < N5 ? 5
                : value < N6 ? 6
                  : value < N7 ? 7
                    : value < N8 ? 8
                      : value < N9 ? 9
                        : 10
    )
  };

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L30
  var MSB$1 = 0x80
    , REST$1 = 0x7F
    , MSBALL = ~REST
    , INT = Math.pow(2, 31);

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L33
  function decode_2(buf, offset) {
    var res = 0
      , offset = offset || 0
      , shift = 0
      , counter = offset
      , b
      , l = buf.length;

    do {
      if (counter >= l) {
        decode_2.bytes = 0;
        throw new RangeError('Could not decode varint')
      }
      b = buf[counter++];
      res += shift < 28
        ? (b & REST$1) << shift
        : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1)

    decode_2.bytes = counter - offset;

    return res
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/varint.js#L7
  const decode_1 = (data) => {
    const code = decode_2(data)
    return [code, decode_2.bytes]
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L8
  function encode_2(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0
      throw new RangeError('Could not encode varint')
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;

    while (num >= INT) {
      out[offset++] = (num & 0xFF) | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = (num & 0xFF) | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;

    encode_2.bytes = offset - oldOffset + 1;

    return out
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/varint.js#L17
  const encodeTo_1 = (int, target, offset = 0) => {
    encode_2(int, target, offset)
    return target
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/varint.js#L26
  const encodingLength_1 = (int) => {
    return encodingLength_2(int)
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L382
  const parseCIDtoBytes = (source, base) => {
    switch (source[0]) {
      case 'Q': {
        const decoder = base || base58btc
        return [base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)]
      }
      case base58btc.prefix: {
        const decoder = base || base58btc
        return [base58btc.prefix, decoder.decode(source)]
      }
      case base32.prefix: {
        const decoder = base || base32
        return [base32.prefix, decoder.decode(source)]
      }
      default: {
        if (base == null) {
          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
        }
        return [source[0], base.decode(source)]
      }
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L412
  const toStringV0 = (bytes, cache, base) => {
    const { prefix } = base
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base.name} encoding`)
    }

    const cid = cache.get(prefix)
    if (cid == null) {
      const cid = base.encode(bytes).slice(1)
      cache.set(prefix, cid)
      return cid
    } else {
      return cid
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L434
  const toStringV1 = (bytes, cache, base) => {
    const { prefix } = base
    const cid = cache.get(prefix)
    if (cid == null) {
      const cid = base.encode(bytes)
      cache.set(prefix, cid)
      return cid
    } else {
      return cid
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L455
  const encodeCID = (version, code, multihash) => {
    const codeOffset = encodingLength_1(version)
    const hashOffset = codeOffset + encodingLength_1(code)
    const bytes = new Uint8Array(hashOffset + multihash.byteLength)
    encodeTo_1(version, bytes, 0)
    encodeTo_1(code, bytes, codeOffset)
    bytes.set(multihash, hashOffset)
    return bytes
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bytes.js#L39
  const coerce = o => {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o
    if (o instanceof ArrayBuffer) return new Uint8Array(o)
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
    }
    throw new Error('Unknown type, must be binary type')
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L22
  class CID {

    constructor(version, code, multihash, bytes) {
      this.code = code
      this.version = version
      this.multihash = multihash
      this.bytes = bytes
      this.byteOffset = bytes.byteOffset
      this.byteLength = bytes.byteLength
      this.asCID = this
      this._baseCache = new Map()

      Object.defineProperties(this, {
        byteOffset: hidden,
        byteLength: hidden,

        code: readonly,
        version: readonly,
        multihash: readonly,
        bytes: readonly,

        _baseCache: hidden,
        asCID: hidden
      })
    }

    toString(base) {
      const { bytes, version, _baseCache } = this
      switch (version) {
        case 0:
          return toStringV0(bytes, _baseCache, base || base58btc.encoder)
        default:
          return toStringV1(bytes, _baseCache, base || base32.encoder)
      }
    }

    static create(version, code, digest) {
      if (typeof code !== 'number') {
        throw new Error('String codecs are no longer supported')
      }

      switch (version) {
        case 0: {
          if (code !== CODE_DAG_PB) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${CODE_DAG_PB}) block encoding`)
          } else {
            return new CID(version, code, digest, digest.bytes)
          }
        }
        case 1: {
          const bytes = encodeCID(version, code, digest.bytes)
          return new CID(version, code, digest, bytes)
        }
        default: {
          throw new Error('Invalid version')
        }
      }
    }

    static parse(source, base) {
      const [prefix, bytes] = parseCIDtoBytes(source, base)

      const cid = CID.decode(bytes)
      cid._baseCache.set(prefix, source)

      return cid
    }

    static decode(bytes) {
      const [cid, remainder] = CID.decodeFirst(bytes)
      if (remainder.length) {
        throw new Error('Incorrect length')
      }
      return cid
    }

    static decodeFirst(bytes) {
      const specs = CID.inspectBytes(bytes)
      const prefixSize = specs.size - specs.multihashSize
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize))
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error('Incorrect length')
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize)
      const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes)
      const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest)
      return [cid, bytes.subarray(specs.size)]
    }

    static inspectBytes(initialBytes) {
      let offset = 0
      const next = () => {
        const [i, length] = decode_1(initialBytes.subarray(offset))
        offset += length
        return i
      }

      let version = next()
      let codec = CODE_DAG_PB
      if (version === 18) { // CIDv0
        version = 0
        offset = 0
      } else if (version === 1) {
        codec = next()
      }

      if (version !== 0 && version !== 1) {
        throw new RangeError(`Invalid CID version ${version}`)
      }

      const prefixSize = offset
      const multihashCode = next()
      const digestSize = next()
      const size = offset + digestSize
      const multihashSize = size - prefixSize

      return { version, codec, multihashCode, digestSize, multihashSize, size }
    }

    static createV0(digest) {
      return CID.create(0, CODE_DAG_PB, digest)
    }

    static createV1(code, digest) {
      return CID.create(1, code, digest)
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/digest.js#L10
  const create = (code, digest) => {
    const size = digest.byteLength
    const sizeOffset = encodingLength_1(code)
    const digestOffset = sizeOffset + encodingLength_1(size)

    const bytes = new Uint8Array(digestOffset + size)
    encodeTo_1(code, bytes, 0)
    encodeTo_1(size, bytes, sizeOffset)
    bytes.set(digest, digestOffset)

    return new Digest(code, size, digest, bytes)
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/hasher.js#L22
  class Hasher {

    constructor(name, code, encode) {
      this.name = name
      this.code = code
      this.encode = encode
    }

    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input)
        return result instanceof Uint8Array
          ? create(this.code, result)
          : result.then((digest) => create(this.code, digest))
      } else {
        throw Error('Unknown type, must be binary type')
      }
    }
  }

  const from = ({ name, code, encode }) => new Hasher(name, code, encode)

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/sha2.js#L7
  const s_sha256 = from({
    name: 'sha2-256',
    code: 18,
    //encode: (input) => coerce(crypto__default["default"].createHash('sha256').update(input).digest())
    encode: (input) => {
      return coerce(createHash('sha256').update(input).digest());
    }
  });

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2016, Daniel Wirtz  All rights reserved.
  *  https://github.com/protobufjs/protobuf.js/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/
  var protobuf = {};//exports;

  protobuf.build = "minimal";

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/lib/inquire/index.js#L10
  const util_inquire = function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) { }
    return null;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/minimal.js#L126
  const util_Buffer = (function () {
    try {
      var Buffer = util_inquire("buffer").Buffer;
      return Buffer.prototype.utf8Write ? Buffer : null;
    } catch (e) {
      return null;
    }
  })();

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L21
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = undefined;
    this.val = val;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L49
  function noop() { }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L91
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L14
  function util_LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L37
  var zero = util_LongBits.zero = new util_LongBits(0, 0);

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L55
  util_LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0,
      hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new util_LongBits(lo, hi);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L80
  util_LongBits.from = function from(value) {
    if (typeof value === "number")
      return util_LongBits.fromNumber(value);
    if (util_isString(value)) {
      if (util_Long)
        value = util_Long.fromString(value);
      else
        return util_LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new util_LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  util_LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L187
  util_LongBits.prototype.length = function length() {
    var part0 = this.lo,
      part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
      part2 = this.hi >>> 24;
    return part2 === 0
      ? part1 === 0
        ? part0 < 16384
          ? part0 < 128 ? 1 : 2
          : part0 < 2097152 ? 3 : 4
        : part1 < 16384
          ? part1 < 128 ? 5 : 6
          : part1 < 2097152 ? 7 : 8
      : part2 < 128 ? 9 : 10;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L242
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L261
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = util_LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L166
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/minimal.js#L79
  const util_isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };

  var invalidEncoding = "invalid encoding";
  var s64 = new Array(123);

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/lib/base64/index.js#L96
  const base64_decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0,
      t;
    for (var i = 0; i < string.length;) {
      var c = string.charCodeAt(i++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L172
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/lib/base64/index.js#L15
  const base64_length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };

  var util_Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L359
  var writeBytes = util_Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }
    : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L374
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util_isString(value)) {
      var buf = Writer.alloc(len = base64_length(value));
      base64_decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L124
  var w1_create = function w1_create() {
    return util_Buffer
      ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      }
      : function create_array() {
        return new Writer();
      };
  };

  Writer.create = w1_create();

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L176
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L193
  function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  }

  VarintOp.prototype.fn = writeVarint32;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L207
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0)
        < 128 ? 1
        : value < 16384 ? 2
          : value < 2097152 ? 3
            : value < 268435456 ? 4
              : 5,
      value)).len;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L227
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0
      ? this._push(writeVarint64, 10, util_LongBits.fromNumber(value))
      : this.uint32(value);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L149
  Writer.alloc = function alloc(size) {
    return new util_Array(size);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer_buffer.js#L6
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L448
  Writer.prototype.finish = function finish() {
    var head = this.head.next,
      buf = this.constructor.alloc(this.len),
      pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L461
  Writer._configure = function (BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = w1_create();
    BufferWriter._configure();
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L22
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
  })();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L123
  function readLongVarint() {
    var bits = new util_LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
  }
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L43
  var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }
    : function create_array(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L56
  var r1_create = function r1_create() {
    return util_Buffer
      ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
          return util_Buffer.isBuffer(buffer)
            ? new BufferReader(buffer)
            : create_array(buffer);
        })(buffer);
      }
      : create_array;
  };
  Reader.create = r1_create();
  Reader.prototype._slice = util_Array.prototype.subarray || /* istanbul ignore next */ util_Array.prototype.slice;
  
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/minimal.js#L237
  function util_merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
      if (dst[keys[i]] === undefined || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L334
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L382
  Reader._configure = function (BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = r1_create();
    BufferReader._configure();

    var fn = "toNumber";
    util_merge(Reader.prototype, {

      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },

      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      }
    });
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer_buffer.js#L16
  function BufferWriter() {
    Writer.call(this);
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L374
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util_isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/lib/utf8/index.js#L15
  function utf8_length(string) {
    var len = 0,
      c = 0;
    for (var i = 0; i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L391
  Writer.prototype.string = function write_string(value) {
    var len = utf8_length(value);
    return len
      ? this.uint32(len)._push(utf8.write, len, value)
      : this._push(writeByte, 1, 0);
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L207
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0)
        < 128 ? 1
        : value < 16384 ? 2
          : value < 2097152 ? 3
            : value < 268435456 ? 4
              : 5,
      value)).len;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L59
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L403
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L414
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L431
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
      tail = this.tail,
      len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next; // skip noop
      this.tail = tail;
      this.len += len;
    }
    return this;
  };

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) Feross Aboukhadijeh, and other contributors.
  *  Licensed under the MIT License.
  *  https://github.com/feross/buffer/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L98
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }

  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
  Object.setPrototypeOf(Buffer, Uint8Array)

  const K_MAX_LENGTH = 0x7fffffff

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L322
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
        'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L78
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    const buf = new Uint8Array(length)
    Object.setPrototypeOf(buf, Buffer.prototype)
    return buf
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L182
  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L214
  function allocUnsafe(size) {
    assertSize(size)
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L222
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer_buffer.js#L20
  BufferWriter._configure = function () {

    BufferWriter.alloc = Buffer.allocUnsafe

    BufferWriter.writeBytesBuffer = util_Buffer && util_Buffer.prototype instanceof Uint8Array && util_Buffer.prototype.set.name === "set"
      ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      }
      : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;)
          buf[pos++] = val[i++];
      };
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader_buffer.js#L6
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader_buffer.js#L17
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader_buffer.js#L27
  BufferReader._configure = function () {
    if (util_Buffer)
      BufferReader.prototype._slice = util_Buffer.prototype.slice;
  };

  protobuf.rpc = {};
  protobuf.roots = {};
  protobuf.configure = configure;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/index-minimal.js#L29
  function configure() {
    // util_configure();
    Writer._configure(BufferWriter);
    Reader._configure(BufferReader);
  }

  configure();

  var $protobuf = protobuf;
  var $protobuf__default = _interopDefaultLegacy($protobuf);

  /*---------------------------------------------------------------------------------------------
*  Licensed under the MIT License.
*  https://github.com/IndigoUnited/js-err-code/blob/8dd437663a48e833ab70223f8a58a888985d1e3a/README.md
*--------------------------------------------------------------------------------------------*/

  //https://github.com/IndigoUnited/js-err-code/blob/8dd437663a48e833ab70223f8a58a888985d1e3a/index.js#L15
  function assign(obj, props) {
    for (const key in props) {
      Object.defineProperty(obj, key, {
        value: props[key],
        enumerable: true,
        configurable: true,
      });
    }

    return obj;
  }

  //https://github.com/IndigoUnited/js-err-code/blob/8dd437663a48e833ab70223f8a58a888985d1e3a/index.js#L34
  function createError(err, code, props) {
    if (!err || typeof err === 'string') {
      throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
      props = {};
    }

    if (typeof code === 'object') {
      props = code;
      code = '';
    }

    if (code) {
      props.code = code;
    }

    try {
      return assign(err, props);
    } catch (_) {
      props.message = err.message;
      props.stack = err.stack;

      const ErrClass = function () { };

      ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

      // @ts-ignore
      const output = assign(new ErrClass(), props);

      return output;
    }
  }

  var errcode = createError;

  function _interopDefaultLegacy(e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
  var errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);

  /*---------------------------------------------------------------------------------------------
  *  Licensed under the MIT License.
  *  https://github.com/ipfs/js-ipfs-unixfs/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/unixfs.js#L8
  const $root = $protobuf__default["default"].roots['ipfs-unixfs'] || ($protobuf__default["default"].roots['ipfs-unixfs'] = {});

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/unixfs.js#L10
  const Data = $root.Data = (() => {
    function Data(p) {
      this.blocksizes = [];
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    Data.prototype.Type = 0;
    Data.prototype.filesize = 0;
    Data.prototype.hashType = 0;
    Data.prototype.fanout = 0;
    Data.prototype.mode = 0;
    Data.prototype.mtime = null;
    Data.encode = function encode(m, w) {
      if (!w) {
        w = Writer.create();
      }
      w.uint32(8).int32(m.Type);
      if (m.Data != null && Object.hasOwnProperty.call(m, 'Data')) {
        w.uint32(18).bytes(m.Data);
      }
      if (m.filesize != null && Object.hasOwnProperty.call(m, 'filesize')) {
        w.uint32(24).uint64(m.filesize); // here is the bug
      }
      if (m.blocksizes != null && m.blocksizes.length) {
        for (var i = 0; i < m.blocksizes.length; ++i)
          w.uint32(32).uint64(m.blocksizes[i]);
      }
      if (m.hashType != null && Object.hasOwnProperty.call(m, 'hashType')) {
        w.uint32(40).uint64(m.hashType);
      }
      if (m.fanout != null && Object.hasOwnProperty.call(m, 'fanout')) {
        w.uint32(48).uint64(m.fanout);
      }

      if (m.mode != null && Object.hasOwnProperty.call(m, 'mode')) {
        w.uint32(56).uint32(m.mode);
      }

      if (m.mtime != null && Object.hasOwnProperty.call(m, 'mtime')) {
        $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
      }

      return w;
    };
    Data.decode = function decode(r, l) {
      if (!(r instanceof Reader))
        r = Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.Type = r.int32();
            break;
          case 2:
            m.Data = r.bytes();
            break;
          case 3:
            m.filesize = r.uint64();
            break;
          case 4:
            if (!(m.blocksizes && m.blocksizes.length))
              m.blocksizes = [];
            if ((t & 7) === 2) {
              var c2 = r.uint32() + r.pos;
              while (r.pos < c2)
                m.blocksizes.push(r.uint64());
            } else
              m.blocksizes.push(r.uint64());
            break;
          case 5:
            m.hashType = r.uint64();
            break;
          case 6:
            m.fanout = r.uint64();
            break;
          case 7:
            m.mode = r.uint32();
            break;
          case 8:
            m.mtime = $root.UnixTime.decode(r, r.uint32());
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Data.fromObject = function fromObject(d) {
      if (d instanceof $root.Data)
        return d;
      var m = new $root.Data();
      switch (d.Type) {
        case 'Raw':
        case 0:
          m.Type = 0;
          break;
        case 'Directory':
        case 1:
          m.Type = 1;
          break;
        case 'File':
        case 2:
          m.Type = 2;
          break;
      }
      return m;
    };
    Data.toObject = function toObject(m, o) {
      if (!o)
          o = {};
      var d = {};
      if (o.arrays || o.defaults) {
          d.blocksizes = [];
      }
      if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
              d.Data = "";
          else {
              d.Data = [];
              if (o.bytes !== Array)
                  d.Data = $util.newBuffer(d.Data);
          }
          if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
              d.filesize = o.longs === String ? "0" : 0;
          if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
              d.hashType = o.longs === String ? "0" : 0;
          if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
              d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
      }
      if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
      }
      if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
      }
      if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
              d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
              d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
      }
      if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
              if (typeof m.blocksizes[j] === "number")
                  d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
              else
                  d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
      }
      if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
              d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
              d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
      }
      if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
              d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
              d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
      }
      if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
      }
      if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root.UnixTime.toObject(m.mtime, o);
      }
      return d;
    };
    Data.DataType = function () {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'Raw'] = 0;
      values[valuesById[1] = 'Directory'] = 1;
      values[valuesById[2] = 'File'] = 2;
      return values;
    }();
    return Data;
  })();

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L10
  const types = [
    'raw',
    'directory',
    'file',
    'metadata',
    'symlink',
    'hamt-sharded-directory'
  ];

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L19
  const dirTypes = [
    'directory',
    'hamt-sharded-directory'
  ];

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L30
  function parseMode(mode) {
    if (mode == null) {
      return undefined;
    }
    if (typeof mode === 'number') {
      return mode & 4095;
    }
    mode = mode.toString();
    if (mode.substring(0, 1) === '0') {
      return parseInt(mode, 8) & 4095;
    }
    return parseInt(mode, 10) & 4095;
  }

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L53
  function parseMtime(input) {
    if (input == null) {
      return undefined;
    }
    let mtime;
    if (input.secs != null) {
      mtime = {
        secs: input.secs,
        nsecs: input.nsecs
      };
    }
    if (input.Seconds != null) {
      mtime = {
        secs: input.Seconds,
        nsecs: input.FractionalNanoseconds
      };
    }
    if (Array.isArray(input)) {
      mtime = {
        secs: input[0],
        nsecs: input[1]
      };
    }
    if (input instanceof Date) {
      const ms = input.getTime();
      const secs = Math.floor(ms / 1000);
      mtime = {
        secs: secs,
        nsecs: (ms - secs * 1000) * 1000
      };
    }
    if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
      return undefined;
    }
    if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
      throw errcode__default["default"](new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');
    }
    return mtime;
  }

  const PBData = Data;

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L24
  const DEFAULT_FILE_MODE = parseInt('0644', 8);
  const DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L122
  class UnixFS {
    static unmarshal (marshaled) {
      const message = PBData.decode(marshaled)
      const decoded = PBData.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      })
      const data = new UnixFS({
        type: types[decoded.Type],
        data: decoded.Data,
        blockSizes: decoded.blocksizes,
        mode: decoded.mode,
        mtime: decoded.mtime
          ? {
              secs: decoded.mtime.Seconds,
              nsecs: decoded.mtime.FractionalNanoseconds
            }
          : undefined
      })
      data._originalMode = decoded.mode || 0;
      return data
    };
    constructor(options = { type: 'file' }) {
      const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
      if (type && !types.includes(type)) {
        throw errcode__default["default"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
      }
      this.type = type || 'file';
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes || [];
      this._originalMode = 0;
      this.mode = parseMode(mode);
      if (mtime) {
        this.mtime = parseMtime(mtime);
        if (this.mtime && !this.mtime.nsecs) {
          this.mtime.nsecs = 0;
        }
      }
    }
    set mode(mode) {
      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
      const parsedMode = parseMode(mode);
      if (parsedMode !== undefined) {
        this._mode = parsedMode;
      }
    }
    get mode() {
      return this._mode;
    }
    isDirectory() {
      return Boolean(this.type && dirTypes.includes(this.type));
    }
    addBlockSize(size) {
      this.blockSizes.push(size)
    }
    fileSize() {
      if (this.isDirectory()) {
        return 0;
      }
      let sum = 0;
      this.blockSizes.forEach(size => {
        sum += size;
      });
      if (this.data) {
        sum += this.data.length;
      }
      return sum;
    }
    marshal() {
      let type;
      switch (this.type) {
        case 'raw':
          type = PBData.DataType.Raw;
          break;
        case 'directory':
          type = PBData.DataType.Directory;
          break;
        case 'file':
          type = PBData.DataType.File;
          break;
        case 'metadata':
          type = PBData.DataType.Metadata;
          break;
        case 'symlink':
          type = PBData.DataType.Symlink;
          break;
        case 'hamt-sharded-directory':
          type = PBData.DataType.HAMTShard;
          break;
        default:
          throw errcode__default["default"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
      }
      let data = this.data;
      if (!this.data || !this.data.length) {
        data = undefined;
      }
      let mode;
      if (this.mode != null) {
        mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
        if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
          mode = undefined;
        }
        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
          mode = undefined;
        }
      }
      let mtime;
      if (this.mtime != null) {
        const parsed = parseMtime(this.mtime);
        if (parsed) {
          mtime = {
            Seconds: parsed.secs,
            FractionalNanoseconds: parsed.nsecs
          };
          if (mtime.FractionalNanoseconds === 0) {
            delete mtime.FractionalNanoseconds;
          }
        }
      }
      const pbData = {
        Type: type,
        Data: data,
        filesize: this.isDirectory() ? undefined : this.fileSize(),
        blocksizes: this.blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode,
        mtime
      };
      return PBData.encode(pbData).finish();
    }
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020-2021 Yusuke Kawasaki
  *  Licensed under the MIT License.
  *  https://github.com/kawanet/sha256-uint8array/blob/main/LICENSE
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L36
  const algorithms = {
    sha256: 1,
  };

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L40
  function createHash(algorithm) {
    if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {
      throw new Error("Digest method not supported");
    }
    return new Hash();
  }

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L6
  const K = [
    0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0,
    0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0,
    0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0,
    0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0,
    0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0,
    0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0,
    0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0,
    0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0,
    0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0,
    0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0,
    0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0,
    0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0,
    0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0,
    0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0,
    0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0,
    0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0,
  ];

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L48
  class Hash {
    constructor() {
      // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
      this.A = 0x6a09e667 | 0;
      this.B = 0xbb67ae85 | 0;
      this.C = 0x3c6ef372 | 0;
      this.D = 0xa54ff53a | 0;
      this.E = 0x510e527f | 0;
      this.F = 0x9b05688c | 0;
      this.G = 0x1f83d9ab | 0;
      this.H = 0x5be0cd19 | 0;
      this._size = 0;
      this._sp = 0; // surrogate pair
      if (!sharedBuffer || sharedOffset >= 8000 /* allocTotal */) {
        sharedBuffer = new ArrayBuffer(8000 /* allocTotal */);
        sharedOffset = 0;
      }
      this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80 /* allocBytes */);
      this._word = new Int32Array(sharedBuffer, sharedOffset, 20 /* allocWords */);
      sharedOffset += 80 /* allocBytes */;
    }
    update(data) {
      // data: string
      if ("string" === typeof data) {
        return this._utf8(data);
      }
      // data: undefined
      if (data == null) {
        throw new TypeError("Invalid type: " + typeof data);
      }
      const byteOffset = data.byteOffset;
      const length = data.byteLength;
      let blocks = (length / 64 /* inputBytes */) | 0;
      let offset = 0;
      // longer than 1 block
      if (blocks && !(byteOffset & 3) && !(this._size % 64 /* inputBytes */)) {
        const block = new Int32Array(data.buffer, byteOffset, blocks * 16 /* inputWords */);
        while (blocks--) {
          this._int32(block, offset >> 2);
          offset += 64 /* inputBytes */;
        }
        this._size += offset;
      }
      // data: TypedArray | DataView
      const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;
      if (BYTES_PER_ELEMENT !== 1 && data.buffer) {
        const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);
        return this._uint8(rest);
      }
      // no more bytes
      if (offset === length)
        return this;
      // data: Uint8Array | Int8Array
      return this._uint8(data, offset);
    }
    _uint8(data, offset) {
      const { _byte, _word } = this;
      const length = data.length;
      offset = offset | 0;
      while (offset < length) {
        const start = this._size % 64 /* inputBytes */;
        let index = start;
        while (offset < length && index < 64 /* inputBytes */) {
          _byte[index++] = data[offset++];
        }
        if (index >= 64 /* inputBytes */) {
          this._int32(_word);
        }
        this._size += index - start;
      }
      return this;
    }
    _utf8(text) {
      const { _byte, _word } = this;
      const length = text.length;
      let surrogate = this._sp;
      for (let offset = 0; offset < length;) {
        const start = this._size % 64 /* inputBytes */;
        let index = start;
        while (offset < length && index < 64 /* inputBytes */) {
          let code = text.charCodeAt(offset++) | 0;
          if (code < 0x80) {
            // ASCII characters
            _byte[index++] = code;
          }
          else if (code < 0x800) {
            // 2 bytes
            _byte[index++] = 0xC0 | (code >>> 6);
            _byte[index++] = 0x80 | (code & 0x3F);
          }
          else if (code < 0xD800 || code > 0xDFFF) {
            // 3 bytes
            _byte[index++] = 0xE0 | (code >>> 12);
            _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);
            _byte[index++] = 0x80 | (code & 0x3F);
          }
          else if (surrogate) {
            // 4 bytes - surrogate pair
            code = ((surrogate & 0x3FF) << 10) + (code & 0x3FF) + 0x10000;
            _byte[index++] = 0xF0 | (code >>> 18);
            _byte[index++] = 0x80 | ((code >>> 12) & 0x3F);
            _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);
            _byte[index++] = 0x80 | (code & 0x3F);
            surrogate = 0;
          }
          else {
            surrogate = code;
          }
        }
        if (index >= 64 /* inputBytes */) {
          this._int32(_word);
          _word[0] = _word[16 /* inputWords */];
        }
        this._size += index - start;
      }
      this._sp = surrogate;
      return this;
    }
    _int32(data, offset) {
      let { A, B, C, D, E, F, G, H } = this;
      let i = 0;
      offset = offset | 0;
      while (i < 16 /* inputWords */) {
        W[i++] = swap32(data[offset++]);
      }
      for (i = 16 /* inputWords */; i < 64 /* workWords */; i++) {
        W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;
      }
      for (i = 0; i < 64 /* workWords */; i++) {
        const T1 = (H + sigma1(E) + ch(E, F, G) + K[i] + W[i]) | 0;
        const T2 = (sigma0(A) + maj(A, B, C)) | 0;
        H = G;
        G = F;
        F = E;
        E = (D + T1) | 0;
        D = C;
        C = B;
        B = A;
        A = (T1 + T2) | 0;
      }
      this.A = (A + this.A) | 0;
      this.B = (B + this.B) | 0;
      this.C = (C + this.C) | 0;
      this.D = (D + this.D) | 0;
      this.E = (E + this.E) | 0;
      this.F = (F + this.F) | 0;
      this.G = (G + this.G) | 0;
      this.H = (H + this.H) | 0;
    }
    digest(encoding) {
      const { _byte, _word } = this;
      let i = (this._size % 64 /* inputBytes */) | 0;
      _byte[i++] = 0x80;
      // pad 0 for current word
      while (i & 3) {
        _byte[i++] = 0;
      }
      i >>= 2;
      if (i > 14 /* highIndex */) {
        while (i < 16 /* inputWords */) {
          _word[i++] = 0;
        }
        i = 0;
        this._int32(_word);
      }
      // pad 0 for rest words
      while (i < 16 /* inputWords */) {
        _word[i++] = 0;
      }
      // input size
      const bits64 = this._size * 8;
      const low32 = (bits64 & 0xffffffff) >>> 0;
      const high32 = (bits64 - low32) / 0x100000000;
      if (high32)
        _word[14 /* highIndex */] = swap32(high32);
      if (low32)
        _word[15 /* lowIndex */] = swap32(low32);
      this._int32(_word);
      return (encoding === "hex") ? this._hex() : this._bin();
    }
    _hex() {
      const { A, B, C, D, E, F, G, H } = this;
      return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);
    }
    _bin() {
      const { A, B, C, D, E, F, G, H, _byte, _word } = this;
      _word[0] = swap32(A);
      _word[1] = swap32(B);
      _word[2] = swap32(C);
      _word[3] = swap32(D);
      _word[4] = swap32(E);
      _word[5] = swap32(F);
      _word[6] = swap32(G);
      _word[7] = swap32(H);
      return _byte.slice(0, 32);
    }
  }

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L290
  const W = new Int32Array(64 /* workWords */);
  let sharedBuffer;
  let sharedOffset = 0;
  const hex32 = num => (num + 0x100000000).toString(16).substr(-8);
  const swapLE = (c => (((c << 24) & 0xff000000) | ((c << 8) & 0xff0000) | ((c >> 8) & 0xff00) | ((c >> 24) & 0xff)));
  const swapBE = (c => c);
  const swap32 = isBE() ? swapBE : swapLE;
  const ch = (x, y, z) => (z ^ (x & (y ^ z)));
  const maj = (x, y, z) => ((x & y) | (z & (x | y)));
  const sigma0 = x => ((x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10));
  const sigma1 = x => ((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7));
  const gamma0 = x => ((x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3));
  const gamma1 = x => ((x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10));

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L308
  function isBE() {
    const buf = new Uint8Array(new Uint16Array([0xFEFF]).buffer); // BOM
    return (buf[0] === 0xFE);
  }

  var MSB = 0x80
    , REST = 0x7F
    , MSBALL = ~REST
    , INT = Math.pow(2, 31);

  /*---------------------------------------------------------------------------------------------
  *  Copyright 2016-2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/ipld/js-dag-pb/blob/master/LICENSE-MIT
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L8
  const pbNodeProperties = ['Data', 'Links']
  const pbLinkProperties = ['Hash', 'Name', 'Tsize']

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L1
  const textEncoder = new TextEncoder();
  const maxInt32 = 2 ** 32
  const maxUInt32 = 2 ** 31

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L197
  const len8tab = [
    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
  ]

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L23
  function encodeLink(link, bytes) {
    let i = bytes.length

    if (typeof link.Tsize === 'number') {
      if (link.Tsize < 0) {
        throw new Error('Tsize cannot be negative')
      }
      if (!Number.isSafeInteger(link.Tsize)) {
        throw new Error('Tsize too large for encoding')
      }
      i = encodeVarint(bytes, i, link.Tsize) - 1
      bytes[i] = 0x18
    }

    if (typeof link.Name === 'string') {
      const nameBytes = textEncoder.encode(link.Name)
      i -= nameBytes.length
      bytes.set(nameBytes, i)
      i = encodeVarint(bytes, i, nameBytes.length) - 1
      bytes[i] = 0x12
    }

    if (link.Hash) {
      i -= link.Hash.length
      bytes.set(link.Hash, i)
      i = encodeVarint(bytes, i, link.Hash.length) - 1
      bytes[i] = 0xa
    }

    return bytes.length - i
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L91
  function sizeLink(link) {
    let n = 0

    if (link.Hash) {
      const l = link.Hash.length
      n += 1 + l + sov(l)
    }

    if (typeof link.Name === 'string') {
      const l = textEncoder.encode(link.Name).length
      n += 1 + l + sov(l)
    }

    if (typeof link.Tsize === 'number') {
      n += 1 + sov(link.Tsize)
    }

    return n
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L179
  function len64(x) {
    let n = 0
    if (x >= maxInt32) {
      x = Math.floor(x / maxInt32)
      n = 32
    }
    if (x >= (1 << 16)) {
      x >>>= 16
      n += 16
    }
    if (x >= (1 << 8)) {
      x >>>= 8
      n += 8
    }
    return n + len8tab[x]
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L166
  function sov(x) {
    if (x % 2 === 0) {
      x++
    }
    return Math.floor((len64(x) + 6) / 7)
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L141
  function encodeVarint(bytes, offset, v) {
    offset -= sov(v)
    const base = offset

    while (v >= maxUInt32) {
      bytes[offset++] = (v & 0x7f) | 0x80
      v /= 128
    }

    while (v >= 128) {
      bytes[offset++] = (v & 0x7f) | 0x80
      v >>>= 7
    }

    bytes[offset] = v

    return base
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L141
  function sizeNode(node) {
    let n = 0

    if (node.Data) {
      const l = node.Data.length
      n += 1 + l + sov(l)
    }

    if (node.Links) {
      for (const link of node.Links) {
        const l = sizeLink(link)
        n += 1 + l + sov(l)
      }
    }

    return n
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L61
  function encodeNode(node) {
    const size = sizeNode(node)
    const bytes = new Uint8Array(size)
    let i = size

    if (node.Data) {
      i -= node.Data.length
      bytes.set(node.Data, i)
      i = encodeVarint(bytes, i, node.Data.length) - 1
      bytes[i] = 0xa
    }

    if (node.Links) {
      for (let index = node.Links.length - 1; index >= 0; index--) {
        const size = encodeLink(node.Links[index], bytes.subarray(0, i))
        i -= size
        i = encodeVarint(bytes, i, size) - 1
        bytes[i] = 0x12
      }
    }

    return bytes
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L18
  function linkComparator(a, b) {
    if (a === b) {
      return 0
    }

    const abuf = a.Name ? textEncoder.encode(a.Name) : []
    const bbuf = b.Name ? textEncoder.encode(b.Name) : []

    let x = abuf.length
    let y = bbuf.length

    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (abuf[i] !== bbuf[i]) {
        x = abuf[i]
        y = bbuf[i]
        break
      }
    }

    return x < y ? -1 : y < x ? 1 : 0
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L45
  function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p) => !properties.includes(p))
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L147
  function validate(node) {

    if (!node || typeof node !== 'object' || Array.isArray(node)) {
      throw new TypeError('Invalid DAG-PB form')
    }

    if (!hasOnlyProperties(node, pbNodeProperties)) {
      throw new TypeError('Invalid DAG-PB form (extraneous properties)')
    }

    if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {
      throw new TypeError('Invalid DAG-PB form (Data must be a Uint8Array)')
    }

    if (!Array.isArray(node.Links)) {
      throw new TypeError('Invalid DAG-PB form (Links must be an array)')
    }

    for (let i = 0; i < node.Links.length; i++) {
      const link = node.Links[i]
      if (!link || typeof link !== 'object' || Array.isArray(link)) {
        throw new TypeError('Invalid DAG-PB form (bad link object)')
      }

      if (!hasOnlyProperties(link, pbLinkProperties)) {
        throw new TypeError('Invalid DAG-PB form (extraneous properties on link object)')
      }

      if (!link.Hash) {
        throw new TypeError('Invalid DAG-PB form (link must have a Hash)')
      }

      if (link.Hash.asCID !== link.Hash) {
        throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')
      }

      if (link.Name !== undefined && typeof link.Name !== 'string') {
        throw new TypeError('Invalid DAG-PB form (link Name must be a string)')
      }

      if (link.Tsize !== undefined && (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0)) {
        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')
      }

      if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
        throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')
      }
    }
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L16
  var decodeVarint = (bytes, offset) => {
    let v = 0
  
    for (let shift = 0; ; shift += 7) {
      /* c8 ignore next 3 */
      if (shift >= 64) {
        throw new Error('protobuf: varint overflow')
      }
      /* c8 ignore next 3 */
      if (offset >= bytes.length) {
        throw new Error('protobuf: unexpected end of data')
      }
  
      const b = bytes[offset++]
      v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)
      if (b < 0x80) {
        break
      }
    }
    return [v, offset]
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L43
  var decodeBytes = (bytes, offset) => {
    let byteLen
    ;[byteLen, offset] = decodeVarint(bytes, offset)
    const postOffset = offset + byteLen
  
    /* c8 ignore next 3 */
    if (byteLen < 0 || postOffset < 0) {
      throw new Error('protobuf: invalid length')
    }
    /* c8 ignore next 3 */
    if (postOffset > bytes.length) {
      throw new Error('protobuf: unexpected end of data')
    }
  
    return [bytes.subarray(offset, postOffset), postOffset]
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L65
  var decodeKey = (bytes, index) => {
    let wire
    ;[wire, index] = decodeVarint(bytes, index);
    return [wire & 0x7, wire >> 3, index]
  };
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L141
  var decodeNode =(bytes) => {
    const l = bytes.length
    let index = 0
    let links
    let linksBeforeData = false
    let data
    while (index < l) {
      let wireType, fieldNum
      ;[wireType, fieldNum, index] = decodeKey(bytes, index)

      if (wireType !== 2) {
        throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)
      }
      if (fieldNum === 1) {
        if (data) {
          throw new Error('protobuf: (PBNode) duplicate Data section')
        }

        ;[data, index] = decodeBytes(bytes, index)
        if (links) {
          linksBeforeData = true
        }
      } else if (fieldNum === 2) {
        if (linksBeforeData) { // interleaved Links/Dode/Links
          throw new Error('protobuf: (PBNode) duplicate Links section')
        } else if (!links) {
          links = []
        }
        let byts
        ;[byts, index] = decodeBytes(bytes, index)
        links.push(decodeLink(byts))
      } else {
        throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)
      }
    }
    if (index > l) {
      throw new Error('protobuf: (PBNode) unexpected end of data')
    }
    const node = {}
    if (data) {
      node.Data = data
    }
    node.Links = links || []
    return node
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L76
  var decodeLink = (bytes) => {
    const link = {}
    const l = bytes.length
    let index = 0
  
    while (index < l) {
      let wireType, fieldNum
      ;[wireType, fieldNum, index] = decodeKey(bytes, index)
  
      if (fieldNum === 1) {
        if (link.Hash) {
          throw new Error('protobuf: (PBLink) duplicate Hash section')
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)
        }
        if (link.Name !== undefined) {
          throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')
        }
        if (link.Tsize !== undefined) {
          throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')
        }
  
        ;[link.Hash, index] = decodeBytes(bytes, index)
      } else if (fieldNum === 2) {
        if (link.Name !== undefined) {
          throw new Error('protobuf: (PBLink) duplicate Name section')
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)
        }
        if (link.Tsize !== undefined) {
          throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')
        }
  
        let byts
        ;[byts, index] = decodeBytes(bytes, index)
        link.Name = textDecoder.decode(byts)
      } else if (fieldNum === 3) {
        if (link.Tsize !== undefined) {
          throw new Error('protobuf: (PBLink) duplicate Tsize section')
        }
        if (wireType !== 0) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)
        }
  
        ;[link.Tsize, index] = decodeVarint(bytes, index)
      } else {
        throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)
      }
    }  
    /* c8 ignore next 3 */
    if (index > l) {
      throw new Error('protobuf: (PBLink) unexpected end of data')
    }  
    return link
  };
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/index.js#L53
  var d_decode = (bytes) => {
    const pbn = decodeNode(bytes)
    const node = {}
    if (pbn.Data) {
      node.Data = pbn.Data
    }
    if (pbn.Links) {
      node.Links = pbn.Links.map((l) => {
        const link = {}
        try {
          link.Hash = CID.decode(l.Hash)
        } catch (e) {}
        if (!link.Hash) {
          throw new Error('Invalid Hash field found in link, expected CID')
        }
        if (l.Name !== undefined) {
          link.Name = l.Name
        }
        if (l.Tsize !== undefined) {
          link.Tsize = l.Tsize
        }
        return link
      })
    }
    return node
  };
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/index.js#L23
  var d_encode = (node) => {
    validate(node)
    const pbn = {}
    if (node.Links) {
      pbn.Links = node.Links.map((l) => {
        const link = {}
        if (l.Hash) {
          link.Hash = l.Hash.bytes // cid -> bytes
        }
        if (l.Name !== undefined) {
          link.Name = l.Name
        }
        if (l.Tsize !== undefined) {
          link.Tsize = l.Tsize
        }
        return link
      })
    }
    if (node.Data) {
      pbn.Data = node.Data
    }

    return encodeNode(pbn)
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2016-2018 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/ipld/js-ipld-dag-pb/blob/master/LICENSE.md
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-node/sortLinks.js#L28
  const sortLinks = (links) => {
    const sort = stable;
    sort.inplace(links, linkSort)
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-node/sortLinks.js#L15
  const linkSort = (a, b) => {
    const buf1 = a.nameAsBuffer
    const buf2 = b.nameAsBuffer

    return uint8ArrayCompare(buf1, buf2)
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-link/dagLink.js#L9
  class DAGLink {
    constructor(name, size, cid) {
      if (!cid) {
        throw new Error('A link requires a cid to point to')
      }
      this.Name = name || ''
      this.Tsize = size
      this.Hash = new CID1(cid)

      Object.defineProperties(this, {
        _nameBuf: { value: null, writable: true, enumerable: false }
      })
    }

    toString() {
      return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`
    }

    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          name: this.Name,
          size: this.Tsize,
          cid: this.Hash.toBaseEncodedString()
        })
      }

      return Object.assign({}, this._json)
    }
    get nameAsBuffer() {
      if (this._nameBuf != null) {
        return this._nameBuf
      }

      this._nameBuf = uint8ArrayFromString(this.Name)
      return this._nameBuf
    }
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-node/dagNode.js#L18
  class DAGNode {

    constructor(data, links = [], serializedSize = null) {
      if (!data) {
        data = new Uint8Array(0)
      }
      if (typeof data === 'string') {
        data = uint8ArrayFromString(data)
      }

      if (!(data instanceof Uint8Array)) {
        throw new Error('Passed \'data\' is not a Uint8Array or a String!')
      }

      if (serializedSize !== null && typeof serializedSize !== 'number') {
        throw new Error('Passed \'serializedSize\' must be a number!')
      }

      const sortedLinks = links.map((link) => {
        return link instanceof DAGLink
          ? link
          : createDagLinkFromB58EncodedHash(link)
      })
      sortLinks(sortedLinks)

      this.Data = data
      this.Links = sortedLinks

      Object.defineProperties(this, {
        _serializedSize: { value: serializedSize, writable: true, enumerable: false },
        _size: { value: null, writable: true, enumerable: false }
      })
    }

    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          data: this.Data,
          links: this.Links.map((l) => l.toJSON()),
          size: this.size
        })
      }

      return Object.assign({}, this._json)
    }

    toString() {
      return `DAGNode <data: "${uint8ArrayToString(this.Data, 'base64urlpad')}", links: ${this.Links.length}, size: ${this.size}>`
    }

    _invalidateCached() {
      this._serializedSize = null
      this._size = null
    }

    /**
     * @param {DAGLink | import('../types').DAGLinkLike} link
     */
    addLink(link) {
      this._invalidateCached()
      return addLink(this, link)
    }

    /**
     * @param {DAGLink | string | CID} link
     */
    rmLink(link) {
      this._invalidateCached()
      return rmLink(this, link)
    }

    /**
     * @param {import('./toDagLink').ToDagLinkOptions} [options]
     */
    toDAGLink(options) {
      return toDAGLink(this, options)
    }

    serialize() {
      const buf = serializeDAGNode(this)

      this._serializedSize = buf.length

      return buf
    }

    get size() {
      if (this._size == null) {
        let serializedSize

        if (serializedSize == null) {
          this._serializedSize = this.serialize().length
          serializedSize = this._serializedSize
        }

        this._size = this.Links.reduce((sum, l) => sum + l.Tsize, serializedSize)
      }

      return this._size
    }

    set size(size) {
      throw new Error("Can't set property: 'size' is immutable")
    }
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/serialize.js#L23
  const toProtoBuf = (node) => {
    const pbn = {}

    if (node.Data && node.Data.byteLength > 0) {
      pbn.Data = node.Data
    } else {
      // NOTE: this has to be null in order to match go-ipfs serialization
      // `null !== new Uint8Array(0)`
      pbn.Data = null
    }

    if (node.Links && node.Links.length > 0) {
      pbn.Links = node.Links
        .map((link) => ({
          Hash: link.Hash.bytes,
          Name: link.Name,
          Tsize: link.Tsize
        }))
    } else {
      pbn.Links = null
    }

    return pbn
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/serialize.js#L53
  const serializeDAGNode = (node) => {
    return encode(toProtoBuf(node))
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag.js#L31
  function PBLink(p) {
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag.js#L71
  PBLink.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.Hash != null && Object.hasOwnProperty.call(m, "Hash"))
      w.uint32(10).bytes(m.Hash);
    if (m.Name != null && Object.hasOwnProperty.call(m, "Name"))
      w.uint32(18).string(m.Name);
    if (m.Tsize != null && Object.hasOwnProperty.call(m, "Tsize"))
      w.uint32(24).uint64(m.Tsize);
    return w;
  };

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/serialize.js#L87
  function encode(pbf) {
    const writer = Writer.create()

    if (pbf.Links != null) {
      for (let i = 0; i < pbf.Links.length; i++) {
        PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim()
      }
    }

    if (pbf.Data != null) {
      writer.uint32(10).bytes(pbf.Data)
    }

    return writer.finish()
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2013-2019 bl contributors
  *  Licensed under the MIT License.
  *  https://github.com/rvagg/bl/blob/master/LICENSE.md
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L4
  const symbol = Symbol.for('BufferList')
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf)
    }

    BufferList._init.call(this, buf)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L14
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, { value: true })

    this._bufs = []
    this.length = 0

    if (buf) {
      this.append(buf)
    }
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L25
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L29
  BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0]
    }

    let tot = 0

    for (let i = 0; i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot]
      }
      tot = _t
    }
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L45
  BufferList.prototype._reverseOffset = function (blOffset) {
    const bufferId = blOffset[0]
    let offset = blOffset[1]

    for (let i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length
    }

    return offset
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L56
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return undefined
    }

    const offset = this._offset(index)

    return this._bufs[offset[0]][offset[1]]
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L66
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === 'number' && start < 0) {
      start += this.length
    }

    if (typeof end === 'number' && end < 0) {
      end += this.length
    }

    return this.copy(null, 0, start, end)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L78
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== 'number' || srcStart < 0) {
      srcStart = 0
    }

    if (typeof srcEnd !== 'number' || srcEnd > this.length) {
      srcEnd = this.length
    }

    if (srcStart >= this.length) {
      return dst || Buffer.alloc(0)
    }

    if (srcEnd <= 0) {
      return dst || Buffer.alloc(0)
    }

    const copy = !!dst
    const off = this._offset(srcStart)
    const len = srcEnd - srcStart
    let bytes = len
    let bufoff = (copy && dstStart) || 0
    let start = off[1]

    // copy/slice everything
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy) {
        // slice, but full concat if multiple buffers
        return this._bufs.length === 1
          ? this._bufs[0]
          : util_Buffer.concat(this._bufs, this.length)
      }

      // copy, need to copy individual buffers
      for (let i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff)
        bufoff += this._bufs[i].length
      }

      return dst
    }

    // easy, cheap case where it's a subset of one of the buffers
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy
        ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
        : this._bufs[off[0]].slice(start, start + bytes)
    }

    if (!copy) {
      // a slice, we need something to copy in to
      dst = Buffer.allocUnsafe(len)
    }

    for (let i = off[0]; i < this._bufs.length; i++) {
      const l = this._bufs[i].length - start

      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start)
        bufoff += l
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes)
        bufoff += l
        break
      }

      bytes -= l

      if (start) {
        start = 0
      }
    }

    // safeguard so that we don't return uninitialized memory
    if (dst.length > bufoff) return dst.slice(0, bufoff)

    return dst
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L157
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0
    end = typeof end !== 'number' ? this.length : end

    if (start < 0) {
      start += this.length
    }

    if (end < 0) {
      end += this.length
    }

    if (start === end) {
      return this._new()
    }

    const startOffset = this._offset(start)
    const endOffset = this._offset(end)
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

    if (endOffset[1] === 0) {
      buffers.pop()
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])
    }

    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1])
    }

    return this._new(buffers)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L190
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L194
  BufferList.prototype.consume = function consume(bytes) {
    // first, normalize the argument, in accordance with how Buffer does it
    bytes = Math.trunc(bytes)
    // do nothing if not a positive number
    if (Number.isNaN(bytes) || bytes <= 0) return this

    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length
        this.length -= this._bufs[0].length
        this._bufs.shift()
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes)
        this.length -= bytes
        break
      }
    }

    return this
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L215
  BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new()

    for (let i = 0; i < this._bufs.length; i++) {
      copy.append(this._bufs[i])
    }

    return copy
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L225
  BufferList.prototype.append = function append(buf) {
    if (buf == null) {
      return this
    }

    if (buf.buffer) {
      // append a view of the underlying ArrayBuffer
      this._appendBuffer(util_Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.append(buf[i])
      }
    } else if (this._isBufferList(buf)) {
      // unwrap argument into individual BufferLists
      for (let i = 0; i < buf._bufs.length; i++) {
        this.append(buf._bufs[i])
      }
    } else {
      // coerce number arguments to strings, since Buffer(number) does
      // uninitialized memory allocation
      if (typeof buf === 'number') {
        buf = buf.toString()
      }

      this._appendBuffer(util_Buffer.from(buf))
    }

    return this
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L255
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf)
    this.length += buf.length
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L260
  BufferList.prototype.indexOf = function (search, offset, encoding) {
    if (encoding === undefined && typeof offset === 'string') {
      encoding = offset
      offset = undefined
    }

    if (typeof search === 'function' || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
    } else if (typeof search === 'number') {
      search = util_Buffer.from([search])
    } else if (typeof search === 'string') {
      search = util_Buffer.from(search, encoding)
    } else if (this._isBufferList(search)) {
      search = search.slice()
    } else if (Array.isArray(search.buffer)) {
      search = util_Buffer.from(search.buffer, search.byteOffset, search.byteLength)
    } else if (!Buffer.isBuffer(search)) {
      search = util_Buffer.from(search)
    }

    offset = Number(offset || 0)

    if (isNaN(offset)) {
      offset = 0
    }

    if (offset < 0) {
      offset = this.length + offset
    }

    if (offset < 0) {
      offset = 0
    }

    if (search.length === 0) {
      return offset > this.length ? this.length : offset
    }

    const blOffset = this._offset(offset)
    let blIndex = blOffset[0] // index of which internal buffer we're working on
    let buffOffset = blOffset[1] // offset of the internal buffer we're working on

    // scan over each buffer
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex]

      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset

        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset)

          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult])
          }

          buffOffset = buff.length - search.length + 1 // end of native search window
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset])

          if (this._match(revOffset, search)) {
            return revOffset
          }

          buffOffset++
        }
      }

      buffOffset = 0
    }

    return -1
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L334
  BufferList.prototype._match = function (offset, search) {
    if (this.length - offset < search.length) {
      return false
    }

    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false
      }
    }
    return true
  }

    //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L347
    ; (function () {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      }

      for (const m in methods) {
        (function (m) {
          if (methods[m] === null) {
            BufferList.prototype[m] = function (offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m](0, byteLength)
            }
          } else {
            BufferList.prototype[m] = function (offset = 0) {
              return this.slice(offset, offset + methods[m])[m](0)
            }
          }
        }(m))
      }
    }())

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L388
  BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L392
  BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol]
  }

  // No license(?)
  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/util/bases.js#L15
  function createCodec(name, prefix, encode, decode) {
    return {
      name,
      prefix,
      encoder: {
        name,
        prefix,
        encode
      },
      decoder: { decode }
    };
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/util/bases.js#L30
  const string = createCodec('utf8', 'u', buf => {
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
  }, str => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/util/bases.js#L63
  var bases = {
    utf8: string,
    'utf-8': string,
  };

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/to-string.js#L18
  function uint8ArrayToString(array, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    return base.encoder.encode(array).substring(1);
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/alloc.js#L24
  function allocUnsafe(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
      return globalThis.Buffer.allocUnsafe(size);
    }
    return new Uint8Array(size);
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/concat.js#L9
  function uint8ArrayConcat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = allocUnsafe(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/compare.js#L7
  function uint8ArrayCompare(a, b) {
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] < b[i]) {
        return -1
      }

      if (a[i] > b[i]) {
        return 1
      }
    }

    if (a.byteLength > b.byteLength) {
      return 1
    }

    if (a.byteLength < b.byteLength) {
      return -1
    }

    return 0
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/from-string.js#L18
  function uint8ArrayFromString(string, encoding = 'utf8') {
    const base = bases[encoding]

    if (!base) {
      throw new Error(`Unsupported encoding "${encoding}"`)
    }

    return base.decoder.decode(`${base.prefix}${string}`)
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multihash/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/constants.js#L18
  const mh_names = Object.freeze({
    'sha2-256': 0x12,
  })

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L13
  const mh_codes = /** @type {import('./types').CodeNameMap} */({})
  for (const key in mh_names) {
    const name = /** @type {HashName} */(key)
    mh_codes[mh_names[name]] = name
  }
  Object.freeze(mh_codes)

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L28
  function mh_toHexString(hash) {
    if (!(hash instanceof Uint8Array)) {
      throw new Error('must be passed a Uint8Array')
    }

    return uint8ArrayToString(hash, 'base16')
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L42
  function mh_fromHexString(hash) {
    return uint8ArrayFromString(hash, 'base16')
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L52
  function mh_toB58String(hash) {
    if (!(hash instanceof Uint8Array)) {
      throw new Error('must be passed a Uint8Array')
    }
    return uint8ArrayToString(multibase_encode('base58btc', hash)).slice(1)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L66
  function mh_fromB58String(hash) {
    const encoded = hash instanceof Uint8Array
      ? uint8ArrayToString(hash)
      : hash

    return multibase_decode('z' + encoded)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L80
  function mh_decode(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new Error('multihash must be a Uint8Array')
    }

    if (bytes.length < 2) {
      throw new Error('multihash too short. must be > 2 bytes.')
    }

    const code = /** @type {HashCode} */(decode_2(bytes))
    if (!mh_isValidCode(code)) {
      throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
    }
    bytes = bytes.slice(decode_2.bytes)

    const len = decode_2(bytes)
    if (len < 0) {
      throw new Error(`multihash invalid length: ${len}`)
    }
    bytes = bytes.slice(decode_2.bytes)

    if (bytes.length !== len) {
      throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)
    }

    return {
      code,
      name: mh_codes[code],
      length: len,
      digest: bytes
    }
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L123
  function mh_encode(digest, code, length) {
    if (!digest || code === undefined) {
      throw new Error('multihash encode requires at least two args: digest, code')
    }
    const hashfn = mh_coerceCode(code)

    if (!(digest instanceof Uint8Array)) {
      throw new Error('digest should be a Uint8Array')
    }

    if (length == null) {
      length = digest.length
    }

    if (length && digest.length !== length) {
      throw new Error('digest length should be equal to specified length.')
    }

    function alloc_allocUnsafe(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return globalThis.Buffer.allocUnsafe(size);
      }
      return new Uint8Array(size);
    }

    const hash = encode_2(hashfn)
    const len = encode_2(length)
    function uint8ArrayConcat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc_allocUnsafe(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L155
  function mh_coerceCode(name) {
    let code = name

    if (typeof name === 'string') {
      if (mh_names[name] === undefined) {
        throw new Error(`Unrecognized hash function named: ${name}`)
      }
      code = mh_names[name]
    }

    if (typeof code !== 'number') {
      throw new Error(`Hash function code should be a number. Got: ${code}`)
    }

    if (mh_codes[code] === undefined && !mh_isAppCode(code)) {
      throw new Error(`Unrecognized function code: ${code}`)
    }

    return code
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L183
  function mh_isAppCode(code) {
    return code > 0 && code < 0x10
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L212
  function mh_validate(multihash) {
    mh_decode(multihash)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L223
  function mh_prefix(multihash) {
    mh_validate(multihash)

    return multihash.subarray(0, 2)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L193
  function mh_isValidCode(code) {
    if (mh_isAppCode(code)) {
      return true
    }

    if (mh_codes[code]) {
      return true
    }

    return false
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L229
  const multihash = {
    mh_names,
    mh_codes,
    mh_toHexString,
    mh_fromHexString,
    mh_toB58String,
    mh_fromB58String,
    mh_decode,
    mh_encode,
    mh_coerceCode,
    mh_isAppCode,
    mh_validate,
    mh_prefix,
    mh_isValidCode
  }


  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multihashing-async/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L21
  async function Multihashing(bytes, alg, length) {
    const digest = await Multihashing.digest(bytes, alg, length)
    return multihash.mh_encode(digest, alg, length)
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L29
  Multihashing.multihash = multihash

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L37
  Multihashing.digest = async (bytes, alg, length) => {
    const hash = Multihashing.createHash(alg)
    const digest = await hash(bytes)
    return length ? digest.slice(0, length) : digest
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L49
  Multihashing.createHash = function (alg) {
    if (!alg) {
      const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')
      throw e
    }
    const code = multihash.mh_coerceCode(alg)
    if (!Multihashing.functions[code]) {
      throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')
    }
    return Multihashing.functions[code]
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/sha.js#L21
  const digest = async (data, alg) => {
    switch (alg) {
      case 'sha2-256':
        return createHash('sha256').update(data).digest()
      default:
        throw new Error(`${alg} is not a supported algorithm`)
    }
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/sha.js#L38
  const { factory: sha } = {
    factory: (alg) => async (data) => {
      return digest(data, alg)
    },
    digest,
    multihashing: async (buf, alg, length) => {
      const h = await digest(buf, alg)
      return multihash.encode(h, alg, length)
    }
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/crypto.js#L53
  var crypto = {
    sha2256: sha('sha2-256'),
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L69
  Multihashing.functions = {
    0x12: crypto.sha2256,
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L114
  Multihashing.validate = async (bytes, hash) => {
    const newHash = await Multihashing(bytes, multihash.decode(hash).name)
    return equals(hash, newHash)
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs Inc
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multibase/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/base.js#L3
  const encodeText = (text) => textEncoder.encode(text)

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/base.js#L13
  class Base {
    constructor(name, code, factory, alphabet) {
      this.name = name
      this.code = code
      this.codeBuf = encodeText(this.code)
      this.alphabet = alphabet
      this.codec = factory(alphabet)
    }
    encode(buf) {
      return this.codec.encode(buf)
    }
    decode(string) {
      for (const char of string) {
        if (this.alphabet && this.alphabet.indexOf(char) < 0) {
          throw new Error(`invalid character '${char}' in '${string}'`)
        }
      }
      return this.codec.decode(string)
    }
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/rfc4648.js#L104
  const rfc4648_1 = (bitsPerChar) => (alphabet) => {
    return {
      encode(input) {
        return _encode(input, alphabet, bitsPerChar)
      },
      decode(input) {
        return _decode(input, alphabet, bitsPerChar)
      }
    }
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/constants.js#L27
  const constants = [
    ['base32', 'b', rfc4648_1(5), 'abcdefghijklmnopqrstuvwxyz234567'],
    ['base58btc', 'z', _basex, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ]

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/constants.js#L54
  const constants1_names = constants.reduce((prev, tupple) => {
    prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
    return prev
  }, /** @type {Record<BaseName,Base>} */({}))

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/constants.js#L59
  const constants1_codes = constants.reduce((prev, tupple) => {
    prev[tupple[1]] = constants1_names[tupple[0]]
    return prev
  }, /** @type {Record<BaseCode,Base>} */({}))

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L115
  function encoding(nameOrCode) {
    if (Object.prototype.hasOwnProperty.call(constants1_names, /** @type {BaseName} */(nameOrCode))) {
      return constants1_names[/** @type {BaseName} */(nameOrCode)]
    } else if (Object.prototype.hasOwnProperty.call(constants1_codes, /** @type {BaseCode} */(nameOrCode))) {
      return constants1_codes[/** @type {BaseCode} */(nameOrCode)]
    } else {
      throw new Error(`Unsupported encoding: ${nameOrCode}`)
    }
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/util.js#L24
  function concat(arrs, length) {
    const output = new Uint8Array(length)
    let offset = 0

    for (const arr of arrs) {
      output.set(arr, offset)
      offset += arr.length
    }

    return output
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/util.js#L3
  const textDecoder = new TextDecoder()
  const decodeText = (bytes) => textDecoder.decode(bytes)

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L103
  function validEncode(name, buf) {
    const enc = encoding(name)
    enc.decode(decodeText(buf))
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L23
  function multibase(nameOrCode, buf) {
    if (!buf) {
      throw new Error('requires an encoded Uint8Array')
    }
    const { name, codeBuf } = encoding(nameOrCode)
    validEncode(name, buf)

    return concat([codeBuf, buf], codeBuf.length + buf.length)
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L42
  function multibase_encode(nameOrCode, buf) {
    const enc = encoding(nameOrCode)
    const data = encodeText(enc.encode(buf))

    return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L58
  function multibase_decode(data) {
    if (data instanceof Uint8Array) {
      data = decodeText(data)
    }
    const prefix = data[0]
    if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
      data = data.toLowerCase()
    }
    const enc = encoding(/** @type {BaseCode} */(data[0]))
    return enc.decode(data.substring(1))
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2016 Friedel Ziegelmayer
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-cid/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-cid/blob/2ed9449c7a7d2df522485822ae46f2d8d10fbbcc/src/cid-util.js#L5
  const CIDUtil = {
    checkCIDComponents: function (other) {
      if (other == null) {
        return 'null values are not valid CIDs'
      }

      if (!(other.version === 0 || other.version === 1)) {
        return 'Invalid version, must be a number equal to 1 or 0'
      }

      if (typeof other.codec !== 'string') {
        return 'codec must be string'
      }

      if (other.version === 0) {
        if (other.codec !== 'dag-pb') {
          return "codec must be 'dag-pb' for CIDv0"
        }
        if (other.multibaseName !== 'base58btc') {
          return "multibaseName must be 'base58btc' for CIDv0"
        }
      }

      if (!(other.multihash instanceof Uint8Array)) {
        return 'multihash must be a Uint8Array'
      }

      try {
        var mh = multihash
        mh.mh_validate(other.multihash)
      } catch (err) {
        let errorMsg = err.message
        if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
          errorMsg = 'Multihash validation failed'
        }
        return errorMsg
      }
    }
  }

  //https://github.com/multiformats/js-cid/blob/2ed9449c7a7d2df522485822ae46f2d8d10fbbcc/src/index.js#L38
  class CID1 {
    constructor(version, codec, multihash, multibaseName) {
      this.version
      this.codec
      this.multihash

      Object.defineProperty(this, symbol, { value: true })
      if (CID1.isCID(version)) {
        const cid = /** @type {CID1} */(version)
        this.version = cid.version
        this.codec = cid.codec
        this.multihash = cid.multihash
        this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
        return
      }

      this.version = version

      this.codec = /** @type {CodecName} */ (codec)
      this.multihash = /** @type {Uint8Array} */ (multihash)
      this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

      CID1.validateCID(this)
    }

    get bytes() {
      let bytes = this._bytes

      if (!bytes) {
        if (this.version === 0) {
          bytes = this.multihash
        } else if (this.version === 1) {
          const codec = multicodec.getCodeVarint(this.codec)
          bytes = uint8ArrayConcat([
            [1], codec, this.multihash
          ], 1 + codec.byteLength + this.multihash.byteLength)
        } else {
          throw new Error('unsupported version')
        }
        Object.defineProperty(this, '_bytes', { value: bytes })
      }

      return bytes
    }

    toBaseEncodedString(base = this.multibaseName) {
      if (this.string && this.string.length !== 0 && base === this.multibaseName) {
        return this.string
      }
      let str
      if (this.version === 0) {
        if (base !== 'base58btc') {
          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
        }
        str = multihash.mh_toB58String(this.multihash)
      } else if (this.version === 1) {
        str = uint8ArrayToString(multibase_encode(base, this.bytes))
      } else {
        throw new Error('unsupported version')
      }
      if (base === this.multibaseName) {
        // cache the string value
        Object.defineProperty(this, 'string', { value: str })
      }
      return str
    }

    toString(base) {
      return this.toBaseEncodedString(base)
    }

    static validateCID(other) {
      const errorMsg = CIDUtil.checkCIDComponents(other)
      if (errorMsg) {
        throw new Error(errorMsg)
      }
    }

    static isCID(value) {
      return value instanceof CID1 || Boolean(value && value[symbol])
    }
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright  2016 Multiformats
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multicodec/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/util.js#L17
  function uint8ArrayToNumber(buf) {
    return parseInt(uint8ArrayToString(buf, 'base16'), 16)
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/util.js#L35
  function varintUint8ArrayEncode(input) {
    return Uint8Array.from(encode_2(uint8ArrayToNumber(input)))
  }

  const baseTable = Object.freeze({
    'raw': CODE_RAW,
    'dag-pb': CODE_DAG_PB,
  })

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/util.js#L42
  function varintEncode(num) {
    return Uint8Array.from(encode_2(num))
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/maps.js#L12
  const nameToVarint = /** @type {NameUint8ArrayMap} */ ({})
  const constantToCode = /** @type {ConstantCodeMap} */({})
  const codeToName = /** @type {CodeNameMap} */({})

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L111
  function getVarintFromName(name) {
    const code = nameToVarint[name]
    if (code === undefined) {
      throw new Error(`Codec "${name}" not found`)
    }
    return code
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/maps.js#L17
  for (const name in baseTable) {
    const codecName = /** @type {CodecName} */(name)
    const code = baseTable[codecName]
    nameToVarint[codecName] = varintEncode(code)

    const constant = /** @type {CodecConstant} */(codecName.toUpperCase().replace(/-/g, '_'))
    constantToCode[constant] = code

    if (!codeToName[code]) {
      codeToName[code] = codecName
    }
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/maps.js#L30
  Object.freeze(nameToVarint)
  Object.freeze(constantToCode)
  Object.freeze(codeToName)

  const multicodec = {
    //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L29
    addPrefix: function addPrefix(multicodecStrOrCode, data) {
      let prefix

      if (multicodecStrOrCode instanceof Uint8Array) {
        prefix = varintUint8ArrayEncode(multicodecStrOrCode)
      } else {
        if (nameToVarint[multicodecStrOrCode]) {
          prefix = nameToVarint[multicodecStrOrCode]
        } else {
          throw new Error('multicodec not recognized')
        }
      }

      return uint8ArrayConcat([prefix, data], prefix.length + data.length)
    },
    //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L51
    rmPrefix: function rmPrefix(data) {
      varint.decode(/** @type {Buffer} */(data))
      return data.slice(varint.decode.bytes)
    },
    //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L77
    getCodeVarint: function getCodeVarint(name) {
      return getVarintFromName(name)
    },
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (C) 2018 Angry Bytes and contributors.
  *  https://github.com/Two-Screen/stable/blob/master/README.md
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L31
  function exec(arr, comp) {
    if (typeof (comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }
    var len = arr.length;
    if (len <= 1) {
      return arr
    }
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L60
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L13
  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L17
  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  const globalThis = this;
  
  async function hashChunk(data, version){
    let size = data.length;
    const dataSize = data.length;
    let multihash;
    if (version == 0){
      const unixFS = new UnixFS({
        type: 'file',
        data: data
      })
      let bytes = d_encode({
        Data: unixFS.marshal(),
        Links: []
      })
      multihash = await Multihashing(bytes, 'sha2-256')
      size = bytes.length;
    }
    else{
      multihash = await Multihashing(data, 'sha2-256') // buffer is [Uint8Array]
    };
    let codec = version==1?'raw':'dag-pb';
    const cid = new CID1(version, codec, multihash)
    return {
      size: size,
      dataSize: dataSize,
      cid: cid
    };
  };
  async function hashChunks(chunks, version){
    let contentLength = 0;
    const unixfs = new UnixFS({
      type: 'file'
    });
    let links = [];
    for (let i = 0; i < chunks.length; i++) {
      let item = chunks[i];
      contentLength += (item.dataSize || item.size);      
      unixfs.addBlockSize(item.dataSize || item.size);
      let cid = item.cid
      if (typeof(cid) == 'string'){
        let parsed = parse(item.cid);
        cid = new CID1(version, 'raw', parsed.multihash.bytes)
      };
      links.push(new DAGLink('', item.size, cid))
    };
    const node = new DAGNode(unixfs.marshal(), links)
    const buffer = node.serialize();
    const multihash = await Multihashing(buffer, 'sha2-256') // buffer is [Uint8Array]
    const cid = new CID1(version, 'dag-pb', multihash)
    return {
      size: buffer.length + contentLength,
      type: 'file',
      cid: cid.toString(),
      bytes: buffer
    };
  };
  async function hashItems(items, version){
    if (version == undefined)
      version = 1;
    let Links = [];
    for (let i = 0; i < items.length; i++) {
      let item = items[i];
      Links.push({
        Name: item.name,
        Hash: parse(item.cid),
        Tsize: item.size
      })
    };
    Links.sort(linkComparator);
    try {
      const dirUnixFS = new UnixFS({
        type: 'directory',
        mtime: undefined,
        mode: 493
      });
      const node = {
        Data: dirUnixFS.marshal(),
        Links
      };
      const bytes = d_encode(node);
      const hash = await s_sha256.digest(bytes);
      // const cid = CID.create(version, RAW_CODE, hash);
      const cid = CID.create(version, CODE_DAG_PB, hash).toString();
      return {
        size: bytes.length + Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0),
        code: CODE_DAG_PB,
        name: '',
        type: 'dir',
        links: items,
        cid: cid,
        bytes: bytes
      }
    } catch (e) {
      throw e;
    }
  };
  function parse(cid, bytes) {
    let result = CID.parse(cid);
    if (bytes){
      let decoded = d_decode(bytes);
      result.links = decoded.Links;
      if (result.code == CODE_DAG_PB)
          result.size = bytes.length + decoded.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
      if (decoded.Data){
        decoded.Data = UnixFS.unmarshal(decoded.Data)
        result.type = decoded.Data.type;
        // if (result.type == 'directory')
        // else if(result.type == 'file' && result.code == CODE_DAG_PB){
        //   result.size = result.size || (decoded.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0))
        // };
      };
    };
    return result;
  };
  async function hashContent(content, version) {
    // let buffer = [];
    let items = [];
    let contentLength = 0;
    if (typeof content === 'string') {
      content = new TextEncoder("utf-8").encode(content)
      // // new TextEncoder("utf-8").encode(value);
      // let chunkSize = 1048576;
      // if (version == 0){
      //   chunkSize = 262144;
      //   let offset = 0  
      //   const size = Math.ceil(content.length/chunkSize);
      //   for (let i = 0; i < size; i++) {
      //     let data = textEncoder.encode(content.substr(offset, chunkSize));
      //     contentLength += data.length;
      //     items.push(await hashChunk(data, version));
      //     offset += chunkSize;
      //   }
      // }
      // else{
      //   content = new TextEncoder("utf-8").encode(content);

      // }
    }
    if (content instanceof Uint8Array){
      let chunkSize = 1048576;
      if (version == 0)
        chunkSize = 262144;

      let offset = 0  
      const size = Math.ceil(content.length/chunkSize)
      for (let i = 0; i < size; i++) {
        let data = content.slice(offset, offset + chunkSize);
        contentLength += data.length;
        items.push(await hashChunk(data, version));
        offset += chunkSize;
      }
    }
    else{
      for await (const data of content) {
        // buffer.push(data);
        contentLength += data.length;
        items.push(await hashChunk(data, version));
      };
    };
    if (items.length == 1){
      return {
        size: contentLength,
        type: 'file',
        code: CODE_RAW,
        cid: items[0].cid.toString()
      };
    }
    else{
      let result= await hashChunks(items, version);
      let links = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        links.push({
          cid: item.cid.toString(),
          size: item.size
        })
      };
      return {
        cid: result.cid,
        size: result.size,
        code: CODE_DAG_PB,
        type: 'file',
        bytes: result.bytes,
        links: links
      };
    }
  };
  function base64Encode(binaryInput){
    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '';
    if (binaryInput.length % 3 === 1) {
      binaryInput += '00';
    } else if (binaryInput.length % 3 === 2) {
      binaryInput += '0';
    };
    for (let i = 0; i < binaryInput.length; i += 6) {
      const chunk = binaryInput.slice(i, i + 6);
      const decimalValue = parseInt(chunk, 2);
      result += base64Chars.charAt(decimalValue);
    };
    const padding = calculatePadding(result);
    result += '='.repeat(padding);
    return result;
  };
  function calculatePadding(inputNumber) {
    const inputLength = inputNumber.toString().length;
    const nextMultipleOf4 = Math.ceil(inputLength / 4) * 4;
    const difference = nextMultipleOf4 - inputLength;
    return difference;
  };
  function hexToBinary(hexString){
    return hexString
      .split('')
      .map(hex => parseInt(hex, 16).toString(2).padStart(4, '0'))
      .join('');
  };
  function cidToHash(cid) {
    const parsedCid = parse(cid);
    const hashBuffer = Buffer.from(parsedCid.multihash.bytes);
    const hashHex = Array.from(hashBuffer.slice(2)).map(byte => byte.toString(16).toUpperCase().padStart(2, '0')).join('');
    const binaryInput = hexToBinary(hashHex);
    return base64Encode(binaryInput);
  };
  // AMD
  if (typeof define == 'function' && define.amd)
    define('@ijstech/ipfs-utils', function () { return {cidToHash, parse, hashChunk, hashChunks, hashItems, hashContent }; })
  // Node.js
  else if (typeof module != 'undefined' && module.exports)
    module.exports = {cidToHash, parse, hashChunk, hashChunks, hashItems, hashContent }
  // Browser
  else {
    if (!globalObject)
      globalObject = typeof self != 'undefined' && self ? self : window;
    globalObject.IPFSUtils = {cidToHash, parse, hashChunk, hashChunks, hashItems, hashContent };
  };
})(this);/*! @license DOMPurify 3.0.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.1/LICENSE */

(function (global, factory) {
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DOMPurify = factory());
})(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var entries = Object.entries,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }
  /* Add properties to a lookup table */

  function addToSet(set, array, transformCaseFunc) {
    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;

    while (l--) {
      var element = array[l];

      if (typeof element === 'string') {
        var lcElement = transformCaseFunc(element);

        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }
  /* Shallow clone an object */

  function clone(object) {
    var newObject = create(null);

    var _iterator = _createForOfIteratorHelper(entries(object)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            property = _step$value[0],
            value = _step$value[1];

        newObject[property] = value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return newObject;
  }
  /* This method automatically checks if the prop is function
   * or getter and behaves accordingly. */

  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);

      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.

  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.

  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
  var text = freeze(['#text']);

  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */


  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    } // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.


    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';

    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html) {
          return html;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };
    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */


    DOMPurify.version = '3.0.1';
    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */

    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }

    var originalDocument = window.document;
    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;
    var ElementPrototype = Element.prototype;
    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');

      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var hooks = {};
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */

    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined';
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
        ERB_EXPR$1 = ERB_EXPR,
        TMPLIT_EXPR$1 = TMPLIT_EXPR,
        DATA_ATTR$1 = DATA_ATTR,
        ARIA_ATTR$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    /* Allowed attribute names */

    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */

    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

    var FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

    var FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */

    var ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */

    var ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */

    var ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
     * Usually removed due to a mXSS issue in jQuery 3.0 */

    var ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */

    var SAFE_FOR_TEMPLATES = false;
    /* Decide if document with <html>... should be returned */

    var WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */

    var SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */

    var FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */

    var RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */

    var RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */

    var RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */

    var SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (7.3.3)
     *   - DOM Tree Accessors (3.1.5)
     *   - Form Element Parent-Child Relations (4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
     *   - HTMLCollection (4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */

    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */

    var KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */

    var IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */

    var USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */

    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    /* Tags that are safe for data: URIs */

    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    /* Attributes safe for values like "javascript:" */

    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */

    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */

    var ALLOWED_NAMESPACES = null;
    var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    /* Parsing of strict XHTML documents */

    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc;
    /* Keep a reference to config to pass to hooks */

    var CONFIG = null;
    /* Ideally, do not touch anything below this line */

    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity


    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */


      if (!cfg || _typeof(cfg) !== 'object') {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */


      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
      /* Set configuration parameters */

      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true

      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

      RETURN_DOM = cfg.RETURN_DOM || false; // Default false

      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

      FORCE_BODY = cfg.FORCE_BODY || false; // Default false

      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

      IN_PLACE = cfg.IN_PLACE || false; // Default false

      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */


      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];

        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */


      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */


      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      } // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.


      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.

    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */

    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */

    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.

      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        } // The only way to switch from MathML to SVG is via`
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.


        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        } // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.


        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        } // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points


        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        } // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.


        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        } // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace


        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      } // For XHTML and XML documents that support custom namespaces


      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      } // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
      // Return false just in case.


      return false;
    };
    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */


    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });

      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        node.remove();
      }
    };
    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */


    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */


    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc;
      var leadingWhitespace;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */

      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */


      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);

        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {// Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      /* Work on whole document or just its body */


      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */


    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };
    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */


    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
    };
    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */


    var _isNode = function _isNode(object) {
      return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };
    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */


    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */


    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeElements', currentNode, null);
      /* Check if element is clobbered or can clobber */


      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Now let's check the element's type and name */


      var tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */

      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });
      /* Detect mXSS attempts abusing namespace confusion */


      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Remove element if anything forbids its presence */


      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }
        /* Keep content except for bad-listed elements */


        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);

        return true;
      }
      /* Check whether element has a valid namespace */


      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Make sure that older browsers don't get noscript mXSS */


      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Sanitize element content to be template-safe */


      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
        content = stringReplace(content, ERB_EXPR$1, ' ');
        content = stringReplace(content, TMPLIT_EXPR$1, ' ');

        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity


    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */


      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */

      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };
    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */


    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */


    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;
      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */

      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;
        value = name === 'value' ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name);
        /* Execute a hook if present */

        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */

        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */


        _removeAttribute(name, currentNode);
        /* Did the hooks approve of the attribute? */


        if (!hookEvent.keepAttr) {
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */


        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);

          continue;
        }
        /* Sanitize attribute content to be template-safe */


        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
          value = stringReplace(value, ERB_EXPR$1, ' ');
          value = stringReplace(value, TMPLIT_EXPR$1, ' ');
        }
        /* Is `value` valid for this attribute? */


        var lcTag = transformCaseFunc(currentNode.nodeName);

        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */


        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Handle attributes that require Trusted Types */


        if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
          if (namespaceURI) ; else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case 'TrustedHTML':
                value = trustedTypesPolicy.createHTML(value);
                break;

              case 'TrustedScriptURL':
                value = trustedTypesPolicy.createScriptURL(value);
                break;
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */


        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeAttributes', currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */


    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode;

      var shadowIterator = _createIterator(fragment);
      /* Execute a hook if present */


      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);
        /* Sanitize tags and elements */


        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        /* Deep shadow DOM detected */


        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(shadowNode);
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };
    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity


    DOMPurify.sanitize = function (dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var returnNode;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */

      IS_EMPTY_INPUT = !dirty;

      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }
      /* Stringify, in case dirty is an object */


      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();

          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }
      /* Return dirty HTML if DOMPurify cannot run */


      if (!DOMPurify.isSupported) {
        return dirty;
      }
      /* Assign config vars */


      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */


      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */

      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);

          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);

        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        /* Initialize the document to work on */


        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */

        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */


      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */


      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */


      while (currentNode = nodeIterator.nextNode()) {
        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        /* Shadow DOM detected, sanitize it */


        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(currentNode);
      }
      /* If we sanitized `dirty` in-place, return it. */


      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */


      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */

      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }
      /* Sanitize final string template-safe */


      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */


    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);

      SET_CONFIG = true;
    };
    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */


    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */


    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */


    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     * @return {Function} removed(popped) hook
     */


    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */


    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */


    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map
define("@ijstech/types/jsonSchema.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
});
define("@ijstech/types/i18n.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.languages = void 0;
    ;
    exports.languages = {
        aa: {
            name: 'Afar',
            native: 'Afar',
        },
        ab: {
            name: 'Abkhazian',
            native: '',
        },
        af: {
            name: 'Afrikaans',
            native: 'Afrikaans',
        },
        ak: {
            name: 'Akan',
            native: 'Akana',
        },
        am: {
            name: 'Amharic',
            native: '',
        },
        an: {
            name: 'Aragonese',
            native: 'Aragons',
        },
        ar: {
            name: 'Arabic',
            native: '',
            rtl: 1,
        },
        as: {
            name: 'Assamese',
            native: '',
        },
        av: {
            name: 'Avar',
            native: '',
        },
        ay: {
            name: 'Aymara',
            native: 'Aymar',
        },
        az: {
            name: 'Azerbaijani',
            native: 'Azrbaycanca / ',
        },
        ba: {
            name: 'Bashkir',
            native: '',
        },
        be: {
            name: 'Belarusian',
            native: '',
        },
        bg: {
            name: 'Bulgarian',
            native: '',
        },
        bh: {
            name: 'Bihari',
            native: '',
        },
        bi: {
            name: 'Bislama',
            native: 'Bislama',
        },
        bm: {
            name: 'Bambara',
            native: 'Bamanankan',
        },
        bn: {
            name: 'Bengali',
            native: '',
        },
        bo: {
            name: 'Tibetan',
            native: ' / Bod skad',
        },
        br: {
            name: 'Breton',
            native: 'Brezhoneg',
        },
        bs: {
            name: 'Bosnian',
            native: 'Bosanski',
        },
        ca: {
            name: 'Catalan',
            native: 'Catal',
        },
        ce: {
            name: 'Chechen',
            native: '',
        },
        ch: {
            name: 'Chamorro',
            native: 'Chamoru',
        },
        co: {
            name: 'Corsican',
            native: 'Corsu',
        },
        cr: {
            name: 'Cree',
            native: 'Nehiyaw',
        },
        cs: {
            name: 'Czech',
            native: 'etina',
        },
        cu: {
            name: 'Old Church Slavonic / Old Bulgarian',
            native: ' / slovnsk',
        },
        cv: {
            name: 'Chuvash',
            native: '',
        },
        cy: {
            name: 'Welsh',
            native: 'Cymraeg',
        },
        da: {
            name: 'Danish',
            native: 'Dansk',
        },
        de: {
            name: 'German',
            native: 'Deutsch',
        },
        dv: {
            name: 'Divehi',
            native: '',
            rtl: 1,
        },
        dz: {
            name: 'Dzongkha',
            native: '',
        },
        ee: {
            name: 'Ewe',
            native: '',
        },
        el: {
            name: 'Greek',
            native: '',
        },
        en: {
            name: 'English',
            native: 'English',
        },
        eo: {
            name: 'Esperanto',
            native: 'Esperanto',
        },
        es: {
            name: 'Spanish',
            native: 'Espaol',
        },
        et: {
            name: 'Estonian',
            native: 'Eesti',
        },
        eu: {
            name: 'Basque',
            native: 'Euskara',
        },
        fa: {
            name: 'Persian',
            native: '',
            rtl: 1,
        },
        ff: {
            name: 'Peul',
            native: 'Fulfulde',
        },
        fi: {
            name: 'Finnish',
            native: 'Suomi',
        },
        fj: {
            name: 'Fijian',
            native: 'Na Vosa Vakaviti',
        },
        fo: {
            name: 'Faroese',
            native: 'Froyskt',
        },
        fr: {
            name: 'French',
            native: 'Franais',
        },
        fy: {
            name: 'West Frisian',
            native: 'Frysk',
        },
        ga: {
            name: 'Irish',
            native: 'Gaeilge',
        },
        gd: {
            name: 'Scottish Gaelic',
            native: 'Gidhlig',
        },
        gl: {
            name: 'Galician',
            native: 'Galego',
        },
        gn: {
            name: 'Guarani',
            native: "Avae'",
        },
        gu: {
            name: 'Gujarati',
            native: '',
        },
        gv: {
            name: 'Manx',
            native: 'Gaelg',
        },
        ha: {
            name: 'Hausa',
            native: '',
            rtl: 1,
        },
        he: {
            name: 'Hebrew',
            native: '',
            rtl: 1,
        },
        hi: {
            name: 'Hindi',
            native: '',
        },
        ho: {
            name: 'Hiri Motu',
            native: 'Hiri Motu',
        },
        hr: {
            name: 'Croatian',
            native: 'Hrvatski',
        },
        ht: {
            name: 'Haitian',
            native: 'Kryol ayisyen',
        },
        hu: {
            name: 'Hungarian',
            native: 'Magyar',
        },
        hy: {
            name: 'Armenian',
            native: '',
        },
        hz: {
            name: 'Herero',
            native: 'Otsiherero',
        },
        ia: {
            name: 'Interlingua',
            native: 'Interlingua',
        },
        id: {
            name: 'Indonesian',
            native: 'Bahasa Indonesia',
        },
        ie: {
            name: 'Interlingue',
            native: 'Interlingue',
        },
        ig: {
            name: 'Igbo',
            native: 'Igbo',
        },
        ii: {
            name: 'Sichuan Yi',
            native: ' / ',
        },
        ik: {
            name: 'Inupiak',
            native: 'Iupiak',
        },
        io: {
            name: 'Ido',
            native: 'Ido',
        },
        is: {
            name: 'Icelandic',
            native: 'slenska',
        },
        it: {
            name: 'Italian',
            native: 'Italiano',
        },
        iu: {
            name: 'Inuktitut',
            native: '',
        },
        ja: {
            name: 'Japanese',
            native: '',
        },
        jv: {
            name: 'Javanese',
            native: 'Basa Jawa',
        },
        ka: {
            name: 'Georgian',
            native: '',
        },
        kg: {
            name: 'Kongo',
            native: 'KiKongo',
        },
        ki: {
            name: 'Kikuyu',
            native: 'Gky',
        },
        kj: {
            name: 'Kuanyama',
            native: 'Kuanyama',
        },
        kk: {
            name: 'Kazakh',
            native: '',
        },
        kl: {
            name: 'Greenlandic',
            native: 'Kalaallisut',
        },
        km: {
            name: 'Cambodian',
            native: '',
        },
        kn: {
            name: 'Kannada',
            native: '',
        },
        ko: {
            name: 'Korean',
            native: '',
        },
        kr: {
            name: 'Kanuri',
            native: 'Kanuri',
        },
        ks: {
            name: 'Kashmiri',
            native: ' / ',
            rtl: 1,
        },
        ku: {
            name: 'Kurdish',
            native: 'Kurd / ',
            rtl: 1,
        },
        kv: {
            name: 'Komi',
            native: '',
        },
        kw: {
            name: 'Cornish',
            native: 'Kernewek',
        },
        ky: {
            name: 'Kyrgyz',
            native: '',
        },
        la: {
            name: 'Latin',
            native: 'Latina',
        },
        lb: {
            name: 'Luxembourgish',
            native: 'Ltzebuergesch',
        },
        lg: {
            name: 'Ganda',
            native: 'Luganda',
        },
        li: {
            name: 'Limburgian',
            native: 'Limburgs',
        },
        ln: {
            name: 'Lingala',
            native: 'Lingla',
        },
        lo: {
            name: 'Laotian',
            native: ' / Pha xa lao',
        },
        lt: {
            name: 'Lithuanian',
            native: 'Lietuvi',
        },
        lu: {
            name: 'Luba-Katanga',
            native: 'Tshiluba',
        },
        lv: {
            name: 'Latvian',
            native: 'Latvieu',
        },
        mg: {
            name: 'Malagasy',
            native: 'Malagasy',
        },
        mh: {
            name: 'Marshallese',
            native: 'Kajin Majel / Ebon',
        },
        mi: {
            name: 'Maori',
            native: 'Mori',
        },
        mk: {
            name: 'Macedonian',
            native: '',
        },
        ml: {
            name: 'Malayalam',
            native: '',
        },
        mn: {
            name: 'Mongolian',
            native: '',
        },
        mo: {
            name: 'Moldovan',
            native: 'Moldoveneasc',
        },
        mr: {
            name: 'Marathi',
            native: '',
        },
        ms: {
            name: 'Malay',
            native: 'Bahasa Melayu',
        },
        mt: {
            name: 'Maltese',
            native: 'bil-Malti',
        },
        my: {
            name: 'Burmese',
            native: '',
        },
        na: {
            name: 'Nauruan',
            native: 'Dorerin Naoero',
        },
        nb: {
            name: 'Norwegian Bokml',
            native: 'Norsk bokml',
        },
        nd: {
            name: 'North Ndebele',
            native: 'Sindebele',
        },
        ne: {
            name: 'Nepali',
            native: '',
        },
        ng: {
            name: 'Ndonga',
            native: 'Oshiwambo',
        },
        nl: {
            name: 'Dutch',
            native: 'Nederlands',
        },
        nn: {
            name: 'Norwegian Nynorsk',
            native: 'Norsk nynorsk',
        },
        no: {
            name: 'Norwegian',
            native: 'Norsk',
        },
        nr: {
            name: 'South Ndebele',
            native: 'isiNdebele',
        },
        nv: {
            name: 'Navajo',
            native: 'Din bizaad',
        },
        ny: {
            name: 'Chichewa',
            native: 'Chi-Chewa',
        },
        oc: {
            name: 'Occitan',
            native: 'Occitan',
        },
        oj: {
            name: 'Ojibwa',
            native: ' / Anishinaabemowin',
        },
        om: {
            name: 'Oromo',
            native: 'Oromoo',
        },
        or: {
            name: 'Oriya',
            native: '',
        },
        os: {
            name: 'Ossetian / Ossetic',
            native: '',
        },
        pa: {
            name: 'Panjabi / Punjabi',
            native: ' /  / ',
        },
        pi: {
            name: 'Pali',
            native: 'Pli / ',
        },
        pl: {
            name: 'Polish',
            native: 'Polski',
        },
        ps: {
            name: 'Pashto',
            native: '',
            rtl: 1,
        },
        pt: {
            name: 'Portuguese',
            native: 'Portugus',
        },
        qu: {
            name: 'Quechua',
            native: 'Runa Simi',
        },
        rm: {
            name: 'Raeto Romance',
            native: 'Rumantsch',
        },
        rn: {
            name: 'Kirundi',
            native: 'Kirundi',
        },
        ro: {
            name: 'Romanian',
            native: 'Romn',
        },
        ru: {
            name: 'Russian',
            native: '',
        },
        rw: {
            name: 'Rwandi',
            native: 'Kinyarwandi',
        },
        sa: {
            name: 'Sanskrit',
            native: '',
        },
        sc: {
            name: 'Sardinian',
            native: 'Sardu',
        },
        sd: {
            name: 'Sindhi',
            native: '',
        },
        se: {
            name: 'Northern Sami',
            native: 'Smegiella',
        },
        sg: {
            name: 'Sango',
            native: 'Sng',
        },
        sh: {
            name: 'Serbo-Croatian',
            native: 'Srpskohrvatski / ',
        },
        si: {
            name: 'Sinhalese',
            native: '',
        },
        sk: {
            name: 'Slovak',
            native: 'Slovenina',
        },
        sl: {
            name: 'Slovenian',
            native: 'Slovenina',
        },
        sm: {
            name: 'Samoan',
            native: 'Gagana Samoa',
        },
        sn: {
            name: 'Shona',
            native: 'chiShona',
        },
        so: {
            name: 'Somalia',
            native: 'Soomaaliga',
        },
        sq: {
            name: 'Albanian',
            native: 'Shqip',
        },
        sr: {
            name: 'Serbian',
            native: '',
        },
        ss: {
            name: 'Swati',
            native: 'SiSwati',
        },
        st: {
            name: 'Southern Sotho',
            native: 'Sesotho',
        },
        su: {
            name: 'Sundanese',
            native: 'Basa Sunda',
        },
        sv: {
            name: 'Swedish',
            native: 'Svenska',
        },
        sw: {
            name: 'Swahili',
            native: 'Kiswahili',
        },
        ta: {
            name: 'Tamil',
            native: '',
        },
        te: {
            name: 'Telugu',
            native: '',
        },
        tg: {
            name: 'Tajik',
            native: '',
        },
        th: {
            name: 'Thai',
            native: ' / Phasa Thai',
        },
        ti: {
            name: 'Tigrinya',
            native: '',
        },
        tk: {
            name: 'Turkmen',
            native: ' / ',
        },
        tl: {
            name: 'Tagalog / Filipino',
            native: 'Tagalog',
        },
        tn: {
            name: 'Tswana',
            native: 'Setswana',
        },
        to: {
            name: 'Tonga',
            native: 'Lea Faka-Tonga',
        },
        tr: {
            name: 'Turkish',
            native: 'Trke',
        },
        ts: {
            name: 'Tsonga',
            native: 'Xitsonga',
        },
        tt: {
            name: 'Tatar',
            native: 'Tatara',
        },
        tw: {
            name: 'Twi',
            native: 'Twi',
        },
        ty: {
            name: 'Tahitian',
            native: 'Reo M`ohi',
        },
        ug: {
            name: 'Uyghur',
            native: 'Uyurq / ',
        },
        uk: {
            name: 'Ukrainian',
            native: '',
        },
        ur: {
            name: 'Urdu',
            native: '',
            rtl: 1,
        },
        uz: {
            name: 'Uzbek',
            native: "O'zbekcha",
        },
        ve: {
            name: 'Venda',
            native: 'Tshivena',
        },
        vi: {
            name: 'Vietnamese',
            native: 'Ting Vit',
        },
        vo: {
            name: 'Volapk',
            native: 'Volapk',
        },
        wa: {
            name: 'Walloon',
            native: 'Walon',
        },
        wo: {
            name: 'Wolof',
            native: 'Wollof',
        },
        xh: {
            name: 'Xhosa',
            native: 'isiXhosa',
        },
        yi: {
            name: 'Yiddish',
            native: '',
            rtl: 1,
        },
        yo: {
            name: 'Yoruba',
            native: 'Yorb',
        },
        za: {
            name: 'Zhuang',
            native: 'Cuengh / T / ',
        },
        "zh-hans": {
            name: 'Chinese (Simplified)',
            native: '',
        },
        "zh-hant": {
            name: 'Chinese (Traditional)',
            native: '',
        },
        zu: {
            name: 'Zulu',
            native: 'isiZulu',
        },
    };
});
define("@ijstech/types/tooltip.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
    ;
});
define("@ijstech/types", ["require", "exports", "@ijstech/types/jsonSchema.ts", "@ijstech/types/i18n.ts"], function (require, exports, JSONSchema, i18n_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GroupType = exports.isModule = exports.languages = exports.JSONSchema = void 0;
    ///<amd-module name='@ijstech/types'/> 
    exports.JSONSchema = JSONSchema;
    Object.defineProperty(exports, "languages", { enumerable: true, get: function () { return i18n_1.languages; } });
    ;
    ;
    function isModule(value) {
        return value.isModule === true;
    }
    exports.isModule = isModule;
    ;
    var GroupType;
    (function (GroupType) {
        GroupType["BASIC"] = "Basic";
        GroupType["LAYOUT"] = "Layout";
        GroupType["FIELDS"] = "Fields";
    })(GroupType = exports.GroupType || (exports.GroupType = {}));
    ;
});
define("@ijstech/style/colors.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Colors = exports.yellow = exports.teal = exports.red = exports.purple = exports.pink = exports.orange = exports.lime = exports.lightGreen = exports.lightBlue = exports.indigo = exports.grey = exports.green = exports.deepPurple = exports.deepOrange = exports.cyan = exports.brown = exports.blueGrey = exports.blue = exports.amber = void 0;
    exports.amber = {
        50: '#fff8e1',
        100: '#ffecb3',
        200: '#ffe082',
        300: '#ffd54f',
        400: '#ffca28',
        500: '#ffc107',
        600: '#ffb300',
        700: '#ffa000',
        800: '#ff8f00',
        900: '#ff6f00',
        A100: '#ffe57f',
        A200: '#ffd740',
        A400: '#ffc400',
        A700: '#ffab00',
    };
    exports.blue = {
        50: '#e3f2fd',
        100: '#bbdefb',
        200: '#90caf9',
        300: '#64b5f6',
        400: '#42a5f5',
        500: '#2196f3',
        600: '#1e88e5',
        700: '#1976d2',
        800: '#1565c0',
        900: '#0d47a1',
        A100: '#82b1ff',
        A200: '#448aff',
        A400: '#2979ff',
        A700: '#2962ff',
    };
    exports.blueGrey = {
        50: '#eceff1',
        100: '#cfd8dc',
        200: '#b0bec5',
        300: '#90a4ae',
        400: '#78909c',
        500: '#607d8b',
        600: '#546e7a',
        700: '#455a64',
        800: '#37474f',
        900: '#263238',
        A100: '#cfd8dc',
        A200: '#b0bec5',
        A400: '#78909c',
        A700: '#455a64',
    };
    exports.brown = {
        50: '#efebe9',
        100: '#d7ccc8',
        200: '#bcaaa4',
        300: '#a1887f',
        400: '#8d6e63',
        500: '#795548',
        600: '#6d4c41',
        700: '#5d4037',
        800: '#4e342e',
        900: '#3e2723',
        A100: '#d7ccc8',
        A200: '#bcaaa4',
        A400: '#8d6e63',
        A700: '#5d4037',
    };
    exports.cyan = {
        50: '#e0f7fa',
        100: '#b2ebf2',
        200: '#80deea',
        300: '#4dd0e1',
        400: '#26c6da',
        500: '#00bcd4',
        600: '#00acc1',
        700: '#0097a7',
        800: '#00838f',
        900: '#006064',
        A100: '#84ffff',
        A200: '#18ffff',
        A400: '#00e5ff',
        A700: '#00b8d4',
    };
    exports.deepOrange = {
        50: '#fbe9e7',
        100: '#ffccbc',
        200: '#ffab91',
        300: '#ff8a65',
        400: '#ff7043',
        500: '#ff5722',
        600: '#f4511e',
        700: '#e64a19',
        800: '#d84315',
        900: '#bf360c',
        A100: '#ff9e80',
        A200: '#ff6e40',
        A400: '#ff3d00',
        A700: '#dd2c00',
    };
    exports.deepPurple = {
        50: '#ede7f6',
        100: '#d1c4e9',
        200: '#b39ddb',
        300: '#9575cd',
        400: '#7e57c2',
        500: '#673ab7',
        600: '#5e35b1',
        700: '#512da8',
        800: '#4527a0',
        900: '#311b92',
        A100: '#b388ff',
        A200: '#7c4dff',
        A400: '#651fff',
        A700: '#6200ea',
    };
    exports.green = {
        50: '#e8f5e9',
        100: '#c8e6c9',
        200: '#a5d6a7',
        300: '#81c784',
        400: '#66bb6a',
        500: '#4caf50',
        600: '#43a047',
        700: '#388e3c',
        800: '#2e7d32',
        900: '#1b5e20',
        A100: '#b9f6ca',
        A200: '#69f0ae',
        A400: '#00e676',
        A700: '#00c853',
    };
    exports.grey = {
        50: '#fafafa',
        100: '#f5f5f5',
        200: '#eeeeee',
        300: '#e0e0e0',
        400: '#bdbdbd',
        500: '#9e9e9e',
        600: '#757575',
        700: '#616161',
        800: '#424242',
        900: '#212121',
        A100: '#f5f5f5',
        A200: '#eeeeee',
        A400: '#bdbdbd',
        A700: '#616161',
    };
    exports.indigo = {
        50: '#e8eaf6',
        100: '#c5cae9',
        200: '#9fa8da',
        300: '#7986cb',
        400: '#5c6bc0',
        500: '#3f51b5',
        600: '#3949ab',
        700: '#303f9f',
        800: '#283593',
        900: '#1a237e',
        A100: '#8c9eff',
        A200: '#536dfe',
        A400: '#3d5afe',
        A700: '#304ffe',
    };
    exports.lightBlue = {
        50: '#e1f5fe',
        100: '#b3e5fc',
        200: '#81d4fa',
        300: '#4fc3f7',
        400: '#29b6f6',
        500: '#03a9f4',
        600: '#039be5',
        700: '#0288d1',
        800: '#0277bd',
        900: '#01579b',
        A100: '#80d8ff',
        A200: '#40c4ff',
        A400: '#00b0ff',
        A700: '#0091ea',
    };
    exports.lightGreen = {
        50: '#f1f8e9',
        100: '#dcedc8',
        200: '#c5e1a5',
        300: '#aed581',
        400: '#9ccc65',
        500: '#8bc34a',
        600: '#7cb342',
        700: '#689f38',
        800: '#558b2f',
        900: '#33691e',
        A100: '#ccff90',
        A200: '#b2ff59',
        A400: '#76ff03',
        A700: '#64dd17',
    };
    exports.lime = {
        50: '#f9fbe7',
        100: '#f0f4c3',
        200: '#e6ee9c',
        300: '#dce775',
        400: '#d4e157',
        500: '#cddc39',
        600: '#c0ca33',
        700: '#afb42b',
        800: '#9e9d24',
        900: '#827717',
        A100: '#f4ff81',
        A200: '#eeff41',
        A400: '#c6ff00',
        A700: '#aeea00',
    };
    exports.orange = {
        50: '#fff3e0',
        100: '#ffe0b2',
        200: '#ffcc80',
        300: '#ffb74d',
        400: '#ffa726',
        500: '#ff9800',
        600: '#fb8c00',
        700: '#f57c00',
        800: '#ef6c00',
        900: '#e65100',
        A100: '#ffd180',
        A200: '#ffab40',
        A400: '#ff9100',
        A700: '#ff6d00',
    };
    exports.pink = {
        50: '#fce4ec',
        100: '#f8bbd0',
        200: '#f48fb1',
        300: '#f06292',
        400: '#ec407a',
        500: '#e91e63',
        600: '#d81b60',
        700: '#c2185b',
        800: '#ad1457',
        900: '#880e4f',
        A100: '#ff80ab',
        A200: '#ff4081',
        A400: '#f50057',
        A700: '#c51162',
    };
    exports.purple = {
        50: '#f3e5f5',
        100: '#e1bee7',
        200: '#ce93d8',
        300: '#ba68c8',
        400: '#ab47bc',
        500: '#9c27b0',
        600: '#8e24aa',
        700: '#7b1fa2',
        800: '#6a1b9a',
        900: '#4a148c',
        A100: '#ea80fc',
        A200: '#e040fb',
        A400: '#d500f9',
        A700: '#aa00ff',
    };
    exports.red = {
        50: '#ffebee',
        100: '#ffcdd2',
        200: '#ef9a9a',
        300: '#e57373',
        400: '#ef5350',
        500: '#f44336',
        600: '#e53935',
        700: '#d32f2f',
        800: '#c62828',
        900: '#b71c1c',
        A100: '#ff8a80',
        A200: '#ff5252',
        A400: '#ff1744',
        A700: '#d50000',
    };
    exports.teal = {
        50: '#e0f2f1',
        100: '#b2dfdb',
        200: '#80cbc4',
        300: '#4db6ac',
        400: '#26a69a',
        500: '#009688',
        600: '#00897b',
        700: '#00796b',
        800: '#00695c',
        900: '#004d40',
        A100: '#a7ffeb',
        A200: '#64ffda',
        A400: '#1de9b6',
        A700: '#00bfa5',
    };
    exports.yellow = {
        50: '#fffde7',
        100: '#fff9c4',
        200: '#fff59d',
        300: '#fff176',
        400: '#ffee58',
        500: '#ffeb3b',
        600: '#fdd835',
        700: '#fbc02d',
        800: '#f9a825',
        900: '#f57f17',
        A100: '#ffff8d',
        A200: '#ffff00',
        A400: '#ffea00',
        A700: '#ffd600',
    };
    exports.Colors = {
        amber: exports.amber,
        blue: exports.blue,
        blueGrey: exports.blueGrey,
        brown: exports.brown,
        cyan: exports.cyan,
        deepOrange: exports.deepOrange,
        deepPurple: exports.deepPurple,
        green: exports.green,
        grey: exports.grey,
        indigo: exports.indigo,
        lightBlue: exports.lightBlue,
        lightGreen: exports.lightGreen,
        lime: exports.lime,
        orange: exports.orange,
        pink: exports.pink,
        purple: exports.purple,
        red: exports.red,
        teal: exports.teal,
        yellow: exports.yellow
    };
});
define("@ijstech/style/theme.ts", ["require", "exports", "@ijstech/style/colors.ts"], function (require, exports, colors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyTheme = exports.currentTheme = exports.ColorVars = exports.ThemeVars = exports.darkTheme = exports.defaultTheme = exports.Colors = void 0;
    Object.defineProperty(exports, "Colors", { enumerable: true, get: function () { return colors_1.Colors; } });
    exports.defaultTheme = {
        action: {
            active: 'rgba(0, 0, 0, 0.54)',
            activeBackground: 'rgba(0, 0, 0, 0.12)',
            activeOpacity: 0.12,
            disabled: 'rgba(0, 0, 0, 0.26)',
            disabledBackground: 'rgba(0, 0, 0, 0.12)',
            disabledOpacity: 0.38,
            focus: 'rgba(0, 0, 0, 0.26)',
            focusBackground: 'rgba(0, 0, 0, 0.12)',
            focusOpacity: 0.12,
            hover: 'rgba(0, 0, 0, 0.12)',
            hoverBackground: 'rgba(0, 0, 0, 0.04)',
            hoverOpacity: 0.04,
            selected: 'rgba(0, 0, 0, 0.14)',
            selectedBackground: 'rgba(0, 0, 0, 0.08)',
            selectedOpacity: 0.08,
        },
        background: {
            default: '#fafafa',
            paper: '#fff',
            main: '#ffffff',
            modal: '#ffffff',
            gradient: 'linear-gradient(90deg, #a8327f 0%, #d4626a 100%)',
        },
        breakpoints: {
            xs: 0,
            sm: 600,
            md: 900,
            lg: 1200,
            xl: 1536,
        },
        divider: 'rgba(0, 0, 0, 0.12)',
        colors: {
            error: {
                contrastText: '#FFFFFF',
                dark: '#D32F2F',
                light: '#e57373',
                main: '#f44336',
            },
            info: {
                contrastText: '#fff',
                dark: '#1976d2',
                light: '#64b5f6',
                main: '#2196f3',
            },
            primary: {
                contrastText: '#fff',
                dark: 'rgb(44, 56, 126)',
                light: 'rgb(101, 115, 195)',
                main: '#3f51b5',
            },
            secondary: {
                contrastText: '#fff',
                dark: 'rgb(171, 0, 60)',
                light: 'rgb(247, 51, 120)',
                main: '#f50057',
            },
            success: {
                contrastText: 'rgba(0, 0, 0, 0.87)',
                dark: '#388e3c',
                light: '#81c784',
                main: '#4caf50',
            },
            warning: {
                contrastText: 'rgba(0, 0, 0, 0.87)',
                dark: '#f57c00',
                light: '#ffb74d',
                main: '#ff9800',
            },
        },
        layout: {
            container: {
                width: '100%',
                maxWidth: '100%',
                textAlign: 'left',
                overflow: 'auto'
            }
        },
        shadows: {
            0: 'none',
            1: '0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12)',
            2: '0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12)',
            3: '0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12)',
            4: '0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12)',
        },
        text: {
            primary: 'rgba(0, 0, 0, 0.87)',
            secondary: 'rgba(0, 0, 0, 0.6)',
            third: '#f6c958',
            disabled: 'rgba(0, 0, 0, 0.38)',
            hint: 'rgba(0, 0, 0, 0.38)',
        },
        docs: {
            background: '#f6f8fa',
            text0: '#393939',
            text1: '#717171',
        },
        typography: {
            fontSize: '14px',
            fontFamily: `'roboto', 'Helvetica', 'Arial', 'Lucida Grande', 'sans-serif'`,
        },
        input: {
            background: '#fff',
            fontColor: '#000'
        },
        combobox: {
            background: '#fff',
            fontColor: '#000'
        }
    };
    exports.darkTheme = {
        action: {
            active: '#fff',
            activeBackground: 'rgba(0, 0, 0, 0.5)',
            activeOpacity: 0.12,
            disabled: 'rgba(255,255,255,0.3)',
            disabledBackground: 'rgba(255,255,255, 0.12)',
            disabledOpacity: 0.38,
            focus: 'rgba(255,255,255, 0.3)',
            focusBackground: 'rgba(255,255,255,0.12)',
            focusOpacity: 0.12,
            hover: 'rgba(255,255,255,0.3)',
            hoverBackground: 'rgba(255,255,255,0.08)',
            hoverOpacity: 0.08,
            selected: 'rgba(255,255,255, 0.6)',
            selectedOpacity: 0.16,
            selectedBackground: 'rgba(255,255,255, 0.16)'
        },
        background: {
            default: '#303030',
            paper: '#424242',
            main: '#181e3e',
            modal: '#192046',
            gradient: 'linear-gradient(90deg, #a8327f 0%, #d4626a 100%)',
        },
        breakpoints: {
            xs: 0,
            sm: 600,
            md: 900,
            lg: 1200,
            xl: 1536,
        },
        colors: {
            error: {
                contrastText: '#fff',
                dark: '#d32f2f',
                light: '#e57373',
                main: '#f44336',
            },
            info: {
                contrastText: 'rgba(0, 0, 0, 0.87)',
                dark: '#0288d1',
                light: '#4fc3f7',
                main: '#29b6f6',
            },
            primary: {
                contrastText: '#fff',
                dark: 'rgb(44, 56, 126)',
                light: 'rgb(101, 115, 195)',
                main: '#3f51b5',
            },
            secondary: {
                contrastText: '#fff',
                dark: 'rgb(171, 0, 60)',
                light: 'rgb(247, 51, 120)',
                main: '#f50057',
            },
            success: {
                contrastText: 'rgba(0, 0, 0, 0.87)',
                dark: '#388e3c',
                light: '#81c784',
                main: '#66bb6a',
            },
            warning: {
                contrastText: 'rgba(0, 0, 0, 0.87)',
                dark: '#f57c00',
                light: '#ffb74d',
                main: '#ffa726',
            },
        },
        layout: {
            container: {
                width: '100%',
                maxWidth: '100%',
                textAlign: 'left',
                overflow: 'auto'
            }
        },
        divider: 'rgba(255, 255, 255, 0.12)',
        shadows: {
            0: 'none',
            1: '0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12)',
            2: '0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12)',
            3: '0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12)',
            4: '0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12)',
        },
        text: {
            primary: '#fff',
            secondary: 'rgba(255, 255, 255, 0.7)',
            third: '#f6c958',
            disabled: 'rgba(255, 255, 255, 0.5)',
            hint: 'rgba(255, 255, 255, 0.5)',
        },
        docs: {
            background: '#010132',
            text0: '#fff',
            text1: '#fff',
        },
        typography: {
            fontSize: '14px',
            fontFamily: `'roboto', 'Helvetica', 'Arial', 'Lucida Grande', 'sans-serif'`,
        },
        input: {
            background: '#fff',
            fontColor: '#000'
        },
        combobox: {
            background: '#fff',
            fontColor: '#000'
        }
    };
    function isObject(item) {
        return item && typeof item === 'object' && !Array.isArray(item);
    }
    function mergeObject(target, source) {
        if (isObject(target) && isObject(source)) {
            for (const key in source) {
                if (isObject(source[key])) {
                    if (!target[key])
                        Object.assign(target, { [key]: {} });
                    mergeObject(target[key], source[key]);
                }
                else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
    }
    function createTheme(theme) {
        let result = JSON.parse(JSON.stringify(exports.defaultTheme));
        mergeObject(result, theme);
        return result;
    }
    function createThemeVars(theme, vars, prefix) {
        vars = vars || {};
        for (let v in theme) {
            if (typeof theme[v] == 'object') {
                vars[v] = {};
                createThemeVars(theme[v], vars[v], prefix ? prefix + v + '-' : v + '-');
            }
            else {
                let name = ((prefix || '') + v)
                    .split(/(?=[A-Z])/)
                    .join('_')
                    .toLowerCase();
                vars[v] = `var(--${name})`;
            }
        }
        return vars;
    }
    function createThemeCss(theme, vars, prefix) {
        vars = vars || {};
        for (let v in theme) {
            if (typeof theme[v] == 'object') {
                createThemeCss(theme[v], vars, prefix ? prefix + v + '-' : v + '-');
            }
            else {
                let name = ((prefix || '') + v)
                    .split(/(?=[A-Z])/)
                    .join('_')
                    .toLowerCase();
                vars[name] = theme[v];
            }
        }
        return vars;
    }
    exports.ThemeVars = createThemeVars(exports.defaultTheme);
    exports.ColorVars = createThemeVars(colors_1.Colors);
    let themeStyle;
    function applyTheme(theme) {
        let cssVars = createThemeCss(theme);
        let css = `:root{`;
        for (let p in cssVars)
            css += `--${p}: ${cssVars[p]};`;
        css += '}';
        if (!themeStyle) {
            themeStyle = document.createElement('style');
            document.head.appendChild(themeStyle);
        }
        themeStyle.textContent = css;
        exports.currentTheme = theme;
    }
    exports.applyTheme = applyTheme;
    applyTheme(exports.defaultTheme);
});
///<amd-module name='@ijstech/style/styles.ts'/> 
// https://raw.githubusercontent.com/blakeembrey/free-style/master/src/index.ts
define("@ijstech/style/styles.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = exports.FreeStyle = exports.Rule = exports.Style = exports.Selector = exports.Cache = void 0;
    /**
     * The unique id is used for unique hashes.
     */
    let uniqueId = 0;
    /**
     * Quick dictionary lookup for unit-less numbers.
     */
    const CSS_NUMBER = Object.create(null);
    /**
     * CSS properties that are valid unit-less numbers.
     *
     * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js
     */
    const CSS_NUMBER_KEYS = [
        "animation-iteration-count",
        "border-image-outset",
        "border-image-slice",
        "border-image-width",
        "box-flex",
        "box-flex-group",
        "box-ordinal-group",
        "column-count",
        "columns",
        "counter-increment",
        "counter-reset",
        "flex",
        "flex-grow",
        "flex-positive",
        "flex-shrink",
        "flex-negative",
        "flex-order",
        "font-weight",
        "grid-area",
        "grid-column",
        "grid-column-end",
        "grid-column-span",
        "grid-column-start",
        "grid-row",
        "grid-row-end",
        "grid-row-span",
        "grid-row-start",
        "line-clamp",
        "line-height",
        "opacity",
        "order",
        "orphans",
        "tab-size",
        "widows",
        "z-index",
        "zoom",
        // SVG properties.
        "fill-opacity",
        "flood-opacity",
        "stop-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
    ];
    // Add vendor prefixes to all unit-less properties.
    for (const property of CSS_NUMBER_KEYS) {
        for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
            CSS_NUMBER[prefix + property] = true;
        }
    }
    /**
     * Escape a CSS class name.
     */
    function escape(str) {
        return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
    }
    /**
     * Interpolate the `&` with style name.
     */
    function interpolate(selector, styleName) {
        return selector.replace(/&/g, styleName);
    }
    /**
     * Transform a JavaScript property into a CSS property.
     */
    function hyphenate(propertyName) {
        return propertyName
            .replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)
            .replace(/^ms-/, "-ms-"); // Internet Explorer vendor prefix.
    }
    /**
     * Generate a hash value from a string.
     */
    function stringHash(str) {
        let value = 5381;
        let len = str.length;
        while (len--)
            value = (value * 33) ^ str.charCodeAt(len);
        return (value >>> 0).toString(36);
    }
    /**
     * Transform a style string to a CSS string.
     */
    function styleToString(name, value) {
        const suffix = typeof value === "number" && value && !CSS_NUMBER[name] ? "px" : "";
        return `${name}:${value}${suffix}`;
    }
    /**
     * Sort an array of tuples by first value.
     */
    function sortTuples(value) {
        return value.sort((a, b) => (a[0] > b[0] ? 1 : -1));
    }
    /**
     * Stringify an array of property tuples.
     */
    function stringifyProperties(properties) {
        return properties
            .map(([name, value]) => {
            if (!Array.isArray(value))
                return styleToString(name, value);
            return value.map((x) => styleToString(name, x)).join(";");
        })
            .join(";");
    }
    /**
     * Interpolate CSS selectors.
     */
    function child(selector, parent) {
        if (!selector)
            return parent;
        if (!selector.includes("&"))
            return `${parent} ${selector}`;
        return interpolate(selector, parent);
    }
    /**
     * Recursive loop building styles with deferred selectors.
     */
    function stylize(rulesList, stylesList, key, styles, parentClassName) {
        const properties = [];
        const nestedStyles = [];
        // Sort keys before adding to styles.
        for (const key of Object.keys(styles)) {
            const value = styles[key];
            if (key.charCodeAt(0) !== 36 /* $ */ && value != null) {
                if (typeof value === "object" && !Array.isArray(value)) {
                    nestedStyles.push([key, value]);
                }
                else {
                    properties.push([hyphenate(key), value]);
                }
            }
        }
        const isUnique = !!styles.$unique;
        const parent = styles.$global ? "" : parentClassName;
        const nested = parent ? nestedStyles : sortTuples(nestedStyles);
        const style = stringifyProperties(sortTuples(properties));
        let pid = style;
        if (key.charCodeAt(0) === 64 /* @ */) {
            pid += `:${key}`;
            const childRules = [];
            const childStyles = [];
            // Nested styles support (e.g. `.foo > @media`).
            if (parent && style) {
                pid += `:${parent}`;
                childStyles.push({ selector: parent, style, isUnique });
            }
            for (const [name, value] of nested) {
                pid += `:${stylize(childRules, childStyles, name, value, parent)}`;
            }
            // Add new rule to parent.
            rulesList.push({
                selector: key,
                rules: childRules,
                styles: childStyles,
                style: parent ? "" : style,
            });
        }
        else {
            const selector = parent ? child(key, parent) : key;
            pid += `:${selector}`;
            if (style) {
                stylesList.push({ selector, style, isUnique });
            }
            for (const [name, value] of nested) {
                pid += `:${stylize(rulesList, stylesList, name, value, selector)}`;
            }
        }
        return pid;
    }
    /**
     * Transform `stylize` tree into style objects.
     */
    function compose(cache, rulesList, stylesList, id, name) {
        for (const { selector, style, isUnique } of stylesList) {
            const key = interpolate(selector, name);
            const item = new Style(style, `s:${isUnique ? (++uniqueId).toString(36) : id}:${style}`);
            item.add(new Selector(key, `k:${key}`));
            cache.add(item);
        }
        for (const { selector, style, rules, styles } of rulesList) {
            const key = interpolate(selector, name);
            const item = new Rule(key, style, `r:${id}:${key}:${style}`);
            compose(item, rules, styles, id, name);
            cache.add(item);
        }
    }
    /**
     * Cache to list to styles.
     */
    function join(arr) {
        let res = "";
        for (let i = 0; i < arr.length; i++)
            res += arr[i];
        return res;
    }
    /**
     * Implement a cache/event emitter.
     */
    class Cache {
        constructor(changes) {
            this.changes = changes;
            this.sheet = [];
            this.changeId = 0;
            this._keys = [];
            this._children = Object.create(null);
            this._counters = Object.create(null);
        }
        add(style) {
            const count = this._counters[style.id] || 0;
            const item = this._children[style.id] || style.clone();
            this._counters[style.id] = count + 1;
            if (count === 0) {
                this._children[item.id] = item;
                this._keys.push(item.id);
                this.sheet.push(item.getStyles());
                this.changeId++;
                if (this.changes)
                    this.changes.add(item, this._keys.length - 1);
            }
            else if (item instanceof Cache && style instanceof Cache) {
                const prevItemChangeId = item.changeId;
                item.merge(style);
                if (item.changeId !== prevItemChangeId) {
                    const index = this._keys.indexOf(style.id);
                    this.sheet.splice(index, 1, item.getStyles());
                    this.changeId++;
                    if (this.changes)
                        this.changes.change(item, index, index);
                }
            }
        }
        remove(style) {
            const count = this._counters[style.id];
            if (count) {
                this._counters[style.id] = count - 1;
                const item = this._children[style.id];
                const index = this._keys.indexOf(item.id);
                if (count === 1) {
                    delete this._counters[style.id];
                    delete this._children[style.id];
                    this._keys.splice(index, 1);
                    this.sheet.splice(index, 1);
                    this.changeId++;
                    if (this.changes)
                        this.changes.remove(item, index);
                }
                else if (item instanceof Cache && style instanceof Cache) {
                    const prevChangeId = item.changeId;
                    item.unmerge(style);
                    if (item.changeId !== prevChangeId) {
                        this.sheet.splice(index, 1, item.getStyles());
                        this.changeId++;
                        if (this.changes)
                            this.changes.change(item, index, index);
                    }
                }
            }
        }
        values() {
            return this._keys.map((key) => this._children[key]);
        }
        merge(cache) {
            for (const item of cache.values())
                this.add(item);
            return this;
        }
        unmerge(cache) {
            for (const item of cache.values())
                this.remove(item);
            return this;
        }
        clone() {
            return new Cache().merge(this);
        }
    }
    exports.Cache = Cache;
    /**
     * Selector is a dumb class made to represent nested CSS selectors.
     */
    class Selector {
        constructor(selector, id) {
            this.selector = selector;
            this.id = id;
        }
        getStyles() {
            return this.selector;
        }
        clone() {
            return this;
        }
    }
    exports.Selector = Selector;
    /**
     * The style container registers a style string with selectors.
     */
    class Style extends Cache {
        constructor(style, id) {
            super();
            this.style = style;
            this.id = id;
        }
        getStyles() {
            return `${this.sheet.join(",")}{${this.style}}`;
        }
        clone() {
            return new Style(this.style, this.id).merge(this);
        }
    }
    exports.Style = Style;
    /**
     * Implement rule logic for style output.
     */
    class Rule extends Cache {
        constructor(rule, style, id) {
            super();
            this.rule = rule;
            this.style = style;
            this.id = id;
        }
        getStyles() {
            return `${this.rule}{${this.style}${join(this.sheet)}}`;
        }
        clone() {
            return new Rule(this.rule, this.style, this.id).merge(this);
        }
    }
    exports.Rule = Rule;
    /**
     * Generate class name from styles.
     */
    function key(id, styles) {
        if (!styles.$displayName)
            return id;
        return `${styles.$displayName}_${id}`;
    }
    /**
     * The FreeStyle class implements the API for everything else.
     */
    class FreeStyle extends Cache {
        constructor(id, changes) {
            super(changes);
            this.id = id;
        }
        registerStyle(css) {
            const ruleList = [];
            const styleList = [];
            const pid = stylize(ruleList, styleList, "", css, ".&");
            const id = `f${stringHash(pid)}`;
            const name = key(id, css);
            compose(this, ruleList, styleList, id, 
            // Escape selector used in CSS when needed for display names.
            name
            //  process.env.NODE_ENV === "production" ? name : escape(name)
            );
            return name;
        }
        registerKeyframes(keyframes) {
            return this.registerHashRule("@keyframes", keyframes);
        }
        registerHashRule(prefix, styles) {
            return this.registerStyle({
                $global: true,
                $displayName: styles.$displayName,
                [`${prefix} &`]: styles,
            });
        }
        registerRule(rule, styles) {
            return this.registerStyle({ $global: true, [rule]: styles });
        }
        registerCss(styles) {
            return this.registerRule("", styles);
        }
        getStyles() {
            return join(this.sheet);
        }
        clone() {
            return new FreeStyle(this.id, this.changes).merge(this);
        }
    }
    exports.FreeStyle = FreeStyle;
    /**
     * Exports a simple function to create a new instance.
     */
    function create(changes) {
        return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);
    }
    exports.create = create;
});
///<amd-module name='@ijstech/style/csstype.ts'/> 
// export {};
define("@ijstech/style/csstype.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
///<amd-module name='@ijstech/style/types.ts'/> 
//https://raw.githubusercontent.com/typestyle/typestyle/master/src/types.ts
define("@ijstech/style/types.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
///<amd-module name='@ijstech/style/formatting.ts'/> 
// https://raw.githubusercontent.com/typestyle/typestyle/master/src/internal/formatting.ts
define("@ijstech/style/formatting.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToKeyframes = exports.convertToStyles = void 0;
    /**
     * We need to do the following to *our* objects before passing to freestyle:
     * - For any `$nest` directive move up to FreeStyle style nesting
     * - For any `$unique` directive map to FreeStyle Unique
     * - For any `$debugName` directive return the debug name
     */
    function convertToStyles(object) {
        /** The final result we will return */
        const styles = {};
        for (const key in object) {
            /** Grab the value upfront */
            const val = object[key];
            /** TypeStyle configuration options */
            if (key === '$nest') {
                const nested = val;
                for (let selector in nested) {
                    const subproperties = nested[selector];
                    styles[selector] = convertToStyles(subproperties);
                }
            }
            else if (key === '$debugName') {
                styles.$displayName = val;
            }
            else {
                styles[key] = val;
            }
        }
        return styles;
    }
    exports.convertToStyles = convertToStyles;
    // todo: better name here
    function convertToKeyframes(frames) {
        const result = {};
        for (const offset in frames) {
            if (offset !== '$debugName') {
                result[offset] = frames[offset];
            }
        }
        if (frames.$debugName) {
            result.$displayName = frames.$debugName;
        }
        return result;
    }
    exports.convertToKeyframes = convertToKeyframes;
});
///<amd-module name='@ijstech/style/utilities.ts'/> 
//https://raw.githubusercontent.com/typestyle/typestyle/master/src/internal/utilities.ts
define("@ijstech/style/utilities.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.media = exports.extend = exports.classes = exports.raf = void 0;
    /** Raf for node + browser */
    exports.raf = typeof requestAnimationFrame === 'undefined'
        /**
         * Make sure setTimeout is always invoked with
         * `this` set to `window` or `global` automatically
         **/
        ? (cb) => setTimeout(cb)
        /**
         * Make sure window.requestAnimationFrame is always invoked with `this` window
         * We might have raf without window in case of `raf/polyfill` (recommended by React)
         **/
        : typeof window === 'undefined'
            ? requestAnimationFrame
            : requestAnimationFrame.bind(window);
    /**
     * Utility to join classes conditionally
     */
    function classes(...classes) {
        return classes
            .map(c => c && typeof c === 'object' ? Object.keys(c).map(key => !!c[key] && key) : [c])
            .reduce((flattened, c) => flattened.concat(c), [])
            .filter(c => !!c)
            .join(' ');
    }
    exports.classes = classes;
    /**
     * Merges various styles into a single style object.
     * Note: if two objects have the same property the last one wins
     */
    function extend(...objects) {
        /** The final result we will return */
        const result = {};
        for (const object of objects) {
            if (object == null || object === false) {
                continue;
            }
            for (const key in object) {
                /** Falsy values except a explicit 0 is ignored */
                const val = object[key];
                if (!val && val !== 0) {
                    continue;
                }
                /** if nested media or pseudo selector */
                if (key === '$nest' && val) {
                    result[key] = result['$nest'] ? extend(result['$nest'], val) : val;
                }
                /** if freestyle sub key that needs merging. We come here due to our recursive calls */
                else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {
                    result[key] = result[key] ? extend(result[key], val) : val;
                }
                else {
                    result[key] = val;
                }
            }
        }
        return result;
    }
    exports.extend = extend;
    /**
     * Utility to help customize styles with media queries. e.g.
     * ```
     * style(
     *  media({maxWidth:500}, {color:'red'})
     * )
     * ```
     */
    const media = (mediaQuery, ...objects) => {
        const mediaQuerySections = [];
        if (mediaQuery.type)
            mediaQuerySections.push(mediaQuery.type);
        if (mediaQuery.orientation)
            mediaQuerySections.push(`(orientation: ${mediaQuery.orientation})`);
        if (mediaQuery.minWidth)
            mediaQuerySections.push(`(min-width: ${mediaLength(mediaQuery.minWidth)})`);
        if (mediaQuery.maxWidth)
            mediaQuerySections.push(`(max-width: ${mediaLength(mediaQuery.maxWidth)})`);
        if (mediaQuery.minHeight)
            mediaQuerySections.push(`(min-height: ${mediaLength(mediaQuery.minHeight)})`);
        if (mediaQuery.maxHeight)
            mediaQuerySections.push(`(max-height: ${mediaLength(mediaQuery.maxHeight)})`);
        const stringMediaQuery = `@media ${mediaQuerySections.join(' and ')}`;
        const object = {
            $nest: {
                [stringMediaQuery]: extend(...objects)
            }
        };
        return object;
    };
    exports.media = media;
    const mediaLength = (value) => typeof value === 'string' ? value : `${value}px`;
});
///<amd-module name='@ijstech/style/typestyle.ts'/> 
// https://raw.githubusercontent.com/typestyle/typestyle/master/src/internal/typestyle.ts
define("@ijstech/style/typestyle.ts", ["require", "exports", "@ijstech/style/styles.ts", "@ijstech/style/formatting.ts", "@ijstech/style/utilities.ts"], function (require, exports, FreeStyle, formatting_1, utilities_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeStyle = exports.TypeStyle = void 0;
    /**
     * Creates an instance of free style with our options
     */
    const createFreeStyle = () => FreeStyle.create();
    /**
     * Maintains a single stylesheet and keeps it in sync with requested styles
     */
    class TypeStyle {
        constructor({ autoGenerateTag }) {
            /**
             * Insert `raw` CSS as a string. This is useful for e.g.
             * - third party CSS that you are customizing with template strings
             * - generating raw CSS in JavaScript
             * - reset libraries like normalize.css that you can use without loaders
             */
            this.cssRaw = (mustBeValidCSS) => {
                if (!mustBeValidCSS) {
                    return;
                }
                this._raw += mustBeValidCSS || '';
                this._pendingRawChange = true;
                this._styleUpdated();
            };
            /**
             * Takes CSSProperties and registers it to a global selector (body, html, etc.)
             */
            this.cssRule = (selector, ...objects) => {
                const styles = (0, formatting_1.convertToStyles)((0, utilities_1.extend)(...objects));
                this._freeStyle.registerRule(selector, styles);
                this._styleUpdated();
                return;
            };
            /**
             * Renders styles to the singleton tag imediately
             * NOTE: You should only call it on initial render to prevent any non CSS flash.
             * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
             **/
            this.forceRenderStyles = () => {
                const target = this._getTag();
                if (!target) {
                    return;
                }
                target.textContent = this.getStyles();
            };
            /**
             * Utility function to register an @font-face
             */
            this.fontFace = (...fontFace) => {
                const freeStyle = this._freeStyle;
                for (const face of fontFace) {
                    freeStyle.registerRule('@font-face', face);
                }
                this._styleUpdated();
                return;
            };
            /**
             * Allows use to use the stylesheet in a node.js environment
             */
            this.getStyles = () => {
                return (this._raw || '') + this._freeStyle.getStyles();
            };
            /**
             * Takes keyframes and returns a generated animationName
             */
            this.keyframes = (frames) => {
                const keyframes = (0, formatting_1.convertToKeyframes)(frames);
                // TODO: replace $debugName with display name
                const animationName = this._freeStyle.registerKeyframes(keyframes);
                this._styleUpdated();
                return animationName;
            };
            /**
             * Helps with testing. Reinitializes FreeStyle + raw
             */
            this.reinit = () => {
                /** reinit freestyle */
                const freeStyle = createFreeStyle();
                this._freeStyle = freeStyle;
                this._lastFreeStyleChangeId = freeStyle.changeId;
                /** reinit raw */
                this._raw = '';
                this._pendingRawChange = false;
                /** Clear any styles that were flushed */
                const target = this._getTag();
                if (target) {
                    target.textContent = '';
                }
            };
            /** Sets the target tag where we write the css on style updates */
            this.setStylesTarget = (tag) => {
                /** Clear any data in any previous tag */
                if (this._tag) {
                    this._tag.textContent = '';
                }
                this._tag = tag;
                /** This special time buffer immediately */
                this.forceRenderStyles();
            };
            /**
             * Takes an object where property names are ideal class names and property values are CSSProperties, and
             * returns an object where property names are the same ideal class names and the property values are
             * the actual generated class names using the ideal class name as the $debugName
             */
            this.stylesheet = (classes) => {
                const classNames = Object.getOwnPropertyNames(classes);
                const result = {};
                for (let className of classNames) {
                    const classDef = classes[className];
                    if (classDef) {
                        classDef.$debugName = className;
                        result[className] = this.style(classDef);
                    }
                }
                return result;
            };
            const freeStyle = createFreeStyle();
            this._autoGenerateTag = autoGenerateTag;
            this._freeStyle = freeStyle;
            this._lastFreeStyleChangeId = freeStyle.changeId;
            this._pending = 0;
            this._pendingRawChange = false;
            this._raw = '';
            this._tag = undefined;
            // rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}
            this.style = this.style.bind(this);
        }
        /**
         * Only calls cb all sync operations settle
         */
        _afterAllSync(cb) {
            this._pending++;
            const pending = this._pending;
            (0, utilities_1.raf)(() => {
                if (pending !== this._pending) {
                    return;
                }
                cb();
            });
        }
        _getTag() {
            if (this._tag) {
                return this._tag;
            }
            if (this._autoGenerateTag) {
                const tag = typeof window === 'undefined'
                    ? { textContent: '' }
                    : document.createElement('style');
                if (typeof document !== 'undefined') {
                    document.head.appendChild(tag);
                }
                this._tag = tag;
                return tag;
            }
            return undefined;
        }
        /** Checks if the style tag needs updating and if so queues up the change */
        _styleUpdated() {
            const changeId = this._freeStyle.changeId;
            const lastChangeId = this._lastFreeStyleChangeId;
            if (!this._pendingRawChange && changeId === lastChangeId) {
                return;
            }
            this._lastFreeStyleChangeId = changeId;
            this._pendingRawChange = false;
            this._afterAllSync(() => this.forceRenderStyles());
        }
        style(...args) {
            const className = this._freeStyle.registerStyle((0, formatting_1.convertToStyles)(utilities_1.extend.apply(undefined, args)));
            this._styleUpdated();
            return className;
        }
    }
    exports.TypeStyle = TypeStyle;
    exports.typeStyle = new TypeStyle({ autoGenerateTag: true });
});
///<amd-module name='@ijstech/style'/> 
//https://typestyle.github.io/#/
define("@ijstech/style", ["require", "exports", "@ijstech/style/theme.ts", "@ijstech/style/colors.ts", "@ijstech/style/typestyle.ts"], function (require, exports, Theme, colors_2, typestyle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.style = exports.keyframes = exports.rotate = exports.fontFace = exports.cssRule = exports.cssRaw = exports.Colors = exports.Theme = void 0;
    exports.Theme = Theme;
    Object.defineProperty(exports, "Colors", { enumerable: true, get: function () { return colors_2.Colors; } });
    // export { TypeStyle };
    /**
     * All the CSS types in the 'types' namespace
     */
    // export * as types from './types';
    // export * as cssTypes from './csstype';
    // export { types };
    /**
     * Export certain utilities
     */
    // export { extend, classes, media } from './utilities';
    /** Sets the target tag where we write the css on style updates */
    // export const setStylesTarget = ts.setStylesTarget;
    /**
     * Insert `raw` CSS as a string. This is useful for e.g.
     * - third party CSS that you are customizing with template strings
     * - generating raw CSS in JavaScript
     * - reset libraries like normalize.css that you can use without loaders
     */
    exports.cssRaw = typestyle_1.typeStyle.cssRaw;
    /**
     * Takes CSSProperties and registers it to a global selector (body, html, etc.)
     */
    exports.cssRule = typestyle_1.typeStyle.cssRule;
    /**
     * Renders styles to the singleton tag imediately
     * NOTE: You should only call it on initial render to prevent any non CSS flash.
     * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
     **/
    // export const forceRenderStyles = ts.forceRenderStyles;
    /**
     * Utility function to register an @font-face
     */
    exports.fontFace = typestyle_1.typeStyle.fontFace;
    // export {rotate} from './snippets';
    function rotate(degree) {
        if (degree !== 0 && !degree)
            return '';
        let value = `rotate(${degree}deg)`;
        return (0, exports.style)({
            transform: value
        });
    }
    exports.rotate = rotate;
    /**
     * Allows use to use the stylesheet in a node.js environment
     */
    // export const getStyles = ts.getStyles;
    /**
     * Takes keyframes and returns a generated animationName
     */
    exports.keyframes = typestyle_1.typeStyle.keyframes;
    /**
     * Helps with testing. Reinitializes FreeStyle + raw
     */
    // export const reinit = ts.reinit;
    /**
     * Takes CSSProperties and return a generated className you can use on your component
     */
    exports.style = typestyle_1.typeStyle.style;
});
/**
 * Takes an object where property names are ideal class names and property values are CSSProperties, and
 * returns an object where property names are the same ideal class names and the property values are
 * the actual generated class names using the ideal class name as the $debugName
 */
// export const stylesheet = ts.stylesheet;
/**
 * Creates a new instance of TypeStyle separate from the default instance.
 *
 * - Use this for creating a different typestyle instance for a shadow dom component.
 * - Use this if you don't want an auto tag generated and you just want to collect the CSS.
 *
 * NOTE: styles aren't shared between different instances.
 */
// export function createTypeStyle(target?: { textContent: string | null }): TypeStyle {
//   const instance = new TypeStyle({ autoGenerateTag: false });
//   if (target) {
//     instance.setStylesTarget(target);
//   }
//   return instance;
// }
define("@ijstech/base/observable.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Observables = exports.initObservables = exports.observable = exports.ClearObservers = exports.Unobserve = exports.Observe = exports.isObservable = void 0;
    ///<amd-module name='@ijstech/base/observable.ts'/> 
    //Modified base on https://github.com/gullerya/object-observer/blob/main/src/object-observer.js
    const INSERT = 'insert', UPDATE = 'update', DELETE = 'delete', REVERSE = 'reverse', SHUFFLE = 'shuffle', oMetaKey = Symbol.for('object-observer-meta-key-0'), validObservableOptionKeys = { async: 1 }, processObserveOptions = (options) => {
        if (!options || typeof options !== 'object') {
            return null;
        }
        const result = {};
        const invalidOptions = [];
        for (const [optName, optVal] of Object.entries(options)) {
            if (optName === 'path') {
                if (typeof optVal !== 'string' || optVal === '') {
                    throw new Error('"path" option, if/when provided, MUST be a non-empty string');
                }
                result[optName] = optVal;
            }
            else if (optName === 'pathsOf') {
                if (options.path) {
                    throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');
                }
                if (typeof optVal !== 'string') {
                    throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');
                }
                result[optName] = options.pathsOf.split('.').filter(Boolean);
            }
            else if (optName === 'pathsFrom') {
                if (options.path || options.pathsOf) {
                    throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf" option/s');
                }
                if (typeof optVal !== 'string' || optVal === '') {
                    throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');
                }
                result[optName] = optVal;
            }
            else {
                invalidOptions.push(optName);
            }
        }
        if (invalidOptions.length) {
            throw new Error(`'${invalidOptions.join(', ')}' is/are not a valid observer option/s`);
        }
        return result;
    }, observe = function observe(observer, options) {
        if (typeof observer !== 'function') {
            throw new Error(`observer MUST be a function, got '${observer}'`);
        }
        const observers = this[oMetaKey].observers;
        if (!observers.some((o) => o[0] === observer)) {
            observers.push([observer, processObserveOptions(options)]);
        }
        else {
            console.warn('observer may be bound to an observable only once; will NOT rebind');
        }
    }, unobserve = function unobserve() {
        const observers = this[oMetaKey].observers;
        let ol = observers.length;
        if (ol) {
            let al = arguments.length;
            if (al) {
                while (al--) {
                    let i = ol;
                    while (i--) {
                        if (observers[i][0] === arguments[al]) {
                            observers.splice(i, 1);
                            ol--;
                        }
                    }
                }
            }
            else {
                observers.splice(0);
            }
        }
    }, clearObservers = function unobserve() {
        this[oMetaKey].observers = [];
    }, propertiesBluePrint = { __observe: { value: observe }, __unobserve: { value: unobserve }, __clearObservers: { value: clearObservers } }, prepareObject = (source, oMeta) => {
        const target = Object.defineProperties({}, propertiesBluePrint);
        target[oMetaKey] = oMeta;
        for (const key in source) {
            target[key] = getObservedOf(source[key], key, oMeta);
        }
        return target;
    }, prepareArray = (source, oMeta) => {
        let l = source.length;
        const target = Object.defineProperties(new Array(l), propertiesBluePrint);
        target[oMetaKey] = oMeta;
        for (let i = 0; i < l; i++) {
            target[i] = getObservedOf(source[i], i, oMeta);
        }
        return target;
    }, prepareTypedArray = (source, oMeta) => {
        Object.defineProperties(source, propertiesBluePrint);
        source[oMetaKey] = oMeta;
        return source;
    }, hasNestedProperty = (obj, path) => {
        return path.split('.').reduce((acc, key) => acc && key in acc ? acc[key] : undefined, obj) !== undefined;
    }, filterChanges = (options, changes) => {
        if (!options) {
            return changes;
        }
        let result = changes;
        if (options.path) {
            const oPath = options.path;
            let newResult = [];
            // result = changes.filter((change:any) => {
            // 	const isValidPath = (change.path || []).every((path: any) => typeof path === 'string');
            // 	if (!isValidPath) return false;
            // 	if (change.path.join('.').startsWith(oPath) && change.type == 'insert')
            // 		tempArr.push(change);
            // 	return change.path.join('.') === oPath;
            // });
            for (const change of changes) {
                const isValidPath = (change.path || []).every((path) => typeof path === 'string');
                if (!isValidPath)
                    continue;
                const changePath = change.path.join('.');
                if (changePath === oPath) {
                    newResult.push(change);
                }
                else if (oPath.startsWith(changePath)) {
                    let newPath = oPath.replace(changePath, '');
                    if (newPath.startsWith('.'))
                        newPath = newPath.slice(1);
                    if (newPath && typeof change.value === 'object' && hasNestedProperty(change.value, newPath)) {
                        const splittedPath = newPath.split('.');
                        let newVal = change.value?.[splittedPath[0]];
                        let oldVal = change.oldVal?.[splittedPath[0]];
                        for (let i = 1; i < splittedPath.length; i++) {
                            newVal = newVal?.[splittedPath[i]];
                            oldVal = oldVal?.[splittedPath[i]];
                        }
                        const newChange = new Change(change.type, [...change.path, newPath], newVal, oldVal, change.object);
                        newResult.push(newChange);
                    }
                }
                else if (changePath.startsWith(oPath) && change.type === 'insert') {
                    console.log('changePath', changePath, oPath);
                }
            }
            result = newResult;
            // if (result.length === 0) {
            // 	result = tempArr;
            // }
        }
        else if (options.pathsOf) {
            const oPathsOf = options.pathsOf;
            const oPathsOfStr = oPathsOf.join('.');
            result = changes.filter((change) => (change.path.length === oPathsOf.length + 1 ||
                (change.path.length === oPathsOf.length && (change.type === REVERSE || change.type === SHUFFLE))) &&
                change.path.join('.').startsWith(oPathsOfStr));
        }
        else if (options.pathsFrom) {
            const oPathsFrom = options.pathsFrom;
            result = changes.filter((change) => change.path.join('.').startsWith(oPathsFrom));
        }
        return result;
    }, callObserverSafe = (listener, changes) => {
        try {
            listener(changes);
        }
        catch (e) {
            console.error(`failed to notify listener ${listener} with ${changes}`, e);
        }
    }, callObserversFromMT = function callObserversFromMT() {
        const batches = this.batches;
        this.batches = null;
        for (const [listener, changes] of batches) {
            callObserverSafe(listener, changes);
        }
    }, callObservers = (oMeta, changes) => {
        let currentObservable = oMeta;
        let observers, target, options, relevantChanges, i;
        const l = changes.length;
        do {
            observers = currentObservable.observers;
            i = observers.length;
            while (i--) {
                [target, options] = observers[i];
                relevantChanges = filterChanges(options, changes);
                if (relevantChanges.length) {
                    if (currentObservable.options.async) {
                        //	this is the async dispatch handling
                        if (!currentObservable.batches) {
                            currentObservable.batches = [];
                            queueMicrotask(callObserversFromMT.bind(currentObservable));
                        }
                        let rb;
                        for (const b of currentObservable.batches) {
                            if (b[0] === target) {
                                rb = b;
                                break;
                            }
                        }
                        if (!rb) {
                            rb = [target, []];
                            currentObservable.batches.push(rb);
                        }
                        Array.prototype.push.apply(rb[1], relevantChanges);
                    }
                    else {
                        //	this is the naive straight forward synchronous dispatch
                        callObserverSafe(target, relevantChanges);
                    }
                }
            }
            //	cloning all the changes and notifying in context of parent
            if (currentObservable.parent) {
                const clonedChanges = new Array(l);
                for (let j = 0; j < l; j++) {
                    clonedChanges[j] = { ...changes[j] };
                    clonedChanges[j].path = [currentObservable.ownKey, ...clonedChanges[j].path];
                }
                changes = clonedChanges;
                currentObservable = currentObservable.parent;
            }
            else {
                currentObservable = null;
            }
        } while (currentObservable);
    }, getObservedOf = (item, key, parent) => {
        if (!item || typeof item !== 'object') {
            return item;
        }
        else if (Array.isArray(item)) {
            return new ArrayOMeta({ target: item, ownKey: key, parent: parent }).proxy;
        }
        else if (ArrayBuffer.isView(item)) {
            return new TypedArrayOMeta({ target: item, ownKey: key, parent: parent }).proxy;
        }
        else if (item instanceof Date) {
            return item;
        }
        else {
            return new ObjectOMeta({ target: item, ownKey: key, parent: parent }).proxy;
        }
    }, proxiedPop = function proxiedPop() {
        const oMeta = this[oMetaKey], target = oMeta.target, poppedIndex = target.length - 1;
        let popResult = target.pop();
        if (popResult && typeof popResult === 'object') {
            const tmpObserved = popResult[oMetaKey];
            if (tmpObserved) {
                popResult = tmpObserved.detach();
            }
        }
        const changes = [new Change(DELETE, [poppedIndex], undefined, popResult, this)];
        callObservers(oMeta, changes);
        return popResult;
    }, proxiedPush = function proxiedPush() {
        const oMeta = this[oMetaKey], target = oMeta.target, l = arguments.length, pushContent = new Array(l), initialLength = target.length;
        for (let i = 0; i < l; i++) {
            pushContent[i] = getObservedOf(arguments[i], initialLength + i, oMeta);
            // const item = arguments[i];
            // if (typeof item !== 'object' || item === null) {
            // 	pushContent[i] = getObservedOf(Observe({}), initialLength + i, oMeta);
            // } else {
            // 	pushContent[i] = getObservedOf(item, initialLength + i, oMeta);
            // }
        }
        const pushResult = Reflect.apply(target.push, target, pushContent);
        const changes = [];
        for (let i = initialLength, j = target.length; i < j; i++) {
            changes[i - initialLength] = new Change(INSERT, [i], target[i], undefined, this);
        }
        callObservers(oMeta, changes);
        return pushResult;
    }, proxiedShift = function proxiedShift() {
        const oMeta = this[oMetaKey], target = oMeta.target;
        let shiftResult, i, l, item, tmpObserved;
        shiftResult = target.shift();
        if (shiftResult && typeof shiftResult === 'object') {
            tmpObserved = shiftResult[oMetaKey];
            if (tmpObserved) {
                shiftResult = tmpObserved.detach();
            }
        }
        //	update indices of the remaining items
        for (i = 0, l = target.length; i < l; i++) {
            item = target[i];
            if (item && typeof item === 'object') {
                tmpObserved = item[oMetaKey];
                if (tmpObserved) {
                    tmpObserved.ownKey = i;
                }
            }
        }
        const changes = [new Change(DELETE, [0], undefined, shiftResult, this)];
        callObservers(oMeta, changes);
        return shiftResult;
    }, proxiedUnshift = function proxiedUnshift() {
        const oMeta = this[oMetaKey], target = oMeta.target, al = arguments.length, unshiftContent = new Array(al);
        for (let i = 0; i < al; i++) {
            unshiftContent[i] = getObservedOf(arguments[i], i, oMeta);
        }
        const unshiftResult = Reflect.apply(target.unshift, target, unshiftContent);
        for (let i = 0, l = target.length, item; i < l; i++) {
            item = target[i];
            if (item && typeof item === 'object') {
                const tmpObserved = item[oMetaKey];
                if (tmpObserved) {
                    tmpObserved.ownKey = i;
                }
            }
        }
        //	publish changes
        const l = unshiftContent.length;
        const changes = new Array(l);
        for (let i = 0; i < l; i++) {
            changes[i] = new Change(INSERT, [i], target[i], undefined, this);
        }
        callObservers(oMeta, changes);
        return unshiftResult;
    }, proxiedReverse = function proxiedReverse() {
        const oMeta = this[oMetaKey], target = oMeta.target;
        let i, l, item;
        target.reverse();
        for (i = 0, l = target.length; i < l; i++) {
            item = target[i];
            if (item && typeof item === 'object') {
                const tmpObserved = item[oMetaKey];
                if (tmpObserved) {
                    tmpObserved.ownKey = i;
                }
            }
        }
        const changes = [new Change(REVERSE, [], undefined, undefined, this)];
        callObservers(oMeta, changes);
        return this;
    }, proxiedSort = function proxiedSort(comparator) {
        const oMeta = this[oMetaKey], target = oMeta.target;
        let i, l, item;
        target.sort(comparator);
        for (i = 0, l = target.length; i < l; i++) {
            item = target[i];
            if (item && typeof item === 'object') {
                const tmpObserved = item[oMetaKey];
                if (tmpObserved) {
                    tmpObserved.ownKey = i;
                }
            }
        }
        const changes = [new Change(SHUFFLE, [], undefined, undefined, this)];
        callObservers(oMeta, changes);
        return this;
    }, proxiedFill = function proxiedFill(filVal, start, end) {
        const oMeta = this[oMetaKey], target = oMeta.target, changes = [], tarLen = target.length, prev = target.slice(0);
        start = start === undefined ? 0 : (start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen));
        end = end === undefined ? tarLen : (end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen));
        if (start < tarLen && end > start) {
            target.fill(filVal, start, end);
            let tmpObserved;
            for (let i = start, item, tmpTarget; i < end; i++) {
                item = target[i];
                target[i] = getObservedOf(item, i, oMeta);
                if (i in prev) {
                    tmpTarget = prev[i];
                    if (tmpTarget && typeof tmpTarget === 'object') {
                        tmpObserved = tmpTarget[oMetaKey];
                        if (tmpObserved) {
                            tmpTarget = tmpObserved.detach();
                        }
                    }
                    changes.push(new Change(UPDATE, [i], target[i], tmpTarget, this));
                }
                else {
                    changes.push(new Change(INSERT, [i], target[i], undefined, this));
                }
            }
            callObservers(oMeta, changes);
        }
        return this;
    }, proxiedCopyWithin = function proxiedCopyWithin(dest, start, end) {
        const oMeta = this[oMetaKey], target = oMeta.target, tarLen = target.length;
        dest = dest < 0 ? Math.max(tarLen + dest, 0) : dest;
        start = start === undefined ? 0 : (start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen));
        end = end === undefined ? tarLen : (end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen));
        const len = Math.min(end - start, tarLen - dest);
        if (dest < tarLen && dest !== start && len > 0) {
            const prev = target.slice(0), changes = [];
            target.copyWithin(dest, start, end);
            for (let i = dest, nItem, oItem, tmpObserved; i < dest + len; i++) {
                //	update newly placed observables, if any
                nItem = target[i];
                if (nItem && typeof nItem === 'object') {
                    nItem = getObservedOf(nItem, i, oMeta);
                    target[i] = nItem;
                }
                //	detach overridden observables, if any
                oItem = prev[i];
                if (oItem && typeof oItem === 'object') {
                    tmpObserved = oItem[oMetaKey];
                    if (tmpObserved) {
                        oItem = tmpObserved.detach();
                    }
                }
                if (typeof nItem !== 'object' && nItem === oItem) {
                    continue;
                }
                changes.push(new Change(UPDATE, [i], nItem, oItem, this));
            }
            callObservers(oMeta, changes);
        }
        return this;
    }, proxiedSplice = function proxiedSplice() {
        const oMeta = this[oMetaKey], target = oMeta.target, splLen = arguments.length, spliceContent = new Array(splLen), tarLen = target.length;
        //	observify the newcomers
        for (let i = 0; i < splLen; i++) {
            spliceContent[i] = getObservedOf(arguments[i], i, oMeta);
        }
        //	calculate pointers
        const startIndex = splLen === 0 ? 0 : (spliceContent[0] < 0 ? tarLen + spliceContent[0] : spliceContent[0]), removed = splLen < 2 ? tarLen - startIndex : spliceContent[1], inserted = Math.max(splLen - 2, 0), spliceResult = Reflect.apply(target.splice, target, spliceContent), newTarLen = target.length;
        //	reindex the paths
        let tmpObserved;
        for (let i = 0, item; i < newTarLen; i++) {
            item = target[i];
            if (item && typeof item === 'object') {
                tmpObserved = item[oMetaKey];
                if (tmpObserved) {
                    tmpObserved.ownKey = i;
                }
            }
        }
        //	detach removed objects
        let i, l, item;
        for (i = 0, l = spliceResult.length; i < l; i++) {
            item = spliceResult[i];
            if (item && typeof item === 'object') {
                tmpObserved = item[oMetaKey];
                if (tmpObserved) {
                    spliceResult[i] = tmpObserved.detach();
                }
            }
        }
        const changes = [];
        let index;
        for (index = 0; index < removed; index++) {
            if (index < inserted) {
                changes.push(new Change(UPDATE, [startIndex + index], target[startIndex + index], spliceResult[index], this));
            }
            else {
                changes.push(new Change(DELETE, [startIndex + index], undefined, spliceResult[index], this));
            }
        }
        for (; index < inserted; index++) {
            changes.push(new Change(INSERT, [startIndex + index], target[startIndex + index], undefined, this));
        }
        callObservers(oMeta, changes);
        return spliceResult;
    }, proxiedTypedArraySet = function proxiedTypedArraySet(source, offset) {
        const oMeta = this[oMetaKey], target = oMeta.target, souLen = source.length, prev = target.slice(0);
        offset = offset || 0;
        target.set(source, offset);
        const changes = new Array(souLen);
        for (let i = offset; i < (souLen + offset); i++) {
            changes[i - offset] = new Change(UPDATE, [i], target[i], prev[i], this);
        }
        callObservers(oMeta, changes);
    }, proxiedArrayMethods = {
        pop: proxiedPop,
        push: proxiedPush,
        shift: proxiedShift,
        unshift: proxiedUnshift,
        reverse: proxiedReverse,
        sort: proxiedSort,
        fill: proxiedFill,
        copyWithin: proxiedCopyWithin,
        splice: proxiedSplice
    }, proxiedTypedArrayMethods = {
        reverse: proxiedReverse,
        sort: proxiedSort,
        fill: proxiedFill,
        copyWithin: proxiedCopyWithin,
        set: proxiedTypedArraySet
    };
    class Change {
        constructor(type, path, value, oldValue, object) {
            this.type = type;
            this.path = path;
            this.value = value;
            this.oldValue = oldValue;
            this.object = object;
        }
    }
    class OMetaBase {
        constructor(properties, cloningFunction) {
            const { target, parent, ownKey } = properties;
            if (parent && ownKey !== undefined) {
                this.parent = parent;
                this.ownKey = ownKey;
            }
            else {
                this.parent = null;
                this.ownKey = null;
            }
            const targetClone = cloningFunction(target, this);
            this.observers = [];
            this.revocable = Proxy.revocable(targetClone, this);
            this.proxy = this.revocable.proxy;
            this.target = targetClone;
            this.options = this.processOptions(properties.options);
        }
        processOptions(options) {
            if (options) {
                if (typeof options !== 'object') {
                    throw new Error(`Observable options if/when provided, MAY only be an object, got '${options}'`);
                }
                const invalidOptions = Object.keys(options).filter(option => !(option in validObservableOptionKeys));
                if (invalidOptions.length) {
                    throw new Error(`'${invalidOptions.join(', ')}' is/are not a valid Observable option/s`);
                }
                return Object.assign({}, options);
            }
            else {
                return {};
            }
        }
        detach() {
            this.parent = null;
            return this.target;
        }
        set(target, key, value) {
            let oldValue = target[key];
            if (value !== oldValue) {
                const newValue = getObservedOf(value, key, this);
                target[key] = newValue;
                if (oldValue && typeof oldValue === 'object') {
                    const tmpObserved = oldValue[oMetaKey];
                    if (tmpObserved) {
                        oldValue = tmpObserved.detach();
                    }
                }
                const changes = oldValue === undefined
                    ? [new Change(INSERT, [key], newValue, undefined, this.proxy)]
                    : [new Change(UPDATE, [key], newValue, oldValue, this.proxy)];
                callObservers(this, changes);
            }
            return true;
        }
        deleteProperty(target, key) {
            let oldValue = target[key];
            delete target[key];
            if (oldValue && typeof oldValue === 'object') {
                const tmpObserved = oldValue[oMetaKey];
                if (tmpObserved) {
                    oldValue = tmpObserved.detach();
                }
            }
            const changes = [new Change(DELETE, [key], undefined, oldValue, this.proxy)];
            callObservers(this, changes);
            return true;
        }
    }
    class ObjectOMeta extends OMetaBase {
        constructor(properties) {
            super(properties, prepareObject);
        }
    }
    class ArrayOMeta extends OMetaBase {
        constructor(properties) {
            super(properties, prepareArray);
        }
        get(target, key) {
            return proxiedArrayMethods[key] || target[key];
        }
    }
    class TypedArrayOMeta extends OMetaBase {
        constructor(properties) {
            super(properties, prepareTypedArray);
        }
        get(target, key) {
            return proxiedTypedArrayMethods[key] || target[key];
        }
    }
    const Observable = Object.freeze({
        from: (target, options) => {
            if (!target || typeof target !== 'object') {
                throw new Error('observable MAY ONLY be created from a non-null object');
            }
            else if (target[oMetaKey]) {
                return target;
            }
            else if (Array.isArray(target)) {
                return new ArrayOMeta({ target: target, ownKey: null, parent: null, options: options }).proxy;
            }
            else if (ArrayBuffer.isView(target)) {
                return new TypedArrayOMeta({ target: target, ownKey: null, parent: null, options: options }).proxy;
            }
            else if (target instanceof Date) {
                throw new Error(`${target} found to be one of a non-observable types`);
            }
            else {
                return new ObjectOMeta({ target: target, ownKey: null, parent: null, options: options }).proxy;
            }
        },
        isObservable: (input) => {
            return !!(input && input[oMetaKey]);
        }
    });
    function isObservable(input) {
        return !!(input && input[oMetaKey]);
    }
    exports.isObservable = isObservable;
    function Observe(target, callback, options) {
        if (!target)
            return;
        if (!!(target && target[oMetaKey])) {
            if (callback)
                target.__observe(callback, options);
            return target;
        }
        ;
        let result;
        if (!target || typeof target !== 'object') {
            throw new Error('observable MAY ONLY be created from a non-null object');
        }
        else if (target[oMetaKey]) {
            result = target;
        }
        else if (Array.isArray(target)) {
            result = new ArrayOMeta({ target: target, ownKey: null, parent: null }).proxy;
        }
        else if (ArrayBuffer.isView(target)) {
            result = new TypedArrayOMeta({ target: target, ownKey: null, parent: null }).proxy;
        }
        else if (target instanceof Date) {
            throw new Error(`${target} found to be one of a non-observable types`);
        }
        else {
            result = new ObjectOMeta({ target: target, ownKey: null, parent: null }).proxy;
        }
        if (callback)
            result.__observe(callback, options);
        return result;
    }
    exports.Observe = Observe;
    function Unobserve(target, observer) {
        if (!target)
            return;
        if (!!(target && target[oMetaKey])) {
            target.__unobserve(observer);
        }
    }
    exports.Unobserve = Unobserve;
    function ClearObservers(target) {
        if (!target)
            return;
        if (!!(target && target[oMetaKey])) {
            target.__clearObservers();
        }
    }
    exports.ClearObservers = ClearObservers;
    function observable(propName, isArray) {
        return function (target, propertyName) {
            target['$observableProps'] = target['$observableProps'] || {};
            target['$observableProps'][propName || propertyName] = {
                propertyName: propertyName,
                isArray: isArray
            };
        };
        // return function(target: any, propertyName: string) {		
        // 	target['$observables'] = target['$observables'] || {};
        // 	let val = Observe({});		
        // 	let isObject = false;
        // 	target['$observables'][propName || propertyName] = val;
        // 	const getter = function() {			
        // 		if (isObject)
        // 			return val
        // 		else{
        // 			return val.value;
        // 		}
        // 	};
        // 	const setter = function(newVal: any) {
        // 		if (typeof(newVal) == 'object'){
        // 			isObject = true;
        // 			Object.assign(val, newVal)
        // 		}
        // 		else{
        // 			isObject = false;
        // 			val.value = newVal
        // 		}
        // 	};
        // 	Object.defineProperty(target, propertyName, {
        // 		get: getter,
        // 		set: setter
        // 	}); 
        // }
    }
    exports.observable = observable;
    function initObservables(target) {
        let observables = target['$observableProps'];
        target['$observables'] = target['$observables'] || {};
        for (let propName in observables) {
            let propertyName = observables[propName]?.propertyName;
            let isArray = observables[propName]?.isArray;
            let val = isArray ? Observe([]) : Observe({});
            let isObject = false;
            target['$observables'][propName] = val;
            const getter = function () {
                if (isObject)
                    return val;
                else {
                    return val.value;
                }
            };
            const setter = function (newVal) {
                if (typeof (newVal) == 'object') {
                    isObject = true;
                    if (Array.isArray(newVal) && isArray) {
                        if (val.length === 0 && newVal.length > 0) {
                            Object.assign(val, newVal);
                            return;
                        }
                        if (val.length > 0 && newVal.length === 0) {
                            val.length = 0;
                            return;
                        }
                        if (val.length > 0 && newVal.length > 0) {
                            val.splice(0, val.length, ...newVal);
                            return;
                        }
                    }
                    else {
                        const combinedDescriptors = {
                            ...Object.getOwnPropertyDescriptors(newVal),
                            ...Object.getOwnPropertyDescriptors(Object.getPrototypeOf(newVal)),
                        };
                        const constructor = combinedDescriptors?.constructor;
                        const isClassInstance = constructor?.value?.name !== 'Object';
                        if (isClassInstance) {
                            Object.defineProperties(val, combinedDescriptors);
                        }
                        else {
                            Object.assign(val, newVal);
                        }
                    }
                }
                else {
                    isObject = false;
                    val.value = newVal;
                }
            };
            Object.defineProperty(target, propertyName, {
                get: getter,
                set: setter
            });
        }
    }
    exports.initObservables = initObservables;
    function Observables(target, propertyName) {
        let result = target['$observables'] || {};
        if (propertyName) {
            return result[propertyName];
        }
        else
            return result;
    }
    exports.Observables = Observables;
});
// const
// 	callbackKey = Symbol('callback-key'),
// 	targetsKey = Symbol('targets-key');
// class ObjectObserver {
// 	constructor(callback:any) {
// 		(<any>this)[callbackKey] = callback;
// 		(<any>this)[targetsKey] = new Set();
// 		Object.freeze(this);
// 	}
// 	observe(target:any, config:any) {
// 		const r = Observable.from(target);
// 		r.__observe((<any>this)[callbackKey], config);
// 		(<any>this)[targetsKey].add(r);
// 		return r;
// 	}
// 	unobserve(target:any) {
// 		target.__unobserve((<any>this)[callbackKey]);
// 		(<any>this)[targetsKey].delete(target);
// 	}
// 	disconnect() {
// 		for (const t of (<any>this)[targetsKey]) {
// 			t.__unobserve((<any>this)[callbackKey]);
// 		}
// 		(<any>this)[targetsKey].clear();
// 	}
// }
define("@ijstech/base/types.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComponentProperty = exports.notifyEventParams = void 0;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    exports.notifyEventParams = [{ name: 'target', type: 'Control', isControl: true }, { name: 'event', type: 'Event' }];
    exports.ComponentProperty = {
        props: {
            "id": { type: 'string' }
        },
        events: {}
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
});
define("@ijstech/base/utils.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCustomElementProperties = exports.customElements = exports.getCustomElements = exports.IdUtils = void 0;
    class IdUtils {
        static generateUUID(length) {
            const uuid = 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
            if (length) {
                return uuid.substring(0, length);
            }
            return uuid;
        }
    }
    exports.IdUtils = IdUtils;
    ;
    let _customElementProperties = {};
    function getCustomElements() {
        return _customElementProperties;
    }
    exports.getCustomElements = getCustomElements;
    ;
    function customElements(tagName, properties) {
        return (constructor) => {
            try {
                if (properties)
                    properties.tagName = tagName;
                else
                    properties = {
                        props: {},
                        events: {},
                        tagName: tagName
                    };
                _customElementProperties[tagName] = properties;
                if (!window.customElements.get(tagName))
                    window.customElements.define(tagName, constructor);
            }
            catch (err) { }
        };
    }
    exports.customElements = customElements;
    ;
    function getCustomElementProperties(name) {
        return _customElementProperties[name?.toLowerCase()];
    }
    exports.getCustomElementProperties = getCustomElementProperties;
    ;
});
define("@ijstech/base/component.ts", ["require", "exports", "@ijstech/base/observable.ts", "@ijstech/base/utils.ts", "@ijstech/base/utils.ts", "@ijstech/base/types.ts"], function (require, exports, observable_1, utils_1, utils_2, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Component = void 0;
    class Component extends HTMLElement {
        constructor(parent, options, defaults) {
            super();
            this.deferReadyCallback = false;
            this._readyCallback = [];
            this.initializing = false;
            this.initialized = false;
            this.attrs = {};
            // this._parent = parent;
            this._uuid = utils_2.IdUtils.generateUUID();
            this.options = options || {};
            this.defaults = defaults || {};
            (0, observable_1.initObservables)(this);
        }
        connectedCallback() {
            if (this.connected)
                return;
            this.connected = true;
            if (!this.initializing && !this.initialized) {
                this.init();
            }
        }
        disconnectedCallback() {
            this.connected = false;
        }
        parseDesignPropValue(value) {
            if (value.startsWith('{') && value.endsWith('}')) {
                value = value.substring(1, value.length - 1);
                if (value.startsWith('{') && value.endsWith('}'))
                    return JSON.parse(value);
            }
            else if (value.startsWith('"') && value.endsWith('"')) {
                value = value.substring(1, value.length - 1);
            }
            else if (value.startsWith("'") && value.endsWith("'")) {
                value = value.substring(1, value.length - 1);
            }
            return value;
        }
        ;
        _getDesignPropValue(prop) {
            return this._designProps && this._designProps[prop];
        }
        ;
        _setDesignPropValue(prop, value, breakpointProp) {
            this._designProps = this._designProps || {};
            this._designProps[prop] = value;
            if (types_1.ComponentProperty.props[prop] && prop !== 'mediaQueries') {
                this[prop] = breakpointProp ?? value;
            }
            else {
                let propInfo = this._propInfo || (0, utils_1.getCustomElementProperties)(this.tagName);
                this._propInfo = propInfo;
                if (propInfo && propInfo.props[prop] && prop !== 'mediaQueries') {
                    if (!['link', 'icon', 'image', 'rightIcon', 'closeIcon'].includes(prop)) {
                        this[prop] = breakpointProp ?? value;
                    }
                }
                ;
            }
            ;
        }
        ;
        _setDesignProps(props, breakpoint = {}) {
            if (breakpoint) {
                for (let prop in breakpoint) {
                    if (!Object.hasOwnProperty.call(props, prop))
                        props[prop] = this._designProps?.[prop];
                }
            }
            for (let prop in props) {
                const hasQuery = Object.hasOwnProperty.call(breakpoint, prop);
                this._setDesignPropValue(prop, props[prop], hasQuery ? breakpoint[prop] : undefined);
            }
        }
        ;
        _getDesignProps() {
            return this._designProps;
        }
        ;
        createElement(tagName, parentElm) {
            let result = document.createElement(tagName);
            if (parentElm)
                parentElm.appendChild(result);
            // else
            //     this.appendChild(result);
            return result;
        }
        ;
        getAttributeValue(target, paths, idx) {
            idx = idx || 0;
            let path = paths[idx];
            let value = target[path];
            idx++;
            if (paths.length > idx)
                try {
                    return this.getAttributeValue(value, paths, idx);
                }
                catch (error) {
                    return value;
                }
            else
                return value;
        }
        ;
        getAttribute(name, removeAfter, defaultValue) {
            if (this.options[name] != null)
                return this.options[name];
            else if (this.attrs[name] != null && this.attrs[name] != undefined) {
                if (removeAfter)
                    this.removeAttribute(name);
                if (this.attrs[name].__target)
                    return this.getAttributeValue(this.attrs[name].__target, this.attrs[name].__path);
                else
                    return this.attrs[name];
            }
            else {
                let value = super.getAttribute(name);
                if (value && value.__target)
                    return;
                else if (value != null) {
                    if (value == 'false' || value == 'true')
                        value = JSON.parse(value);
                    this.options[name] = value;
                    if (removeAfter)
                        this.removeAttribute(name);
                    return value;
                }
                else if (this.defaults[name] != null)
                    return this.defaults[name];
            }
            ;
            return defaultValue;
        }
        ;
        getPositionAttribute(name, removeAfter, defaultValue) {
            let result = parseFloat(this.getAttribute(name, removeAfter, defaultValue));
            if (removeAfter && result)
                this.style[name] = result + 'px';
            return result;
        }
        ;
        getStyleAttribute(name, removeAfter, defaultValue) {
            let result = this.getAttribute(name, removeAfter, defaultValue);
            if (removeAfter && result)
                this.style[name] = result;
            return result;
        }
        ;
        get uuid() {
            return this._uuid;
        }
        get id() {
            return this.getAttribute('id');
        }
        ;
        set id(value) {
            this.options.id = value;
            this.setAttribute('id', value);
        }
        async ready() {
            if (this.initialized)
                return;
            return new Promise((resolve) => {
                if (this.initialized)
                    return resolve();
                this._readyCallback.push(resolve);
                if (!this.initializing && !this.initialized) {
                    this.init();
                }
            });
        }
        ;
        executeReadyCallback() {
            if (this.initialized)
                return;
            this.initialized = true;
            this.initializing = false;
            let callbacks = this._readyCallback;
            for (let i = 0; i < callbacks.length; i++) {
                callbacks[i]();
            }
            ;
            this._readyCallback = [];
        }
        ;
        init() {
            if (!this.initializing && !this.initialized) {
                this.initializing = true;
                if (this.options['class']) {
                    this.setAttribute('class', this.options['class']);
                }
                if (!this.deferReadyCallback) {
                    this.executeReadyCallback();
                }
                ;
            }
            ;
        }
        ;
    }
    exports.Component = Component;
});
define("@ijstech/base/style/base.css.ts", ["require", "exports", "@ijstech/style", "@ijstech/style"], function (require, exports, style_1, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOpacityStyleClass = exports.getControlMediaQueriesStyleClass = exports.getControlMediaQueriesStyle = exports.getMediaQueryRule = exports.getSpacingValue = exports.getBackgroundStyleClass = exports.getBackground = exports.getOverflowStyleClass = exports.getBorderStyleClass = exports.getBorderSideStyleClass = exports.getBorderSideObj = exports.containerStyle = exports.disabledStyle = void 0;
    const spinnerAnim = (0, style_1.keyframes)({
        "0%": {
            transform: 'rotate(0deg)'
        },
        "100%": {
            transform: 'rotate(360deg)'
        },
    });
    (0, style_1.cssRule)('html', {
        overscrollBehavior: 'none',
    });
    (0, style_1.cssRule)('body', {
        // userSelect: 'none',
        background: style_1.Theme.ThemeVars.background.default,
        backgroundAttachment: 'fixed !important',
        margin: 0,
        padding: 0,
        overflowX: 'hidden',
        overflowY: 'auto',
        overscrollBehavior: 'none',
        $nest: {
            '*, *:before, *:after': {
                boxSizing: 'border-box'
            },
            '.text-left': {
                textAlign: 'left'
            },
            '.text-right': {
                textAlign: 'right'
            },
            '.text-center': {
                textAlign: 'center'
            },
            '.bold': {
                fontWeight: 'bold'
            },
            '.inline-flex': {
                display: 'inline-flex'
            },
            '.flex': {
                display: 'flex'
            },
            '.inline-block': {
                display: 'inline-block'
            },
            '.mr-1': {
                marginRight: '1rem !important'
            },
            '.ml-1': {
                marginLeft: '1rem !important'
            },
            '.mb-1': {
                marginBottom: '1rem !important'
            },
            '.mt-1': {
                marginTop: '1rem !important'
            },
            '.mb-2': {
                marginBottom: '2rem'
            },
            '.pointer': {
                cursor: 'pointer'
            },
            '.text-underline': {
                textDecoration: 'underline'
            },
            '.text-none i-link > a': {
                textDecoration: 'none'
            },
            '.i-loading-overlay': {
                position: 'absolute',
                zIndex: 9,
                margin: 0,
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                transition: 'opacity .3s',
                background: style_1.Theme.ThemeVars.background.default,
                $nest: {
                    '&:after': {
                        content: '""',
                        position: 'absolute',
                        opacity: '.5',
                        width: '100%',
                        height: '100%'
                    },
                    '.i-loading-spinner_text': {
                        fontSize: '1rem',
                        color: style_1.Theme.ThemeVars.text.primary,
                        fontFamily: style_1.Theme.ThemeVars.typography.fontFamily,
                        marginTop: '.5rem'
                    },
                    '.i-loading-spinner_icon': {
                        display: 'block',
                        animation: `${spinnerAnim} 2s linear infinite`,
                        $nest: {
                            'i-image': {
                                display: 'block',
                                maxHeight: '100%',
                                maxWidth: '100%'
                            }
                        }
                    },
                    '.i-loading-spinner': {
                        position: 'absolute',
                        top: '50%',
                        left: '50%',
                        transform: 'translate(-50%, -50%)',
                        zIndex: 9999,
                        padding: '1rem'
                    }
                }
            }
        }
    });
    exports.disabledStyle = (0, style_1.style)({
        opacity: 0.4,
        cursor: 'default'
    });
    exports.containerStyle = (0, style_1.style)({
        $nest: {
            "span.resizer": {
                zIndex: 999
            },
            "span.resizer:hover": {
                backgroundColor: style_1.Theme.ThemeVars.colors.info.main,
                transitionDelay: '0.5s'
            },
            'span.resizer.highlight': {
                backgroundColor: style_1.Theme.ThemeVars.colors.info.main
            },
            'span.e-resize': {
                position: 'absolute',
                right: '0px',
                height: '100%',
                width: '4px',
                cursor: 'e-resize'
            },
            'span.n-resize': {
                position: 'absolute',
                top: '0px',
                height: '4px',
                width: '100%',
                cursor: 'n-resize'
            },
            'span.s-resize': {
                position: 'absolute',
                bottom: '0px',
                height: '4px',
                width: '100%',
                cursor: 's-resize'
            },
            'span.w-resize': {
                position: 'absolute',
                left: '0px',
                height: '100%',
                width: '4px',
                cursor: 'w-resize'
            },
            'span.resizing': {
                userSelect: 'none',
                pointerEvents: 'none'
            }
        }
    });
    const getBorderSideObj = (side, value) => {
        let styleObj = {};
        if (value.width !== undefined) {
            let borderWidthProp = `border-${side}-width`;
            styleObj[borderWidthProp] = (0, exports.getSpacingValue)(value.width);
        }
        if (value.style !== undefined) {
            let borderStyleProp = `border-${side}-style`;
            styleObj[borderStyleProp] = value.style;
        }
        if (value.color !== undefined) {
            let borderColorProp = `border-${side}-color`;
            styleObj[borderColorProp] = value.color || 'transparent';
        }
        return styleObj;
    };
    exports.getBorderSideObj = getBorderSideObj;
    const getBorderSideStyleClass = (side, value) => {
        const styleObj = (0, exports.getBorderSideObj)(side, value);
        return (0, style_1.style)(styleObj);
    };
    exports.getBorderSideStyleClass = getBorderSideStyleClass;
    const getBorderStyleClass = (value) => {
        if (!value)
            return '';
        const { width, style: bdStyle, color, top, right, bottom, left } = value;
        let styleObj = {};
        if (Object.hasOwnProperty.call(value, 'radius')) {
            styleObj['borderRadius'] = value.radius;
        }
        let borderWidth = width || '1px';
        let borderColor = color || 'transparent';
        let borderStyle = bdStyle || 'solid';
        styleObj.borderWidth = '';
        styleObj.borderColor = '';
        styleObj.borderStyle = '';
        if (top) {
            const { width, color, style } = top;
            styleObj.borderWidth = `${(0, exports.getSpacingValue)(width || borderWidth)}`;
            styleObj.borderColor = `${color || borderColor}`;
            styleObj.borderStyle = `${style || borderStyle}`;
        }
        if (right) {
            const { width, color, style } = right;
            styleObj.borderWidth += ` ${(0, exports.getSpacingValue)(width || borderWidth)}`;
            styleObj.borderColor += ` ${color || borderColor}`;
            styleObj.borderStyle += ` ${style || borderStyle}`;
        }
        if (bottom) {
            const { width, color, style } = bottom;
            styleObj.borderWidth += ` ${(0, exports.getSpacingValue)(width || borderWidth)}`;
            styleObj.borderColor += ` ${color || borderColor}`;
            styleObj.borderStyle += ` ${style || borderStyle}`;
        }
        if (left) {
            const { width, color, style } = left;
            styleObj.borderWidth += ` ${(0, exports.getSpacingValue)(width || borderWidth)}`;
            styleObj.borderColor += ` ${color || borderColor}`;
            styleObj.borderStyle += ` ${style || borderStyle}`;
        }
        if (!styleObj.borderWidth) {
            styleObj.borderWidth = borderWidth;
        }
        if (!styleObj.borderColor) {
            styleObj.borderColor = borderColor || 'transparent';
        }
        if (!styleObj.borderStyle) {
            styleObj.borderStyle = borderStyle || 'solid';
        }
        return (0, style_1.style)(styleObj);
    };
    exports.getBorderStyleClass = getBorderStyleClass;
    const getOverflowStyleClass = (value) => {
        let styleObj = {};
        if (value.x === value.y) {
            styleObj.overflow = value.x;
        }
        else {
            if (value.x) {
                styleObj.overflowX = value.x;
            }
            if (value.y) {
                styleObj.overflowY = value.y;
            }
        }
        return (0, style_1.style)(styleObj);
    };
    exports.getOverflowStyleClass = getOverflowStyleClass;
    const getBackground = (value) => {
        let styleObj = { background: '' };
        let bg = '';
        value.image && (bg += `url(${value.image})`);
        value.color && (bg += `${value.color}`);
        styleObj.background = bg;
        return styleObj;
    };
    exports.getBackground = getBackground;
    const getBackgroundStyleClass = (value) => {
        return (0, style_1.style)((0, exports.getBackground)(value));
    };
    exports.getBackgroundStyleClass = getBackgroundStyleClass;
    const getSpacingValue = (value) => {
        const isNumber = typeof value === 'number' || (value !== '' && !Number.isNaN(Number(value)));
        return isNumber ? `${value}px` : value;
    };
    exports.getSpacingValue = getSpacingValue;
    const getMediaQueryRule = (mediaQuery) => {
        let mediaQueryRule;
        const maxWidth = mediaQuery.maxWidth ? (0, exports.getSpacingValue)(mediaQuery.maxWidth) : 0;
        const minWidth = mediaQuery.minWidth ? (0, exports.getSpacingValue)(mediaQuery.minWidth) : 0;
        if (minWidth && maxWidth) {
            mediaQueryRule = `@media (min-width: ${minWidth}) and (max-width: ${maxWidth})`;
        }
        else if (minWidth) {
            mediaQueryRule = `@media (min-width: ${minWidth})`;
        }
        else if (maxWidth) {
            mediaQueryRule = `@media (max-width: ${maxWidth})`;
        }
        return mediaQueryRule;
    };
    exports.getMediaQueryRule = getMediaQueryRule;
    const getControlMediaQueriesStyle = (mediaQueries, props) => {
        let styleObj = {
            $nest: {}
        };
        if (mediaQueries) {
            for (let mediaQuery of mediaQueries) {
                let mediaQueryRule = (0, exports.getMediaQueryRule)(mediaQuery);
                if (mediaQueryRule) {
                    styleObj['$nest'][mediaQueryRule] = {};
                    let { display, visible, padding, margin, position, border, overflow, background, grid, zIndex, top, left, right, bottom, maxHeight, maxWidth, font, width, height, minWidth, minHeight, opacity, stack } = mediaQuery.properties || {};
                    if (display) {
                        styleObj['$nest'][mediaQueryRule]['display'] = `${display} !important`;
                    }
                    if (typeof visible === 'boolean') {
                        const currentDisplay = display ?? props?.display ?? 'flex';
                        styleObj['$nest'][mediaQueryRule]['display'] = visible ? `${currentDisplay} !important` : 'none !important';
                    }
                    if (padding) {
                        const { top = 0, right = 0, bottom = 0, left = 0 } = padding;
                        styleObj['$nest'][mediaQueryRule]['padding'] = `${(0, exports.getSpacingValue)(top)} ${(0, exports.getSpacingValue)(right)} ${(0, exports.getSpacingValue)(bottom)} ${(0, exports.getSpacingValue)(left)} !important`;
                    }
                    if (margin) {
                        const { top = 0, right = 0, bottom = 0, left = 0 } = margin;
                        styleObj['$nest'][mediaQueryRule]['margin'] = `${(0, exports.getSpacingValue)(top)} ${(0, exports.getSpacingValue)(right)} ${(0, exports.getSpacingValue)(bottom)} ${(0, exports.getSpacingValue)(left)} !important`;
                    }
                    if (border) {
                        const { radius, width, style, color, bottom, top, left, right } = border;
                        if (width !== undefined && width !== null)
                            styleObj['$nest'][mediaQueryRule]['border'] = `${width || ''} ${style || ''} ${color || ''}!important`;
                        if (radius)
                            styleObj['$nest'][mediaQueryRule]['borderRadius'] = `${(0, exports.getSpacingValue)(radius)} !important`;
                        if (bottom)
                            styleObj['$nest'][mediaQueryRule]['borderBottom'] = `${(0, exports.getSpacingValue)(bottom.width || '')} ${bottom.style || ''} ${bottom.color || ''}!important`;
                        if (top)
                            styleObj['$nest'][mediaQueryRule]['borderTop'] = `${(0, exports.getSpacingValue)(top.width || '') || ''} ${top.style || ''} ${top.color || ''}!important`;
                        if (left)
                            styleObj['$nest'][mediaQueryRule]['borderLeft'] = `${(0, exports.getSpacingValue)(left.width || '')} ${left.style || ''} ${left.color || ''}!important`;
                        if (right)
                            styleObj['$nest'][mediaQueryRule]['borderRight'] = `${(0, exports.getSpacingValue)(right.width || '')} ${right.style || ''} ${right.color || ''}!important`;
                    }
                    if (background) {
                        const value = (0, exports.getBackground)(background);
                        styleObj['$nest'][mediaQueryRule]['background'] = value.background + '!important';
                    }
                    if (grid) {
                        const { column, columnSpan, row, rowSpan, horizontalAlignment, verticalAlignment, area } = grid;
                        if (column && columnSpan) {
                            styleObj['$nest'][mediaQueryRule]['gridColumn'] = `${column + ' / span ' + columnSpan}!important`;
                        }
                        else if (column)
                            styleObj['$nest'][mediaQueryRule]['gridColumnStart'] = `${column.toString()}!important`;
                        else if (columnSpan)
                            styleObj['$nest'][mediaQueryRule]['gridColumn'] = `${'span ' + columnSpan}!important`;
                        if (row && rowSpan)
                            styleObj['$nest'][mediaQueryRule]['gridRow'] = `${row + ' / span ' + rowSpan}!important`;
                        else if (row)
                            styleObj['$nest'][mediaQueryRule]['gridRowStart'] = `${row.toString()}!important`;
                        else if (rowSpan)
                            styleObj['$nest'][mediaQueryRule]['gridRow'] = `${'span ' + rowSpan}!important`;
                        if (area)
                            styleObj['$nest'][mediaQueryRule]['gridArea'] = `${area}!important`;
                        if (horizontalAlignment)
                            styleObj['$nest'][mediaQueryRule]['justifyContent'] = `${horizontalAlignment}!important`;
                        if (verticalAlignment)
                            styleObj['$nest'][mediaQueryRule]['alignItems'] = `${verticalAlignment}!important`;
                    }
                    if (position) {
                        styleObj['$nest'][mediaQueryRule]['position'] = `${position} !important`;
                    }
                    if (zIndex !== undefined && zIndex !== null) {
                        styleObj['$nest'][mediaQueryRule]['zIndex'] = `${zIndex} !important`;
                    }
                    if (top !== undefined && top !== null) {
                        styleObj['$nest'][mediaQueryRule]['top'] = `${(0, exports.getSpacingValue)(top)} !important`;
                    }
                    if (left !== undefined && left !== null) {
                        styleObj['$nest'][mediaQueryRule]['left'] = `${(0, exports.getSpacingValue)(left)} !important`;
                    }
                    if (right !== undefined && right !== null) {
                        styleObj['$nest'][mediaQueryRule]['right'] = `${(0, exports.getSpacingValue)(right)} !important`;
                    }
                    if (bottom !== undefined && bottom !== null) {
                        styleObj['$nest'][mediaQueryRule]['bottom'] = `${(0, exports.getSpacingValue)(bottom)} !important`;
                    }
                    if (maxHeight !== undefined && maxHeight !== null) {
                        styleObj['$nest'][mediaQueryRule]['maxHeight'] = `${(0, exports.getSpacingValue)(maxHeight)} !important`;
                    }
                    if (maxWidth !== undefined && maxWidth !== null) {
                        styleObj['$nest'][mediaQueryRule]['maxWidth'] = `${(0, exports.getSpacingValue)(maxWidth)} !important`;
                    }
                    if (width !== undefined && width !== null) {
                        styleObj['$nest'][mediaQueryRule]['width'] = `${(0, exports.getSpacingValue)(width)} !important`;
                    }
                    if (height !== undefined && height !== null) {
                        styleObj['$nest'][mediaQueryRule]['height'] = `${(0, exports.getSpacingValue)(height)} !important`;
                    }
                    if (minWidth !== undefined && minWidth !== null) {
                        styleObj['$nest'][mediaQueryRule]['minWidth'] = `${(0, exports.getSpacingValue)(minWidth)} !important`;
                    }
                    if (minHeight !== undefined && minHeight !== null) {
                        styleObj['$nest'][mediaQueryRule]['minHeight'] = `${(0, exports.getSpacingValue)(minHeight)} !important`;
                    }
                    if (overflow) {
                        if (typeof overflow === 'string') {
                            styleObj['$nest'][mediaQueryRule]['overflow'] = `${overflow} !important`;
                        }
                        else {
                            const { x, y } = overflow || {};
                            if (x === y) {
                                styleObj['$nest'][mediaQueryRule]['overflow'] = `${x} !important`;
                            }
                            else {
                                if (x)
                                    styleObj['$nest'][mediaQueryRule]['overflowX'] = `${x} !important`;
                                if (y)
                                    styleObj['$nest'][mediaQueryRule]['overflowY'] = `${y} !important`;
                            }
                        }
                    }
                    if (font) {
                        const { size, weight, style, name, color, bold, transform } = font;
                        if (size)
                            styleObj['$nest'][mediaQueryRule]['fontSize'] = `${size}!important`;
                        if (typeof bold === 'boolean') {
                            styleObj['$nest'][mediaQueryRule]['fontWeight'] = bold === true ? `bold !important` : `normal !important`;
                        }
                        if (weight)
                            styleObj['$nest'][mediaQueryRule]['fontWeight'] = `${weight}!important`;
                        if (style)
                            styleObj['$nest'][mediaQueryRule]['fontStyle'] = `${style}!important`;
                        if (name)
                            styleObj['$nest'][mediaQueryRule]['fontFamily'] = `${name}!important`;
                        if (color)
                            styleObj['$nest'][mediaQueryRule]['color'] = `${color}!important`;
                        if (transform)
                            styleObj['$nest'][mediaQueryRule]['textTransform'] = `${transform}!important`;
                    }
                    if (opacity !== undefined && opacity !== null) {
                        styleObj['$nest'][mediaQueryRule]['opacity'] = `${opacity}!important`;
                    }
                    if (stack) {
                        const { basis, grow, shrink } = stack;
                        if (basis !== undefined && basis !== null)
                            styleObj['$nest'][mediaQueryRule]['flexBasis'] = `${basis}!important`;
                        if (grow !== undefined && grow !== null)
                            styleObj['$nest'][mediaQueryRule]['flexGrow'] = `${grow}!important`;
                        if (shrink !== undefined && shrink !== null)
                            styleObj['$nest'][mediaQueryRule]['flexShrink'] = `${shrink}!important`;
                    }
                }
            }
        }
        return styleObj;
    };
    exports.getControlMediaQueriesStyle = getControlMediaQueriesStyle;
    const getControlMediaQueriesStyleClass = (mediaQueries, props) => {
        let styleObj = (0, exports.getControlMediaQueriesStyle)(mediaQueries, props);
        return Styles.style(styleObj);
    };
    exports.getControlMediaQueriesStyleClass = getControlMediaQueriesStyleClass;
    const getOpacityStyleClass = (opacity) => {
        return Styles.style({
            opacity: opacity
        });
    };
    exports.getOpacityStyleClass = getOpacityStyleClass;
});
define("@ijstech/base/i18n.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.I18n = void 0;
    class I18n {
        constructor() {
            this.translations = {};
        }
        /**
         * Initializes the translations for the application.
         *
         * @param translations - An object containing translation key-value pairs.
         */
        init(translations) {
            for (let key in translations)
                this.translations[key] = translations[key];
        }
        ;
        /**
         * Retrieves a localized string based on the provided key and optional parameters.
         *
         * @param key - The key for the localized string.
         * @param params - An optional object containing key-value pairs to replace placeholders in the localized string.
         * @param skipApp - An optional boolean to skip checking the application's i18n for the key. Defaults to false.
         * @returns The localized string with placeholders replaced by the provided parameters, if any.
         */
        get(key, params, skipApp) {
            let application = window['application'];
            if (key == '$')
                return key;
            if (key.startsWith('$'))
                key = key.substring(1);
            if (!skipApp && application.i18n.has(key))
                return application.i18n.get(key, params, true);
            let locale = application.locale;
            let trans = this.translations[locale];
            let result;
            if (trans && trans[key]) {
                result = trans[key];
            }
            else if (locale == 'zh-hans' && this.translations['zh-hant'] && this.translations['zh-hant'][key]) {
                result = hantToHans(this.translations['zh-hant'][key]);
            }
            else if (locale == 'zh-hant' && this.translations['zh-hans'] && this.translations['zh-hans'][key]) {
                result = hansToHant(this.translations['zh-hans'][key]);
            }
            else
                result = key.replace(/_/g, ' ');
            if (params) {
                for (let p in params)
                    result = result.replace(new RegExp(`{{${p}}}`, 'g'), params[p]);
            }
            ;
            return result;
        }
        ;
        /**
         * Checks if a given translation key exists in the current locale's translations.
         *
         * @param key - The translation key to check.
         * @returns `true` if the translation key exists in the current locale's translations, otherwise `false`.
         */
        has(key) {
            let application = window['application'];
            if (key == '$')
                return false;
            if (key.startsWith('$'))
                key = key.substring(1);
            let locale = application.locale;
            let trans = this.translations[locale];
            return !!trans && !!trans[key];
        }
        ;
    }
    exports.I18n = I18n;
    ;
    const hans = { "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
    let hant;
    function hansToHant(value) {
        if (!hant) {
            hant = {};
            for (let key in hans) {
                hant[hans[key]] = key;
            }
        }
        ;
        let result = '';
        if (value) {
            for (var i = 0; i < value.length; i++) {
                result += hant[value[i]] || value[i];
            }
            ;
        }
        ;
        return result;
    }
    ;
    function hantToHans(value) {
        let result = '';
        if (value) {
            for (var i = 0; i < value.length; i++) {
                result += hans[value[i]] || value[i];
            }
            ;
        }
        ;
        return result;
    }
    ;
});
define("@ijstech/base/control.ts", ["require", "exports", "@ijstech/base/component.ts", "@ijstech/base/observable.ts", "@ijstech/base/types.ts", "@ijstech/base/utils.ts", "@ijstech/base/style/base.css.ts", "@ijstech/types"], function (require, exports, component_1, observable_2, types_2, utils_3, base_css_1, types_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Container = exports.ContainerResizer = exports.Control = exports.ControlProperties = exports.Background = exports.Overflow = exports.Border = exports.SpaceValue = void 0;
    function getParentControl(elm) {
        if (elm.parentElement instanceof Control) {
            return elm.parentElement;
        }
        else if (elm.parentElement)
            return getParentControl(elm.parentElement);
        return null;
    }
    ;
    function getParentModule(elm) {
        let parentElement = elm.parentElement;
        if (parentElement && (0, types_3.isModule)(parentElement)) {
            return parentElement;
        }
        else if (parentElement)
            return getParentModule(parentElement);
        return null;
    }
    ;
    function getParentControlById(elm, id) {
        if (elm.parentElement instanceof Control) {
            if (elm.parentElement[id] instanceof Control)
                return elm.parentElement[id];
            else
                return getParentControlById(elm.parentElement, id);
        }
        ;
        return null;
    }
    ;
    const toNumberValue = (value) => {
        return parseFloat(value.replace('px', ''));
    };
    let _refreshTimeout;
    function refresh() {
        if (!document.body.style.opacity)
            document.body.style.opacity = '0';
        clearTimeout(_refreshTimeout);
        _refreshTimeout = setTimeout(() => {
            try {
                clearTimeout(_refreshTimeout);
                _refreshTimeout = undefined;
                // let width = window.innerWidth - 1;//document.body.offsetWidth -1;
                // let height = window.innerHeight - 1;//document.body.offsetHeight -1;
                for (let i = 0; i < document.body.childNodes.length; i++) {
                    let node = document.body.childNodes[i];
                    if (node instanceof Container && node.nodeName !== 'I-MODAL') {
                        node.style.position = 'absolute';
                        // node.style.width = width + 'px';
                        // node.style.height = height + 'px';
                        node.style.width = '100%';
                        node.style.height = '100%';
                        // node.style.overflowX = 'hidden'; moved to body
                        // node.parent = null;
                        node.refresh();
                    }
                }
            }
            finally {
                document.body.style.opacity = '1';
            }
        }, 10);
    }
    ;
    window.addEventListener('resize', () => {
        refresh();
    });
    class SpaceValue {
        constructor(owner, value, prop) {
            this._owner = owner;
            this._value = value;
            this._prop = prop;
            this.update();
        }
        ;
        get left() {
            return this._value.left;
        }
        ;
        set left(value) {
            this._value.left = value;
            this.update();
        }
        ;
        get top() {
            return this._value.top;
        }
        ;
        set top(value) {
            this._value.top = value;
            this.update();
        }
        ;
        get right() {
            return this._value.right;
        }
        ;
        set right(value) {
            this._value.right = value;
            this.update();
        }
        ;
        get bottom() {
            return this._value.bottom;
        }
        ;
        set bottom(value) {
            this._value.bottom = value;
            this.update();
        }
        ;
        getSpacingValue(value) {
            if (value === '')
                return '0px';
            const isNumber = !Number.isNaN(Number(value));
            if (typeof value === 'number' || isNumber)
                return value + 'px';
            if (value === 'auto')
                return value;
            const unit = value.replace(/^-?\d+(\.\d+)?/g, '');
            const number = value.replace(unit, '');
            const isValidUnit = ['px', 'em', 'rem', '%'].includes(unit);
            return isValidUnit ? value : `${number}px`;
        }
        ;
        update(value) {
            if (value)
                this._value = value;
            const { top = 0, right = 0, bottom = 0, left = 0 } = this._value;
            switch (this._prop) {
                case 'margin':
                    // this._owner.margin = this._value;
                    this._owner.style.margin = `${this.getSpacingValue(top)} ${this.getSpacingValue(right)} ${this.getSpacingValue(bottom)} ${this.getSpacingValue(left)}`;
                    break;
                case 'padding':
                    // if (this._owner instanceof Container)
                    //     this._owner.padding = this._value;
                    this._owner.style.padding = `${this.getSpacingValue(top)} ${this.getSpacingValue(right)} ${this.getSpacingValue(bottom)} ${this.getSpacingValue(left)}`;
                    break;
            }
            ;
        }
        ;
    }
    exports.SpaceValue = SpaceValue;
    ;
    // const DefaultBorderCornerStyles: IBorderCornerStyles = {
    //     radius: undefined
    // }
    const DefaultBorderSideStyles = {
        width: undefined,
        style: undefined,
        color: undefined
    };
    const DefaultAnchor = { top: true, left: true, right: false, bottom: false };
    class Border {
        // private _topLeft: IBorderCornerStyles;
        // private _topRight: IBorderCornerStyles;
        // private _bottomLeft: IBorderCornerStyles;
        // private _bottomRight: IBorderCornerStyles;
        constructor(target, options) {
            this._styleClassMap = {};
            this._target = target;
            if (options)
                this.updateValue(options);
        }
        updateValue(options) {
            if (options && Object.keys(options).length) {
                this.updateAllSidesProps(options);
            }
            else {
                this.removeStyles();
            }
        }
        isNumber(value) {
            if (value === undefined || value === '')
                return false;
            return !Number.isNaN(Number(value));
        }
        updateAllSidesProps(options) {
            this._width = this.isNumber(options.width) ? options.width + 'px' : options.width || '';
            this._style = options.style || 'solid';
            this._color = options.color || '';
            this._radius = this.isNumber(options.radius) ? options.radius + 'px' : options.radius || '';
            this._top = options.top || {};
            this._right = options.right || {};
            this._bottom = options.bottom || {};
            this._left = options.left || {};
            this.setBorderStyles({
                width: this._width,
                style: this._style,
                color: this._color,
                radius: this._radius,
                top: this._top,
                right: this._right,
                bottom: this._bottom,
                left: this._left
            });
        }
        removeStyles() {
            this.removeStyleClass('left');
            this.removeStyleClass('bottom');
            this.removeStyleClass('right');
            this.removeStyleClass('top');
            this.removeStyleClass('style');
            this.removeStyleClass('color');
            this.removeStyleClass('radius');
            this.removeStyleClass('width');
        }
        get radius() {
            return this._radius;
        }
        set radius(value) {
            if (this.isNumber(value)) {
                this._radius = value + 'px';
                this._target.style.borderRadius = value + 'px';
            }
            else if (typeof value === 'string') {
                this._radius = value;
                this._target.style.borderRadius = value;
            }
        }
        get width() {
            return this._width;
        }
        set width(value) {
            if (this.isNumber(value)) {
                this._width = value + 'px';
            }
            else if (typeof value === 'string') {
                this._width = value;
            }
            this.setBorderProp('width', this._width);
        }
        get style() {
            return this._style;
        }
        set style(value) {
            this._style = value;
            this.setBorderProp('style', this._style);
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this.setBorderProp('color', this._color);
        }
        get top() {
            if (!this._top) {
                this._top = { ...DefaultBorderSideStyles };
            }
            return this._top;
        }
        set top(value) {
            this._top = value;
            this.setSideBorderStyles('top', value);
        }
        get right() {
            if (!this._right) {
                this._right = { ...DefaultBorderSideStyles };
            }
            return this._right;
        }
        set right(value) {
            this._right = value;
            this.setSideBorderStyles('right', value);
        }
        get bottom() {
            if (!this._bottom) {
                this._bottom = { ...DefaultBorderSideStyles };
            }
            return this._bottom;
        }
        set bottom(value) {
            this._bottom = value;
            this.setSideBorderStyles('bottom', value);
        }
        get left() {
            if (!this._left) {
                this._left = { ...DefaultBorderSideStyles };
            }
            return this._left;
        }
        set left(value) {
            this._left = value;
            this.setSideBorderStyles('left', value);
        }
        removeStyleClass(name) {
            const style = this._styleClassMap[name];
            if (style) {
                this._target.classList.remove(style);
                delete this._styleClassMap[name];
            }
        }
        setSideBorderStyles(side, value) {
            if (value && (value.width !== undefined || value.style || value.color !== undefined)) {
                let style = (0, base_css_1.getBorderSideStyleClass)(side, value);
                this.removeStyleClass(side);
                this._styleClassMap[side] = style;
                this._target.classList.add(style);
            }
        }
        setBorderStyles(value) {
            let style = (0, base_css_1.getBorderStyleClass)(value);
            this.removeStyles();
            this._styleClassMap['width'] = style;
            this._styleClassMap['style'] = style;
            this._styleClassMap['color'] = style;
            this._styleClassMap['radius'] = style;
            this._target.classList.add(style);
        }
        setBorderProp(prop, value) {
            let style = (0, base_css_1.getBorderStyleClass)({ [prop]: value });
            this.removeStyleClass('left');
            this.removeStyleClass('bottom');
            this.removeStyleClass('right');
            this.removeStyleClass('top');
            this.removeStyleClass(prop);
            this._styleClassMap[prop] = style;
            this._target.classList.add(style);
        }
    }
    exports.Border = Border;
    class Overflow {
        constructor(target, value) {
            this._target = target;
            if (value) {
                this.updateValue(value);
                this.setOverflowStyle();
            }
        }
        ;
        get x() {
            return this._value?.x ?? "visible";
        }
        set x(value) {
            if (!this._value) {
                this._value = { x: value };
            }
            else {
                this._value.x = value;
            }
            this.setOverflowStyle();
        }
        get y() {
            return this._value?.y ?? "visible";
        }
        set y(value) {
            if (!this._value) {
                this._value = { x: value };
            }
            else {
                this._value.y = value;
            }
            this.setOverflowStyle();
        }
        updateValue(value) {
            if (typeof value === 'string') {
                this._value = { x: value, y: value };
            }
            else {
                this._value = value;
            }
        }
        setOverflowStyle(value) {
            if (value) {
                this.updateValue(value);
            }
            let style = (0, base_css_1.getOverflowStyleClass)(this._value);
            if (this._style) {
                this._target.classList.remove(this._style);
            }
            this._style = style;
            this._target.classList.add(style);
        }
    }
    exports.Overflow = Overflow;
    class Background {
        constructor(target, value) {
            this._target = target;
            value && this.setBackgroundStyle(value);
        }
        ;
        get color() {
            return this._value?.color || '';
        }
        set color(value) {
            if (!this._value) {
                this._value = { color: value };
            }
            else {
                this._value.color = value;
            }
            this.setBackgroundStyle();
        }
        get image() {
            return this._value?.image || '';
        }
        set image(value) {
            if (!this._value) {
                this._value = { image: value };
            }
            else {
                this._value.image = value;
            }
            this.setBackgroundStyle();
        }
        updateValue(value) {
            this._value = value;
        }
        setBackgroundStyle(value) {
            value && this.updateValue(value);
            let style = (0, base_css_1.getBackgroundStyleClass)(this._value);
            this._style && this._target.classList.remove(this._style);
            this._style = style;
            this._target.classList.add(style);
        }
    }
    exports.Background = Background;
    function removeFirstAndLastCharacter(value) {
        return value.substring(1, value.length - 1);
    }
    ;
    exports.ControlProperties = {
        props: {
            dock: { type: 'string', default: 'none', values: ['none', 'fill', 'left', 'top', 'right', 'bottom'] },
            top: { type: 'number', default: 'auto' },
            left: { type: 'number', default: 'auto' },
            right: { type: 'number', default: 'auto' },
            bottom: { type: 'number', default: 'auto' },
            width: { type: 'number', default: 'auto' },
            height: { type: 'number', default: 'auto' },
            minWidth: { type: 'number', default: 'auto' },
            minHeight: { type: 'number', default: 'auto' },
            maxWidth: { type: 'number', default: 'auto' },
            maxHeight: { type: 'number', default: 'auto' },
            visible: { type: 'boolean', default: true },
            enabled: { type: 'boolean', default: true },
            background: { type: 'object', default: { color: '', image: '' } },
            margin: { type: 'object', default: {} },
            padding: { type: 'object', default: {} },
            opacity: { type: 'string', default: '1' },
            position: { type: 'string', default: '' },
            overflow: { type: 'object', default: { x: '', y: '' } },
            zIndex: { type: 'string', default: '' },
            border: { type: 'object', default: {} },
            display: { type: 'string', default: '' },
            mediaQueries: { type: 'array', default: [] },
            font: { type: 'object', default: { style: 'normal', transform: 'unset' } },
            stack: { type: 'object', default: { basis: '', grow: '', shrink: '' } },
            class: { type: 'string' },
            cursor: { type: 'string', default: 'auto' },
            boxShadow: { type: 'string', default: '' },
        },
        events: {
            onClick: types_2.notifyEventParams,
            onContextMenu: types_2.notifyEventParams,
            onDblClick: types_2.notifyEventParams,
            onFocus: types_2.notifyEventParams,
            onKeyDown: types_2.notifyEventParams,
            onKeyUp: types_2.notifyEventParams,
            onMouseDown: types_2.notifyEventParams,
            onMouseMove: types_2.notifyEventParams,
            onMouseUp: types_2.notifyEventParams
        }
    };
    ;
    class Control extends component_1.Component {
        // public data: any;
        static async create(options, parent, defaults) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        ;
        constructor(parent, options, defaults) {
            super(parent, options, defaults);
            this._controls = [];
            this._enabled = true;
            // protected _paddingLeft = 0;
            // protected _paddingTop = 0;
            // protected _paddingRight = 0;
            // protected _paddingBottom = 0;
            // protected _marginLeft = 0;
            // protected _marginTop = 0;
            // protected _marginRight = 0;
            // protected _marginBottom = 0;
            // protected _anchorLeft = true;
            // protected _anchorTop = true;
            // protected _anchorRight = false;
            // protected _anchorBottom = false;
            this._visible = true;
            this._designMode = false;
            this.propertyClassMap = {};
            // if (parent instanceof Container)
            // if (parent)
            this.parent = parent;
        }
        ;
        get parentModule() {
            if (!this._parentModule) {
                this._parentModule = getParentModule(this);
            }
            ;
            return this._parentModule;
        }
        ;
        _setDesignPropValue(prop, value, breakpointProp) {
            super._setDesignPropValue(prop, value, breakpointProp);
            if (exports.ControlProperties.props[prop] && prop !== 'mediaQueries') {
                if (typeof breakpointProp === 'object' && typeof value === 'object') {
                    this[prop] = { ...value, ...breakpointProp };
                }
                else
                    this[prop] = breakpointProp ?? value;
            }
            ;
        }
        ;
        _getCustomProperties() {
            let result = {
                props: {},
                events: {}
            };
            for (let n in types_2.ComponentProperty.props)
                result.props[n] = types_2.ComponentProperty.props[n];
            for (let n in types_2.ComponentProperty.events)
                result.events[n] = types_2.ComponentProperty.events[n];
            for (let n in exports.ControlProperties.props)
                result.props[n] = exports.ControlProperties.props[n];
            for (let n in exports.ControlProperties.events)
                result.events[n] = exports.ControlProperties.events[n];
            let propInfo = (0, utils_3.getCustomElementProperties)(this.tagName);
            if (propInfo) {
                result.tagName = propInfo.tagName;
                result.className = propInfo.className;
                result.icon = propInfo.icon;
                for (let n in propInfo.props)
                    result.props[n] = propInfo.props[n];
                for (let n in propInfo.events)
                    result.events[n] = propInfo.events[n];
            }
            ;
            result.dataSchema = JSON.parse(JSON.stringify(propInfo?.dataSchema || {}));
            return result;
        }
        ;
        getMarginStyle() {
            const computedStyle = window.getComputedStyle(this);
            const left = toNumberValue(computedStyle.marginLeft);
            const right = toNumberValue(computedStyle.marginRight);
            const bottom = toNumberValue(computedStyle.marginBottom);
            const top = toNumberValue(computedStyle.marginTop);
            return { top, right, bottom, left };
        }
        getPaddingStyle() {
            const computedStyle = window.getComputedStyle(this);
            const left = toNumberValue(computedStyle.paddingLeft);
            const right = toNumberValue(computedStyle.paddingRight);
            const bottom = toNumberValue(computedStyle.paddingBottom);
            const top = toNumberValue(computedStyle.paddingTop);
            return { top, right, bottom, left };
        }
        xssSanitize(value) {
            //TODO: sanitize untrusted script to prevent XSS attacks
            //https://github.com/cure53/DOMPurify
            return DOMPurify.sanitize(value);
        }
        ;
        get contextMenu() {
            if (this._contextMenuId && !this._contextMenuControl)
                this._contextMenuControl = getParentControlById(this, this._contextMenuId);
            return this._contextMenuControl;
        }
        ;
        set contextMenu(value) {
            if (typeof value === 'string') {
                this._contextMenuId = value;
                this._contextMenuControl = null;
            }
            else if (value instanceof Control) {
                this._contextMenuId = value.id;
                this._contextMenuControl = value;
            }
            else {
                this._contextMenuId = null;
                this._contextMenuControl = null;
            }
            ;
        }
        ;
        get margin() {
            return this._margin;
        }
        set margin(value) {
            if (!this._margin)
                this._margin = new SpaceValue(this, value, 'margin');
            else
                this._margin.update(value);
            // const { top = 0, right = 0, bottom = 0, left = 0 } = value;
            // this.style.margin = `${this.getSpacingValue(top)} ${this.getSpacingValue(right)} ${this.getSpacingValue(bottom)} ${this.getSpacingValue(left)}`;
            // const margin = this.getMarginStyle();
            // this._marginLeft = margin.left;
            // this._marginTop = margin.top;
            // this._marginRight = margin.right;
            // this._marginBottom = margin.bottom;
        }
        get marginStyle() {
            return (side) => this.getMarginStyle()[side];
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (!this._padding)
                this._padding = new SpaceValue(this, value, 'padding');
            else
                this._padding.update(value);
            // const { top = 0, right = 0, bottom = 0, left = 0 } = value;
            // this.style.padding = `${this.getSpacingValue(top)} ${this.getSpacingValue(right)} ${this.getSpacingValue(bottom)} ${this.getSpacingValue(left)}`;
            // const padding = this.getPaddingStyle();
            // this._paddingLeft = padding.left;
            // this._paddingTop = padding.top;
            // this._paddingRight = padding.right;
            // this._paddingBottom = padding.bottom;
        }
        get paddingStyle() {
            return (side) => this.getPaddingStyle()[side];
        }
        addChildControl(control) {
            if (!control.parentNode)
                this.appendChild(control);
        }
        removeChildControl(control) {
            if (this.contains(control))
                this.removeChild(control);
        }
        get parent() {
            return this._parent;
        }
        set parent(value) {
            if (value && value._controls.indexOf(this) < 0)
                value._controls.push(this);
            if (this._parent != value) {
                if (this._parent) {
                    if (this._parent._controls.indexOf(this) > -1)
                        this._parent._controls.splice(this._parent._controls.indexOf(this), 1);
                    // if (this._parent.contains(this)) 
                    //     this._parent.removeChild(this);
                    this._parent.removeChildControl(this);
                    if (!_refreshTimeout)
                        this._parent.refresh();
                }
                ;
                this._parent = value;
                if (this._parent) {
                    this._parent.addChildControl(this);
                    // this._parent.controls.push(this);
                    // if (this.parentNode != value) {
                    //     this._parent.appendChild(this);
                    if (!_refreshTimeout)
                        this._parent.refresh();
                    // }
                }
            }
        }
        connectedCallback() {
            super.connectedCallback();
            refresh();
            if (!this.mediaQueries)
                this.setAttributeToProperty('mediaQueries');
        }
        ;
        disconnectedCallback() {
            if (this._tooltip) {
                this._tooltip.close();
            }
            // this.parent = undefined;
            super.disconnectedCallback();
        }
        getParentHeight() {
            if (!this._parent)
                return window.innerHeight;
            else if (this._parent._container)
                return this._parent._container.offsetHeight;
            else
                return this._parent.offsetHeight;
        }
        ;
        getParentWidth() {
            if (!this._parent)
                return window.innerWidth;
            else if (this._parent._container)
                return this._parent._container.offsetWidth;
            else {
                return this._parent.offsetWidth;
            }
        }
        ;
        getParentOccupiedLeft() {
            if (!this._parent)
                return 0;
            else {
                let result = this._parent.paddingStyle('left');
                for (let i = 0; i < this._parent._controls.length; i++) {
                    let control = this._parent._controls[i];
                    if (control === this) {
                        if (this.dock == 'left')
                            return result;
                    }
                    else if (control.visible && control.dock == 'left') {
                        result += control.offsetWidth + control.marginStyle('left');
                    }
                }
                ;
                return result;
            }
            ;
        }
        ;
        getParentOccupiedRight() {
            if (!this._parent)
                return 0;
            else {
                let result = this._parent.paddingStyle('right');
                for (let i = 0; i < this._parent._controls.length; i++) {
                    let control = this._parent._controls[i];
                    if (control === this) {
                        if (this.dock == 'right')
                            return result;
                    }
                    else if (control.dock == 'right') {
                        result += control.offsetWidth + control.marginStyle('right');
                    }
                }
                ;
                return result;
            }
            ;
        }
        ;
        getParentOccupiedBottom() {
            if (!this._parent)
                return 0;
            else {
                let result = this._parent.paddingStyle('bottom');
                for (let i = 0; i < this._parent._controls.length; i++) {
                    let control = this._parent._controls[i];
                    if (control === this) {
                        if (this.dock == 'bottom')
                            return result;
                    }
                    else if (control.visible && control.dock == 'bottom') {
                        result += control.offsetHeight + control.marginStyle('bottom');
                    }
                }
                ;
                return result;
            }
            ;
        }
        ;
        getParentOccupiedTop() {
            if (!this._parent)
                return 0;
            else {
                let result = this._parent.paddingStyle('top');
                for (let i = 0; i < this._parent._controls.length; i++) {
                    let control = this._parent._controls[i];
                    if (control === this) {
                        if (this.dock == 'top')
                            return result;
                    }
                    else if (control.visible && control.dock == 'top') {
                        result += control.offsetHeight + control.marginStyle('top');
                    }
                }
                ;
                return result;
            }
            ;
        }
        ;
        get dock() {
            return this._dock || '';
        }
        set dock(value) {
            this._dock = value;
            if (this._resizer)
                this._resizer.reset();
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(value) {
            if (this._enabled != value) {
                this._enabled = value;
                if (value) {
                    this.classList.remove('disabled');
                    this.classList.remove(base_css_1.disabledStyle);
                }
                else {
                    this.classList.add('disabled');
                    this.classList.add(base_css_1.disabledStyle);
                }
            }
        }
        _handleClick(event, stopPropagation) {
            if (this._onClick && typeof this._onClick === 'function') {
                this._onClick(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleClick = parent._handleClick.bind(parent);
                return parent._handleClick(event);
            }
            else
                return true;
        }
        _handleContextMenu(event, stopPropagation) {
            let contextMenu = this.contextMenu;
            if (contextMenu) {
                contextMenu.show({ x: event.clientX, y: event.clientY });
            }
            ;
            if (this._onContextMenu) {
                this._onContextMenu(this, event);
                return true;
            }
            else if (!stopPropagation && !contextMenu) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleContextMenu = parent._handleContextMenu.bind(parent);
                return parent._handleContextMenu(event);
            }
            else
                return true;
        }
        ;
        _handleDblClick(event, stopPropagation) {
            if (this._onDblClick) {
                this._onDblClick(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleDblClick = parent._handleDblClick.bind(parent);
                return parent._handleDblClick(event);
            }
            else
                return true;
        }
        _handleFocus(event, stopPropagation) {
            if (this._onFocus) {
                this._onFocus(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleFocus = parent._handleFocus.bind(parent);
                return parent._handleFocus(event);
            }
            else
                return true;
        }
        ;
        _handleKeyDown(event, stopPropagation) {
            if (this._onKeyDown) {
                this._onKeyDown(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleKeyDown = parent._handleKeyDown.bind(parent);
                return parent._handleKeyDown(event);
            }
            else
                return true;
        }
        ;
        _handleKeyUp(event, stopPropagation) {
            if (this._onKeyUp) {
                this._onKeyUp(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleKeyUp = parent._handleKeyUp.bind(parent);
                return parent._handleKeyUp(event);
            }
            else
                return true;
        }
        ;
        _handleMouseDown(event, stopPropagation) {
            if (this._onMouseDown) {
                this._onMouseDown(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleMouseDown = parent._handleMouseDown.bind(parent);
                return parent._handleMouseDown(event);
            }
            else
                return true;
        }
        ;
        _handleMouseMove(event, stopPropagation) {
            if (this._onMouseMove) {
                this._onMouseMove(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleMouseMove = parent._handleMouseMove.bind(parent);
                return parent._handleMouseMove(event);
            }
            else
                return true;
        }
        ;
        _handleMouseUp(event, stopPropagation) {
            if (this._onMouseUp) {
                this._onMouseUp(this, event);
                return true;
            }
            else if (!stopPropagation) {
                let parent = getParentControl(this);
                if (!parent)
                    return false;
                parent._handleMouseUp = parent._handleMouseUp.bind(parent);
                return parent._handleMouseUp(event);
            }
            else
                return true;
        }
        get maxWidth() {
            return this.style.maxWidth;
        }
        set maxWidth(value) {
            if (!isNaN(Number(value))) {
                this.style.maxWidth = value + 'px';
            }
            else {
                this.style.maxWidth = value + "";
            }
        }
        get minWidth() {
            return this.style.minWidth;
        }
        set minWidth(value) {
            if (!isNaN(Number(value))) {
                this.style.minWidth = value + 'px';
            }
            else {
                this.style.minWidth = value + "";
            }
        }
        get designMode() {
            return this._designMode ?? false;
        }
        set designMode(value) {
            this._designMode = value ?? false;
            if (this._tooltip)
                this._tooltip.designMode = value;
        }
        observables(propName) {
            let self = this;
            if (self['$observables'] && self['$observables'][propName])
                return self['$observables'][propName];
        }
        get onClick() {
            return this._onClick;
        }
        set onClick(callback) {
            this._onClick = callback;
        }
        get onContextMenu() {
            return this._onContextMenu;
        }
        set onContextMenu(callback) {
            this._onContextMenu = callback;
        }
        get onDblClick() {
            return this._onDblClick;
        }
        set onDblClick(callback) {
            this._onDblClick = callback;
        }
        get onMouseDown() {
            return this._onMouseDown;
        }
        ;
        set onMouseDown(callback) {
            this._onMouseDown = callback;
        }
        ;
        get onMouseUp() {
            return this._onMouseUp;
        }
        ;
        set onMouseUp(callback) {
            this._onMouseUp = callback;
        }
        ;
        set onObserverChanged(callback) {
            if (!this._onObserverChanged)
                this._onObserverChanged = callback;
        }
        get onObserverChanged() {
            return this._onObserverChanged;
        }
        ;
        clearInnerHTML() {
            this.innerHTML = '';
        }
        ;
        refresh() {
            if (this._dock != null) {
                // this.style.position = 'absolute';
                if (!this.position)
                    this.style.position = 'absolute';
                switch (this.dock) {
                    case 'none': {
                        if (this.anchor.top === false)
                            this.top = (this.getParentHeight() - this.offsetHeight) / 2;
                        if (this.anchor.left === false)
                            this.left = (this.getParentWidth() - this.offsetWidth) / 2;
                        break;
                    }
                    case 'left': {
                        let top = this.getParentOccupiedTop();
                        this.top = top; // + this.marginStyle('top');
                        this.left = this.getParentOccupiedLeft();
                        this.height = this.getParentHeight() - top - this.getParentOccupiedBottom() - this.marginStyle('top') - this.marginStyle('bottom');
                        break;
                    }
                    case 'top': {
                        this.top = this.getParentOccupiedTop();
                        this.width = this.getParentWidth();
                        if (this.anchor.left)
                            this.left = 0;
                        else
                            this.left = (this.getParentWidth() - this.offsetWidth) / 2;
                        break;
                    }
                    case 'right': {
                        let top = this.getParentOccupiedTop();
                        this.top = top;
                        this.left = this.getParentWidth() - this.getParentOccupiedRight() - this.offsetWidth;
                        this.height = this.getParentHeight() - top - this.getParentOccupiedBottom();
                        break;
                    }
                    case 'bottom':
                        this.top = this.getParentHeight() - this.getParentOccupiedBottom() - this.offsetHeight;
                        this.left = 0;
                        this.width = this.getParentWidth();
                        break;
                    case 'fill':
                        this.width = this.getParentWidth() - this.getParentOccupiedLeft() - this.getParentOccupiedRight();
                        this.height = this.getParentHeight() - this.getParentOccupiedTop() - this.getParentOccupiedBottom();
                        this.left = this.getParentOccupiedLeft();
                        this.top = this.getParentOccupiedTop();
                        break;
                    case 'center':
                        this.left = (this.getParentWidth() - this.offsetWidth) / 2;
                        this.top = (this.getParentHeight() - this.offsetHeight) / 2;
                        break;
                }
            }
            ;
        }
        get resizable() {
            return this.attrs['resizer'] == true && ['left', 'top', 'right', 'bottom'].indexOf(this.dock) >= 0;
        }
        setProperty(propName, value) {
            if (value?.__target) {
                let target = value.__target;
                let path = value.__path;
                this[propName] = target[path[0]];
                (0, observable_2.Observe)(target.observables(path[0]), (changes) => {
                    let change = changes[0];
                    this[propName] = change.value;
                });
            }
            else {
                this.setAttribute(propName, value);
            }
        }
        setAttributeToProperty(propertyName) {
            const prop = this.getAttribute(propertyName, true);
            if (prop !== null && prop !== undefined)
                this[propertyName] = prop;
        }
        init() {
            super.init();
            this.setAttributeToProperty('height');
            this.setAttributeToProperty('left');
            this.setAttributeToProperty('top');
            this.setAttributeToProperty('right');
            this.setAttributeToProperty('bottom');
            this.setAttributeToProperty('width');
            this.setAttributeToProperty('dock');
            this.setAttributeToProperty('margin');
            this.setAttributeToProperty('padding');
            this.setAttributeToProperty('tag');
            this.setAttributeToProperty('anchor');
            this.setAttributeToProperty('contextMenu');
            // this._marginLeft = this.getPositionAttribute('marginLeft', true, 0);
            // this._marginTop = this.getPositionAttribute('marginTop', true, 0);
            // this._marginRight = this.getPositionAttribute('marginRight', true, 0);
            // this._marginBottom = this.getPositionAttribute('marginBottom', true, 0);
            // this._paddingLeft = this.getPositionAttribute('paddingLeft', true, 0);
            // this._paddingTop = this.getPositionAttribute('paddingTop', true, 0);
            // this._paddingRight = this.getPositionAttribute('paddingRight', true, 0);
            // this._paddingBottom = this.getPositionAttribute('paddingBottom', true, 0);
            // this._anchorLeft = this.getAttribute('anchorLeft', true, true);
            // this._anchorTop = this.getAttribute('anchorTop', true, true);
            // this._anchorRight = this.getAttribute('anchorRight', true, false);
            // this._anchorBottom = this.getAttribute('anchorBottom', true, false);
            this.setAttributeToProperty('maxWidth');
            this.setAttributeToProperty('minWidth');
            this.setAttributeToProperty('stack');
            this.setAttributeToProperty('grid');
            this.setAttributeToProperty('display');
            this.setAttributeToProperty('position');
            if ((this._left != null || this._top != null) && !this.position)
                this.style.position = 'absolute';
            if (this.getAttribute('enabled') !== false)
                this.classList.add('enabled');
            else
                this.enabled = false;
            if (this.getAttribute('visible') == false)
                this.visible = false;
            this.setAttributeToProperty('background');
            this.setAttributeToProperty('zIndex');
            this.setAttributeToProperty('lineHeight');
            this.setAttributeToProperty('linkTo');
            this.setAttributeToProperty('maxHeight');
            this.setAttributeToProperty('minHeight');
            this.setAttributeToProperty('opacity');
            const tooltip = this.getAttribute('tooltip', true);
            if (tooltip && !this._tooltip) {
                let constructor = window.customElements.get('i-tooltip');
                if (constructor) {
                    let t = new constructor(this, this.parentModule?.i18n);
                    this._tooltip = t;
                }
            }
            ;
            // tooltip && (this._tooltip = new Tooltip(this))
            const font = this.getAttribute('font', true);
            font && (this.font = font);
            let border = this.getAttribute('border', true);
            if (border) {
                this.border = new Border(this, border);
            }
            this.setAttributeToProperty('overflow');
            this.setAttributeToProperty('cursor');
            this.setAttributeToProperty('letterSpacing');
            this.setAttributeToProperty('boxShadow');
            this.setAttributeToProperty('designMode');
            // this.setAttributeToProperty('mediaQueries');
            // this.addEventListener('click', this._handleClick.bind(this));
            // this.addEventListener('dblclick', this._handleDblClick.bind(this));
            // this.addEventListener('oncontextmenu', this._handleContextMenu.bind(this));
        }
        setElementPosition(elm, prop, value) {
            if (value != null && !isNaN(value)) {
                this['_' + prop] = parseFloat(value);
                elm.style[prop] = parseFloat(value) + 'px';
            }
            else if (value != null) {
                this['_' + prop] = value;
                elm.style[prop] = value;
            }
        }
        setPosition(prop, value) {
            if (value != null && !isNaN(value)) {
                this['_' + prop] = parseFloat(value);
                this.style[prop] = parseFloat(value) + 'px';
            }
            else if (value != null) {
                this['_' + prop] = value;
                this.style[prop] = value;
            }
            ;
        }
        ;
        get height() {
            return (!isNaN(this._height) ? this._height : this.offsetHeight);
        }
        ;
        set height(value) {
            this.setPosition('height', value);
        }
        ;
        get heightValue() {
            if (typeof (this._height) == 'string')
                return parseInt(this._height, 10);
            else
                return this._height;
        }
        ;
        get left() {
            return (!isNaN(this._left) ? this._left : this.offsetLeft);
        }
        set left(value) {
            if (!this.dock)
                this.dock = 'none';
            this.setPosition('left', value);
        }
        set right(value) {
            if (!this.dock)
                this.dock = 'none';
            this.setPosition('right', value);
        }
        set bottom(value) {
            if (!this.dock)
                this.dock = 'none';
            this.setPosition('bottom', value);
        }
        get top() {
            return (!isNaN(this._top) ? this._top : this.offsetTop);
        }
        set top(value) {
            if (!this.dock)
                this.dock = 'none';
            this.setPosition('top', value);
        }
        get visible() {
            return this._visible;
        }
        set visible(value) {
            this._visible = value;
            if (!this._visible)
                this.style.display = 'none';
            else if (this._left != null || this._top != null)
                this.style.display = '';
            else if (this.style.display === 'none')
                this.style.display = '';
            if (this._parent && !_refreshTimeout)
                this._parent.refresh();
        }
        get width() {
            return (!isNaN(this._width) ? this._width : this.offsetWidth);
        }
        set width(value) {
            this.setPosition('width', value);
        }
        get widthValue() {
            if (typeof (this._width) == 'string')
                return parseInt(this._width, 10);
            else
                return this._width;
        }
        ;
        get stack() {
            return this._stack;
        }
        set stack(value) {
            this._stack = value;
            this.style.flexBasis = value.basis || '';
            this.style.flexGrow = value.grow || '';
            this.style.flexShrink = value.shrink || '';
        }
        get grid() {
            return this._grid;
        }
        set grid(value) {
            this._grid = value;
            if (value.column && value.columnSpan)
                this.style.gridColumn = value.column + ' / span ' + value.columnSpan;
            else if (value.column)
                this.style.gridColumnStart = value.column.toString();
            else if (value.columnSpan)
                this.style.gridColumn = 'span ' + value.columnSpan;
            if (value.row && value.rowSpan)
                this.style.gridRow = value.row + ' / span ' + value.rowSpan;
            else if (value.row)
                this.style.gridRowStart = value.row.toString();
            else if (value.rowSpan)
                this.style.gridRow = 'span ' + value.rowSpan;
            if (value.area)
                this.style.gridArea = value.area;
            if (value.horizontalAlignment)
                this.style.justifyContent = value.horizontalAlignment;
            if (value.verticalAlignment)
                this.style.alignItems = value.verticalAlignment;
        }
        get background() {
            if (!this._background) {
                this._background = new Background(this);
            }
            return this._background;
        }
        set background(value) {
            if (!this._background) {
                this._background = new Background(this, value);
            }
            else {
                this._background.setBackgroundStyle(value);
            }
        }
        get zIndex() {
            return this._zIndex;
        }
        set zIndex(value) {
            this.style.zIndex = value + "";
            this._zIndex = value + "";
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(value) {
            this._lineHeight = value;
            this.style.lineHeight = "" + value;
        }
        get linkTo() {
            return this._linkTo;
        }
        set linkTo(value) {
            this._linkTo = value;
        }
        get position() {
            return this.style.position;
        }
        set position(value) {
            this.style.position = value;
        }
        get maxHeight() {
            return this.style.maxHeight;
        }
        set maxHeight(value) {
            if (!isNaN(Number(value))) {
                this.style.maxHeight = value + 'px';
            }
            else {
                this.style.maxHeight = value + "";
            }
        }
        get minHeight() {
            return this.style.minHeight;
        }
        set minHeight(value) {
            if (!isNaN(Number(value))) {
                this.style.minHeight = value + 'px';
            }
            else {
                this.style.minHeight = value + "";
            }
        } // TODO: fix
        get border() {
            if (!this._border) {
                this._border = new Border(this);
            }
            return this._border;
        }
        set border(value) {
            if (!this.border) {
                this._border = new Border(this, value);
            }
            else {
                this._border.updateValue(value);
            }
        }
        get overflow() {
            if (!this._overflow) {
                this._overflow = new Overflow(this);
            }
            return this._overflow;
        }
        set overflow(value) {
            if (!this._overflow) {
                this._overflow = new Overflow(this, value);
            }
            else {
                this._overflow.setOverflowStyle(value);
            }
        }
        get tooltip() {
            if (!this._tooltip) {
                let constructor = window.customElements.get('i-tooltip');
                if (constructor) {
                    let t = new constructor(this, this.parentModule?.i18n);
                    this._tooltip = t;
                }
                ;
                // this._tooltip = new Tooltip(this);
                this._tooltip.designMode = this.designMode;
            }
            return this._tooltip;
        }
        get font() {
            return {
                color: this.style.color,
                name: this.style.fontFamily,
                size: this.style.fontSize,
                bold: this.style.fontStyle.indexOf('bold') >= 0,
                style: this.style.fontStyle,
                transform: this.style.textTransform,
                weight: this.style.fontWeight,
                shadow: this.style.textShadow
            };
        }
        set font(value) {
            this.style.color = value.color || '';
            this.style.fontSize = value.size || '';
            this.style.fontFamily = value.name || '';
            this.style.fontStyle = value.style || '';
            this.style.textTransform = value.transform || 'none';
            this.style.fontWeight = value.bold ? 'bold' : `${value.weight || ''}`;
            this.style.textShadow = value.shadow || 'none';
        }
        get display() {
            return this._display;
        }
        set display(value) {
            this._display = value;
            this.style.display = this.visible === false ? 'none' : value;
        }
        get anchor() {
            return this._anchor || DefaultAnchor;
        }
        set anchor(value) {
            const data = { ...DefaultAnchor, ...value };
            this._anchor = data;
        }
        get opacity() {
            return this._opacity;
        }
        set opacity(value) {
            this._opacity = typeof value === 'string' ? value : `${value}`;
            if (this._opacity) {
                const style = (0, base_css_1.getOpacityStyleClass)(value);
                this.setStyle('opacity', style);
            }
            else {
                this.removeStyle('opacity');
            }
        }
        get cursor() {
            return this.style.cursor;
        }
        set cursor(value) {
            this.style.cursor = value;
        }
        get letterSpacing() {
            return this.style.letterSpacing;
        }
        set letterSpacing(value) {
            if (!isNaN(Number(value))) {
                this.style.letterSpacing = value + 'px';
            }
            else {
                this.style.letterSpacing = value + "";
            }
        }
        get boxShadow() {
            return this.style.boxShadow;
        }
        set boxShadow(value) {
            this.style.boxShadow = value;
        }
        get mediaQueries() {
            return this._cmediaQueries;
        }
        set mediaQueries(value) {
            this._cmediaQueries = value;
            let style = (0, base_css_1.getControlMediaQueriesStyleClass)(this._cmediaQueries, { display: this.display });
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        removeStyle(propertyName) {
            let style = this.propertyClassMap[propertyName];
            if (style)
                this.classList.remove(style);
        }
        setStyle(propertyName, value) {
            this.removeStyle(propertyName);
            if (value) {
                this.propertyClassMap[propertyName] = value;
                this.classList.add(value);
            }
        }
        updateLocale(i18n) {
            if (this._tooltip) {
                this._tooltip.updateLocale(i18n);
            }
        }
        ;
    }
    exports.Control = Control;
    ;
    class ContainerResizer {
        constructor(target) {
            this.target = target;
            this._mouseDownHandler = this.handleMouseDown.bind(this);
            this._mouseUpHandler = this.handleMouseUp.bind(this);
            this._mouseMoveHandler = this.handleMouseMove.bind(this);
        }
        ;
        reset() {
            if (!this.target.resizable && this._resizer) {
                this._resizer.removeEventListener('mousedown', this._mouseDownHandler);
                this.target.removeChild(this._resizer);
                this._resizer = undefined;
            }
            else if (this.target.resizable) {
                switch (this.target.dock) {
                    case 'left':
                        this.resizer.classList.value = 'resizer e-resize';
                        break;
                    case 'top':
                        this.resizer.classList.value = 'resizer s-resize';
                        break;
                    case 'right':
                        this.resizer.classList.value = 'resizer w-resize';
                        break;
                    case 'bottom':
                        this.resizer.classList.value = 'resizer n-resize';
                        break;
                }
                ;
            }
            ;
        }
        ;
        handleMouseDown(e) {
            // e.preventDefault();
            // e.stopPropagation();
            this.target.classList.add('resizing');
            this._origHeight = this.target.offsetHeight;
            this._origWidth = this.target.offsetWidth;
            if (this._resizer) {
                this._resizer.classList.add('highlight');
                this._mouseDownPos = {
                    x: e.clientX,
                    y: e.clientY
                };
                document.addEventListener('mousemove', this._mouseMoveHandler);
                document.addEventListener('mouseup', this._mouseUpHandler);
            }
        }
        ;
        handleMouseMove(e) {
            e.preventDefault();
            e.stopPropagation();
            let offsetX = e.clientX - this._mouseDownPos.x;
            let offsetY = e.clientY - this._mouseDownPos.y;
            switch (this.target.dock) {
                case 'left':
                    this.target.style.width = (this._origWidth + offsetX) + 'px';
                    this.target.parent?.refresh();
                    break;
                case 'top':
                    this.target.style.height = (this._origHeight + offsetY) + 'px';
                    this.target.parent?.refresh();
                    break;
                case 'right':
                    this.target.style.width = (this._origWidth - offsetX) + 'px';
                    this.target.parent?.refresh();
                    break;
                case 'bottom':
                    this.target.style.height = (this._origHeight - offsetY) + 'px';
                    this.target.parent?.refresh();
                    break;
            }
        }
        ;
        handleMouseUp(e) {
            document.removeEventListener('mousemove', this._mouseMoveHandler);
            document.removeEventListener('mouseup', this._mouseUpHandler);
            // e.preventDefault();
            // e.stopPropagation();
            this.target.classList.remove('resizing');
            if (this._resizer)
                this._resizer.classList.remove('highlight');
        }
        ;
        get resizer() {
            if (!this._resizer) {
                this._resizer = document.createElement('span');
                this.target.appendChild(this._resizer);
                this._resizer.addEventListener('mousedown', this._mouseDownHandler);
            }
            ;
            return this._resizer;
        }
        ;
    }
    exports.ContainerResizer = ContainerResizer;
    ;
    class Container extends Control {
        get controls() {
            return this._controls;
        }
        get resizer() {
            return this.attrs['resizer'] == true;
        }
        ;
        set resizer(value) {
            this.attrs['resizer'] = value;
            if (this.resizable && !this._resizer)
                this._resizer = new ContainerResizer(this);
            if (this._resizer)
                this._resizer.reset();
        }
        init() {
            super.init();
            this.classList.add(base_css_1.containerStyle);
            if (this.resizable && !this._resizer) {
                this._resizer = new ContainerResizer(this);
                this._resizer.reset();
            }
            ;
        }
        ;
        refreshControls() {
            for (let i = 0; i < this._controls.length; i++)
                this._controls[i].refresh();
        }
        ;
        refresh(skipRefreshControls) {
            super.refresh();
            for (let i = 0; i < this.childNodes.length; i++) {
                let node = this.childNodes[i];
                if (node instanceof Control) {
                    node.parent = this;
                }
                ;
            }
            ;
            if (!skipRefreshControls)
                this.refreshControls();
        }
        ;
        updateLocale(i18n) {
            if (this._controls?.length) {
                for (let i = 0; i < this._controls.length; i++)
                    this._controls[i].updateLocale(i18n);
            }
            else {
                const childNodes = this.childNodes;
                for (const childNode of childNodes) {
                    if (childNode instanceof Control) {
                        childNode.updateLocale(i18n);
                    }
                }
            }
        }
        ;
    }
    exports.Container = Container;
    ;
});
define("@ijstech/base/permissions.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Permissions = void 0;
    class Permissions {
        constructor() { }
        async query(name, descriptor) {
            try {
                const status = await navigator.permissions.query(Object.assign({ name }, descriptor));
                return status;
            }
            catch (e) {
            }
            return null;
        }
        async request(name) {
            if (name === 'geolocation') {
                return navigator.geolocation.getCurrentPosition(() => { });
            }
            else if (name === 'notifications') {
                return Notification.requestPermission();
            }
            else if (name === 'camera') {
                return navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            }
            else if (name === 'microphone') {
                return navigator.mediaDevices.getUserMedia({ video: false, audio: true });
            }
            return false;
        }
    }
    exports.Permissions = Permissions;
});
define("@ijstech/base", ["require", "exports", "@ijstech/base/observable.ts", "@ijstech/base/component.ts", "@ijstech/base/control.ts", "@ijstech/base/control.ts", "@ijstech/base/i18n.ts", "@ijstech/base/types.ts", "@ijstech/base/style/base.css.ts", "@ijstech/base/utils.ts", "@ijstech/base/permissions.ts"], function (require, exports, observable_3, component_2, control_1, control_2, i18n_1, Types, base_css_2, utils_4, permissions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAttributeToProperty = exports.customModule = exports.RequireJS = exports.LibPath = exports.Permissions = exports.getCustomElements = exports.customElements = exports.IdUtils = exports.getMediaQueryRule = exports.getSpacingValue = exports.getBackground = exports.getControlMediaQueriesStyle = exports.Types = exports.Container = exports.Control = exports.I18n = exports.Overflow = exports.SpaceValue = exports.Border = exports.Background = exports.Component = exports.observable = exports.isObservable = exports.Observables = exports.ClearObservers = exports.Unobserve = exports.Observe = void 0;
    Object.defineProperty(exports, "Observe", { enumerable: true, get: function () { return observable_3.Observe; } });
    Object.defineProperty(exports, "Unobserve", { enumerable: true, get: function () { return observable_3.Unobserve; } });
    Object.defineProperty(exports, "ClearObservers", { enumerable: true, get: function () { return observable_3.ClearObservers; } });
    Object.defineProperty(exports, "Observables", { enumerable: true, get: function () { return observable_3.Observables; } });
    Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return observable_3.isObservable; } });
    Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_3.observable; } });
    Object.defineProperty(exports, "Component", { enumerable: true, get: function () { return component_2.Component; } });
    Object.defineProperty(exports, "Background", { enumerable: true, get: function () { return control_1.Background; } });
    Object.defineProperty(exports, "Border", { enumerable: true, get: function () { return control_1.Border; } });
    Object.defineProperty(exports, "SpaceValue", { enumerable: true, get: function () { return control_1.SpaceValue; } });
    Object.defineProperty(exports, "Overflow", { enumerable: true, get: function () { return control_1.Overflow; } });
    Object.defineProperty(exports, "Control", { enumerable: true, get: function () { return control_2.Control; } });
    Object.defineProperty(exports, "Container", { enumerable: true, get: function () { return control_2.Container; } });
    Object.defineProperty(exports, "I18n", { enumerable: true, get: function () { return i18n_1.I18n; } });
    exports.Types = Types;
    Object.defineProperty(exports, "getControlMediaQueriesStyle", { enumerable: true, get: function () { return base_css_2.getControlMediaQueriesStyle; } });
    Object.defineProperty(exports, "getBackground", { enumerable: true, get: function () { return base_css_2.getBackground; } });
    Object.defineProperty(exports, "getSpacingValue", { enumerable: true, get: function () { return base_css_2.getSpacingValue; } });
    Object.defineProperty(exports, "getMediaQueryRule", { enumerable: true, get: function () { return base_css_2.getMediaQueryRule; } });
    Object.defineProperty(exports, "IdUtils", { enumerable: true, get: function () { return utils_4.IdUtils; } });
    Object.defineProperty(exports, "customElements", { enumerable: true, get: function () { return utils_4.customElements; } });
    Object.defineProperty(exports, "getCustomElements", { enumerable: true, get: function () { return utils_4.getCustomElements; } });
    Object.defineProperty(exports, "Permissions", { enumerable: true, get: function () { return permissions_1.Permissions; } });
    let scripts = document.getElementsByTagName("script");
    // let LibUrl = new URL(scripts[scripts.length - 1].src);
    // let pathname = LibUrl.pathname;
    let pathname = scripts[scripts.length - 1].src;
    let lastIndex = pathname.lastIndexOf('/');
    let LibPath = pathname.slice(0, lastIndex + 1);
    exports.LibPath = LibPath;
    exports.RequireJS = {
        config(config) {
            (window.require).config(config);
        },
        require(reqs, callback) {
            (window.require)(reqs, callback);
        },
        defined(module) {
            return (window.require).defined(module);
        }
    };
    ;
    ;
    function customModule(target) {
        _currentDefineModule = target;
    }
    exports.customModule = customModule;
    ;
    function setAttributeToProperty(element, propertyName, defaultValue) {
        const prop = element.getAttribute(propertyName, true, defaultValue);
        if (prop)
            element[propertyName] = prop;
    }
    exports.setAttributeToProperty = setAttributeToProperty;
});
///<amd-module name='@ijstech/ipfs/types.ts'/> 
define("@ijstech/ipfs/types.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CidCode = void 0;
    var CidCode;
    (function (CidCode) {
        CidCode[CidCode["DAG_PB"] = 112] = "DAG_PB";
        CidCode[CidCode["RAW"] = 85] = "RAW";
    })(CidCode = exports.CidCode || (exports.CidCode = {}));
    ;
    ;
    ;
});
///<amd-module name='@ijstech/ipfs/utils.ts'/> 
/*!-----------------------------------------------------------
* Copyright (c) IJS Technologies. All rights reserved.
* Released under dual BUSL-1.1/commercial license
* https://ijs.network
*-----------------------------------------------------------*/
define("@ijstech/ipfs/utils.ts", ["require", "exports", "@ijstech/ipfs/types.ts"], function (require, exports, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cidToHash = exports.hashFile = exports.hashContent = exports.hashItems = exports.hashChunks = exports.hashChunk = exports.parse = void 0;
    // import { RequireJS, LibPath } from '@ijstech/base';
    // RequireJS.require(['@ijstech/ipfs-util'], (lib: any) => {
    //     IPFS = lib;
    // });
    const IPFS = window['require']('@ijstech/ipfs-utils');
    function parse(cid, bytes) {
        let result = IPFS.parse(cid, bytes);
        let links = [];
        if (result.links) {
            for (let i = 0; i < result.links.length; i++) {
                let link = result.links[i];
                links.push({
                    cid: link.Hash.toString(),
                    name: link.Name,
                    size: link.Tsize
                });
            }
        }
        ;
        return {
            cid: cid,
            size: result.size,
            code: result.code,
            type: result.type == 'directory' ? 'dir' : result.type == 'file' ? 'file' : result.code == types_1.CidCode.RAW ? 'file' : undefined,
            multihash: result.multihash,
            links: links,
            bytes: result.bytes
        };
    }
    exports.parse = parse;
    ;
    ;
    async function hashChunk(data /*Buffer*/, version) {
        if (version == undefined)
            version = 1;
        return IPFS.hashChunk(data, version);
    }
    exports.hashChunk = hashChunk;
    ;
    async function hashChunks(chunks, version) {
        if (version == undefined)
            version = 1;
        return IPFS.hashChunks(chunks, version);
    }
    exports.hashChunks = hashChunks;
    ;
    async function hashItems(items, version) {
        return await IPFS.hashItems(items || [], version);
    }
    exports.hashItems = hashItems;
    ;
    async function hashContent(content, version) {
        if (version == undefined)
            version = 1;
        if (content.length == 0) {
            return {
                cid: version == 1 ? 'bafkreihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku' : 'QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH',
                type: 'file',
                code: version == 1 ? 0x55 : 0x70,
                size: 0
            };
        }
        return IPFS.hashContent(content, version);
    }
    exports.hashContent = hashContent;
    ;
    async function hashFile(file, version) {
        if (version == undefined)
            version = 1;
        if (file instanceof File) {
            if (file.size == 0)
                return await IPFS.hashContent('', version);
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsArrayBuffer(file);
                reader.addEventListener('error', (event) => {
                    reject('Error occurred reading file');
                });
                reader.addEventListener('load', async (event) => {
                    const data = new Uint8Array(event.target.result);
                    let result = await IPFS.hashContent(data, version);
                    resolve(result);
                });
            });
        }
        else
            return IPFS.hashContent(file, version);
    }
    exports.hashFile = hashFile;
    ;
    function cidToHash(cid) {
        return IPFS.cidToHash(cid);
    }
    exports.cidToHash = cidToHash;
    ;
});
define("@ijstech/ipfs/fileManager.ts", ["require", "exports", "@ijstech/ipfs/utils.ts", "@ijstech/ipfs/types.ts"], function (require, exports, utils_1, types_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileManager = exports.FileNode = exports.FileManagerHttpTransport = void 0;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    class FileManagerHttpTransport {
        constructor(options) {
            this.updated = {};
            this.options = options || {};
            this.options.endpoint = this.options.endpoint || '';
        }
        ;
        async applyUpdate(node) {
            let cidInfo = node.cidInfo;
            if (cidInfo && !this.updated[cidInfo.cid]) {
                let result = await this.getUploadUrl(cidInfo, node.isRoot);
                let endpoints = result?.data;
                if (await node.isFolder()) {
                    let url = endpoints?.[cidInfo.cid];
                    if (!url?.exists && cidInfo.bytes && url?.url) {
                        let method = url?.method || 'PUT';
                        let headers = url?.headers || {};
                        headers['Content-Type'] = headers['Content-Type'] || 'application/octet-stream';
                        headers['Content-Length'] = cidInfo.bytes.length.toString();
                        let res = await fetch(url.url, {
                            method: method,
                            headers: headers,
                            body: cidInfo.bytes
                        });
                        if (!res.ok)
                            throw new Error(res.statusText);
                    }
                    ;
                }
                else if (cidInfo.links?.length && cidInfo.links?.length > 0) {
                    let offset = 0;
                    for (let link of cidInfo.links) {
                        let url = endpoints?.[link.cid];
                        if (url?.url && !url?.exists) {
                            let method = url?.method || 'PUT';
                            let headers = url?.headers || {};
                            headers['Content-Type'] = headers['Content-Type'] || 'application/octet-stream';
                            headers['Content-Length'] = link.size.toString();
                            let body;
                            if (node.fileContent)
                                body = node.fileContent?.slice(offset, offset + link.size);
                            else if (node.file) {
                                let chunk = node.file.slice(offset, offset + link.size);
                                body = chunk;
                            }
                            ;
                            offset += link.size;
                            let res = await fetch(url.url, {
                                method: method,
                                headers: headers,
                                body: body
                            });
                            if (!res.ok)
                                throw new Error(res.statusText);
                        }
                        ;
                    }
                    ;
                    if (cidInfo.bytes) {
                        let url = endpoints?.[cidInfo.cid];
                        if (url?.url && !url?.exists) {
                            let method = url?.method || 'PUT';
                            let headers = url?.headers || {};
                            headers['Content-Type'] = headers['Content-Type'] || 'application/octet-stream';
                            headers['Content-Length'] = cidInfo.bytes.length.toString();
                            let res = await fetch(url.url, {
                                method: method,
                                headers: headers,
                                body: cidInfo.bytes
                            });
                            if (!res.ok)
                                throw new Error(res.statusText);
                        }
                        ;
                    }
                    ;
                }
                else if (endpoints?.[cidInfo.cid]) {
                    let url = endpoints[cidInfo.cid];
                    if (!url?.exists) {
                        let method = url?.method || 'PUT';
                        let headers = url?.headers || {};
                        headers['Content-Type'] = headers['Content-Type'] || 'application/octet-stream';
                        headers['Content-Length'] = cidInfo.size.toString();
                        let body;
                        if (node.fileContent)
                            body = node.fileContent;
                        else if (node.file) {
                            body = node.file;
                        }
                        ;
                        let res = await fetch(url.url, {
                            method: method,
                            headers: headers,
                            body: body
                        });
                        if (!res.ok)
                            throw new Error(res.statusText);
                    }
                    ;
                }
                ;
                this.updated[cidInfo.cid] = true;
            }
            ;
            if (node.isRoot) {
                let signature;
                if (this.options.signer) {
                    signature = await this.options.signer.sign({
                        action: 'UPDATE_ROOT',
                        timestamp: new Date().getTime(),
                        data: {
                            cid: node.cid
                        }
                    }, {
                        action: 'string',
                        timestamp: 'number',
                        data: 'object'
                    });
                }
                ;
                let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'UPDATE_ROOT',
                        signature: signature,
                        data: {
                            cid: node.cid
                        }
                    })
                });
                return await result.json();
            }
            ;
            return {
                success: true
            };
        }
        ;
        async getCidInfo(cid) {
            let cidInfo = (0, utils_1.parse)(cid);
            if (cidInfo.code == types_2.CidCode.DAG_PB) {
                let data = await fetch(`${this.options.endpoint}/stat/${cid}`);
                if (data.status == 200) {
                    return await data.json();
                }
            }
            else
                return cidInfo;
        }
        ;
        async getRoot() {
            let signature;
            if (this.options.signer)
                signature = await this.options.signer.sign({
                    action: 'GET_ROOT',
                    timestamp: new Date().getTime()
                }, {
                    action: 'string',
                    timestamp: 'number'
                });
            let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    action: 'GET_ROOT',
                    signature: signature
                })
            });
            return await result.json();
        }
        ;
        async getUploadUrl(cidInfo, isRoot) {
            let req = {
                cid: cidInfo.cid,
                name: cidInfo.name,
                size: cidInfo.size,
                type: cidInfo.type,
                links: []
            };
            let signature;
            if (cidInfo.links) {
                for (let link of cidInfo.links) {
                    req.links?.push({
                        cid: link.cid,
                        name: link.name,
                        size: link.size
                    });
                }
                ;
            }
            ;
            if (this.options.signer) {
                let timestamp = new Date().getTime();
                signature = await this.options.signer.sign({
                    action: 'GET_UPLOAD_URL',
                    timestamp: timestamp,
                    data: req
                }, {
                    action: 'string',
                    timestamp: 'number',
                    data: 'object'
                });
                let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'GET_UPLOAD_URL',
                        signature: signature,
                        data: req
                    })
                });
                return await result.json();
            }
            else {
                let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        data: req
                    })
                });
                return await result.json();
            }
        }
        ;
    }
    exports.FileManagerHttpTransport = FileManagerHttpTransport;
    ;
    class FileNode {
        constructor(owner, name, parent, cidInfo) {
            this._owner = owner;
            this._name = name;
            if (parent) {
                this._parent = parent;
                if (!cidInfo)
                    this._parent.addItem(this);
            }
            ;
            this._items = [];
            this._cidInfo = cidInfo;
            this._isFile = cidInfo?.type == 'file' || false;
            this._isFolder = cidInfo?.type == 'dir' || true;
            if (this._cidInfo?.type == 'dir') {
                this._cidInfo.links?.forEach(link => {
                    this._items.push(new FileNode(this._owner, link.name || '', this, link));
                });
            }
            ;
        }
        ;
        get cid() {
            return this._cidInfo?.cid || '';
        }
        ;
        async checkCid() {
            if (this._cidInfo && this._cidInfo.type == undefined) {
                this._cidInfo = await this._owner.getCidInfo(this._cidInfo.cid);
                if (this._cidInfo?.type == 'dir') {
                    this._isFolder = true;
                    this._isFile = false;
                    this._items = [];
                    if (this._cidInfo.links) {
                        for (let i = 0; i < this._cidInfo.links.length; i++) {
                            let link = this._cidInfo.links[i];
                            if (link?.name) {
                                let node = new FileNode(this._owner, link.name, this, link);
                                this._items.push(node);
                            }
                            ;
                        }
                        ;
                    }
                    ;
                }
                else {
                    this._isFolder = false;
                    this._isFile = true;
                }
            }
            ;
        }
        ;
        get fullPath() {
            let path = this._name;
            let parent = this._parent;
            while (parent) {
                path = parent.name + '/' + path;
                parent = parent.parent;
            }
            ;
            return path;
        }
        ;
        get isModified() {
            return this._isModified;
        }
        ;
        modified(value) {
            if (value === false)
                return this._isModified = false;
            this._isModified = true;
            this._cidInfo = undefined;
            if (this._parent)
                this._parent.modified();
        }
        ;
        get name() {
            return this._name;
        }
        ;
        set name(value) {
            if (this._name != value) {
                this._name = value;
                this.modified();
            }
            ;
        }
        ;
        get parent() {
            return this._parent;
        }
        ;
        set parent(value) {
            if (this._parent != value) {
                if (this._parent) {
                    let idx = this._parent._items.indexOf(this);
                    if (idx >= 0) {
                        this._parent._items.splice(idx, 1);
                        this._parent.modified();
                    }
                    ;
                }
                ;
                this._parent = value;
                this._parent._items.push(this);
                this.modified();
            }
            ;
        }
        ;
        async itemCount() {
            await this.checkCid();
            return this._items.length;
        }
        ;
        async items(index) {
            await this.checkCid();
            let item = this._items[index];
            return item;
        }
        ;
        async addFile(name, file) {
            await this.checkCid();
            return this._owner.addFileTo(this, name, file);
        }
        ;
        async addFileContent(name, content) {
            await this.checkCid();
            if (typeof (content) == 'string')
                content = new TextEncoder().encode(content);
            return this._owner.addFileTo(this, name, content);
        }
        ;
        async addItem(item) {
            if (this._items.indexOf(item) < 0) {
                this._items.push(item);
                this.modified();
            }
            ;
        }
        ;
        removeItem(item) {
            let idx = this._items.indexOf(item);
            if (idx >= 0) {
                this._items.splice(idx, 1);
                this.modified();
            }
            ;
        }
        ;
        async findItem(name) {
            let item = this._items.find(item => item.name == name);
            return item;
        }
        ;
        get cidInfo() {
            return this._cidInfo;
        }
        ;
        async isFile() {
            await this.checkCid();
            return this._isFile;
        }
        ;
        async isFolder() {
            await this.checkCid();
            return this._isFolder;
        }
        ;
        get file() {
            return this._file;
        }
        ;
        set file(value) {
            this._isFile = true;
            this._isFolder = false;
            this._file = value;
            this._fileContent = undefined;
            this.modified();
        }
        ;
        get fileContent() {
            return this._fileContent;
        }
        ;
        set fileContent(value) {
            this._isFile = true;
            this._isFolder = false;
            this._file = undefined;
            this._fileContent = value;
            this.modified();
        }
        ;
        async hash() {
            if (!this._cidInfo) {
                if (this._isFile) {
                    if (this._fileContent)
                        this._cidInfo = await (0, utils_1.hashContent)(this._fileContent);
                    else if (this._file)
                        this._cidInfo = await (0, utils_1.hashFile)(this._file);
                }
                else if (this._isFolder) {
                    let items = [];
                    for (let i = 0; i < this._items.length; i++) {
                        let item = this._items[i];
                        let cidInfo = await item.hash();
                        if (cidInfo) {
                            cidInfo.name = item.name;
                            items.push(cidInfo);
                        }
                    }
                    ;
                    this._cidInfo = await (0, utils_1.hashItems)(items);
                }
                ;
            }
            ;
            return this._cidInfo;
        }
        ;
    }
    exports.FileNode = FileNode;
    ;
    class FileManager {
        constructor(options) {
            this.options = options || {};
            if (this.options?.transport)
                this.transporter = this.options.transport;
            else
                this.transporter = new FileManagerHttpTransport(this.options);
        }
        ;
        async addFileTo(folder, filePath, file) {
            if (filePath.startsWith('/'))
                filePath = filePath.substr(1);
            let paths = filePath.split('/');
            let node = folder;
            for (let path of paths) {
                let item = await folder.findItem(path);
                if (!item)
                    item = new FileNode(this, path, node);
                else
                    await item.checkCid();
                node = item;
            }
            ;
            if (file instanceof Uint8Array) {
                node.fileContent = file;
            }
            else {
                node.file = file;
            }
            ;
            return node;
        }
        ;
        async addFile(filePath, file) {
            if (!filePath.startsWith('/'))
                filePath = '/' + filePath;
            let fileNode = await this.getFileNode(filePath);
            if (fileNode) {
                fileNode.file = file;
                return fileNode;
            }
        }
        ;
        async addFileContent(filePath, content) {
            if (!filePath.startsWith('/'))
                filePath = '/' + filePath;
            let fileNode = await this.getFileNode(filePath);
            if (fileNode) {
                if (typeof (content) == 'string')
                    fileNode.fileContent = new TextEncoder().encode(content);
                else
                    fileNode.fileContent = content;
                return fileNode;
            }
            ;
        }
        ;
        async getCidInfo(cid) {
            return await this.transporter?.getCidInfo(cid);
        }
        ;
        async updateNode(fileNode) {
            if (fileNode.isModified) {
                await fileNode.hash();
                if (await fileNode.isFolder()) {
                    let count = await fileNode.itemCount();
                    for (let i = 0; i < count; i++) {
                        let item = await fileNode.items(i);
                        await this.updateNode(item);
                    }
                    ;
                }
                ;
                await this.transporter.applyUpdate(fileNode);
                fileNode.modified(false);
            }
            ;
        }
        ;
        async applyUpdates() {
            if (this.rootNode) {
                await this.updateNode(this.rootNode);
                return this.rootNode;
            }
            ;
        }
        ;
        delete(fileNode) {
            if (fileNode.parent) {
                fileNode.parent.removeItem(fileNode);
                fileNode.parent.modified(true);
            }
        }
        ;
        async addFolder(folder, name) {
            let node = folder;
            if (name.startsWith('/'))
                name = name.substr(1);
            let paths = name.split('/');
            for (let path of paths) {
                let item = await folder.findItem(path);
                if (!item) {
                    item = new FileNode(this, path, node);
                    item.modified(true);
                    await this.updateNode(item);
                }
                else
                    await item.checkCid();
                node = item;
            }
            ;
            node.modified(true);
            await this.updateNode(node);
            return node;
        }
        async updateFolderName(fileNode, newName) {
            fileNode.name = newName;
            fileNode.modified(true);
            await this.updateNode(fileNode);
        }
        ;
        async getFileNode(path) {
            if (!path.startsWith('/'))
                path = '/' + path;
            let paths = path.split('/');
            let node = await this.getRootNode();
            for (let i = 1; i < paths.length; i++) {
                let path = paths[i];
                if (node) {
                    let item = await node.findItem(path);
                    if (!item) {
                        item = new FileNode(this, path, node);
                        item.modified(true);
                        await this.updateNode(item);
                    }
                    else
                        await item.checkCid();
                    node = item;
                }
                else
                    break;
            }
            ;
            return node;
        }
        ;
        async getRootNode() {
            if (!this.rootNode) {
                if (this.options.rootCid)
                    this.rootNode = await this.setRootCid(this.options.rootCid);
                else {
                    let result = await this.transporter.getRoot();
                    let data = result.data;
                    if (data.cid)
                        this.rootNode = await this.setRootCid(data.cid);
                    else
                        this.rootNode = new FileNode(this, '/', undefined);
                    this.quota = data.quota;
                    this.used = data.used;
                }
                ;
                if (this.rootNode)
                    this.rootNode.isRoot = true;
            }
            ;
            return this.rootNode;
        }
        ;
        reset() {
            this.rootNode = undefined;
        }
        ;
        async setRootCid(cid) {
            this.options.rootCid = cid;
            try {
                let cidInfo = await this.transporter.getCidInfo(cid);
                if (cidInfo) {
                    this.rootNode = new FileNode(this, '/', undefined, cidInfo);
                    this.rootNode.isRoot = true;
                    await this.rootNode.checkCid();
                    return this.rootNode;
                }
                else
                    this.options.rootCid = undefined;
            }
            catch (err) {
                this.options.rootCid = undefined;
            }
        }
        ;
        move(fileNode, newParent) {
            if (fileNode.parent)
                fileNode.parent.removeItem(fileNode);
            fileNode.parent = newParent;
        }
        ;
    }
    exports.FileManager = FileManager;
    ;
});
define("@ijstech/ipfs", ["require", "exports", "@ijstech/ipfs/utils.ts", "@ijstech/ipfs/types.ts", "@ijstech/ipfs/utils.ts", "@ijstech/ipfs/fileManager.ts"], function (require, exports, utils_2, types_3, utils_3, fileManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cidToSri = exports.hashFiles = exports.FileNode = exports.FileManagerHttpTransport = exports.FileManager = exports.parse = exports.hashItems = exports.hashFile = exports.hashContent = exports.cidToHash = exports.CidCode = void 0;
    Object.defineProperty(exports, "CidCode", { enumerable: true, get: function () { return types_3.CidCode; } });
    Object.defineProperty(exports, "cidToHash", { enumerable: true, get: function () { return utils_3.cidToHash; } });
    Object.defineProperty(exports, "hashContent", { enumerable: true, get: function () { return utils_3.hashContent; } });
    Object.defineProperty(exports, "hashFile", { enumerable: true, get: function () { return utils_3.hashFile; } });
    Object.defineProperty(exports, "hashItems", { enumerable: true, get: function () { return utils_3.hashItems; } });
    Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return utils_3.parse; } });
    Object.defineProperty(exports, "FileManager", { enumerable: true, get: function () { return fileManager_1.FileManager; } });
    Object.defineProperty(exports, "FileManagerHttpTransport", { enumerable: true, get: function () { return fileManager_1.FileManagerHttpTransport; } });
    Object.defineProperty(exports, "FileNode", { enumerable: true, get: function () { return fileManager_1.FileNode; } });
    ;
    function convertToTree(items) {
        const root = {
            $idx: {},
            links: []
        };
        for (const item of items) {
            if (item.path && item.cid) {
                const paths = item.path.split('/');
                let node = root;
                for (const path of paths) {
                    if (path) {
                        if (!node.$idx[path]) {
                            let item = {
                                $idx: {},
                                links: [],
                                name: path,
                                type: 'dir'
                            };
                            node.$idx[path] = item;
                            node.links.push(item);
                        }
                        ;
                        node = node.$idx[path];
                    }
                    ;
                }
                ;
                delete node.links;
                delete node.$idx;
                node.type = 'file';
                node.size = item.cid.size;
                node.cid = item.cid.cid;
            }
            ;
        }
        ;
        return root;
    }
    ;
    async function hashTree(tree) {
        delete tree.$idx;
        let items = tree.links;
        if (items) {
            for (const item of items) {
                delete item.$idx;
                if (item.type == 'dir') {
                    await hashTree(item);
                }
                ;
            }
            ;
            let cid = await (0, utils_2.hashItems)(items);
            tree.type = 'dir';
            tree.cid = cid.cid;
            tree.size = cid.size;
        }
        ;
        return tree;
    }
    ;
    async function hashFiles(files, version) {
        if (version == undefined)
            version = 1;
        return new Promise(async (resolve, reject) => {
            try {
                let tree = convertToTree(files);
                let cid = await hashTree(tree);
                resolve(cid);
            }
            catch (err) {
                reject(err);
            }
            ;
        });
    }
    exports.hashFiles = hashFiles;
    ;
    async function cidToSri(cid) {
        return await (0, utils_2.cidToHash)(cid);
    }
    exports.cidToSri = cidToSri;
});
define("@ijstech/moment/moment.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moment = void 0;
    var moment;
    (function (moment) {
    })(moment = exports.moment || (exports.moment = {}));
});
define("@ijstech/moment", ["require", "exports", "@ijstech/base"], function (require, exports, base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moment = void 0;
    let _moment;
    exports.moment = _moment;
    base_1.RequireJS.config({
        paths: {
            '@moment': `${base_1.LibPath}lib/moment/2.29.1/min/moment-with-locales.min.js`,
        }
    });
    base_1.RequireJS.require(['@moment'], (moment) => {
        exports.moment = _moment = moment;
    });
    ;
});
define("@ijstech/application/event-bus.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventBus = void 0;
    class EventBus {
        constructor() {
            this.subscribers = {};
        }
        static getInstance() {
            if (this.instance === undefined) {
                this.instance = new EventBus();
            }
            return this.instance;
        }
        dispatch(event, arg) {
            const subscriber = this.subscribers[event];
            if (subscriber === undefined) {
                return;
            }
            Object.keys(subscriber).forEach((key) => subscriber[key](arg));
        }
        register(sender, event, callback) {
            const id = this.getNextId();
            if (!this.subscribers[event])
                this.subscribers[event] = {};
            this.subscribers[event][id] = callback.bind(sender);
            return {
                unregister: () => {
                    delete this.subscribers[event][id];
                    if (Object.keys(this.subscribers[event]).length === 0)
                        delete this.subscribers[event];
                },
            };
        }
        getNextId() {
            return EventBus.nextId++;
        }
    }
    EventBus.nextId = 0;
    EventBus.instance = undefined;
    exports.EventBus = EventBus;
});
define("@ijstech/application/globalEvent.ts", ["require", "exports", "@ijstech/base"], function (require, exports, base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GlobalEvents = void 0;
    ;
    function getControl(target) {
        if (target instanceof base_1.Control) {
            return target;
        }
        if ((target instanceof HTMLElement || target instanceof SVGElement) && target.parentElement)
            return getControl(target.parentElement);
        return null;
    }
    ;
    class GlobalEvents {
        constructor() {
            this._initialTouchPos = false;
            this._handleMouseDown = this._handleMouseDown.bind(this);
            this._handleMouseMove = this._handleMouseMove.bind(this);
            this._handleMouseUp = this._handleMouseUp.bind(this);
            this.bindEvents();
        }
        abortEvent(event) {
            event.stopPropagation();
        }
        ;
        _handleClick(event) {
            let control = getControl(event.target);
            if (control) { // && !(control instanceof Checkbox)){            
                if (control.enabled) {
                    if (control._handleClick(event)) {
                        // event.preventDefault();
                        event.stopPropagation();
                    }
                    ;
                }
                ;
            }
            ;
        }
        ;
        _handleMouseDown(event) {
            const target = event.target;
            let control = getControl(target);
            if (control?.enabled) {
                this._initialTouchPos = true;
                if (control._handleMouseDown(event)) {
                    // event.preventDefault();
                    event.stopPropagation();
                }
                if (window.PointerEvent) {
                    // target.setPointerCapture((event as PointerEvent).pointerId);
                    document.addEventListener('pointermove', this._handleMouseMove, true);
                    document.addEventListener('pointerup', this._handleMouseUp, true);
                }
                else {
                    document.addEventListener('mousemove', control._handleMouseMove, true);
                    document.addEventListener('mouseup', control._handleMouseUp, true);
                }
            }
        }
        _handleMouseMove(event) {
            let control = getControl(event.target);
            if (control?.enabled) {
                if (!this._initialTouchPos) {
                    return;
                }
                if (control._handleMouseMove(event)) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
        ;
        _handleMouseUp(event) {
            const target = event.target;
            let control = getControl(target);
            if (control?.enabled) {
                if (window.PointerEvent) {
                    // target.releasePointerCapture((event as PointerEvent).pointerId);
                    document.removeEventListener('pointermove', this._handleMouseMove, true);
                    document.removeEventListener('pointerup', this._handleMouseUp, true);
                }
                else {
                    document.removeEventListener('mousemove', control._handleMouseMove, true);
                    document.removeEventListener('mouseup', control._handleMouseUp, true);
                }
                this._initialTouchPos = false;
                if (control._handleMouseUp(event)) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
        ;
        _handleDblClick(event) {
            let control = getControl(event.target);
            if (control) {
                if (control.enabled) {
                    if (control._handleDblClick(event)) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            }
        }
        _handleKeyDown(event) {
            let control = getControl(event.target);
            if (control) {
                if (control.enabled) {
                    if (control._handleKeyDown(event)) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            }
        }
        _handleKeyUp(event) {
            let control = getControl(event.target);
            if (control) {
                if (control.enabled) {
                    if (control._handleKeyUp(event)) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            }
        }
        _handleContextMenu(event) {
            let control = getControl(event.target);
            if (control) {
                // event.preventDefault();
                event.stopPropagation();
                if (control.enabled)
                    control._handleContextMenu(event);
            }
        }
        // private _handleTouchStart(event: TouchEvent){
        // }
        // private _handleTouchEnd(event: TouchEvent){
        // }
        // private _handleTouchMove(event: TouchEvent){
        // }
        _handleChange(event) {
        }
        _handleMouseWheel(event) {
            let control = getControl(event.target);
            if (control) {
                // event.preventDefault();
                event.stopPropagation();
                if (control.enabled && control._handleMouseWheel)
                    control._handleMouseWheel(event);
            }
        }
        _handleFocus(event) {
            let control = getControl(event.target);
            if (control) {
                // event.preventDefault();
                // event.stopPropagation();
                if (control.enabled && control._handleFocus)
                    control._handleFocus(event);
            }
        }
        _handleBlur(event) {
            let control = getControl(event.target);
            if (control) {
                // event.preventDefault();
                // event.stopPropagation();
                if (control.enabled && control._handleBlur)
                    control._handleBlur(event);
            }
        }
        bindEvents() {
            // window.addEventListener('mousedown', this._handleMouseDown.bind(this));
            // window.addEventListener('mousemove', this._handleMouseMove.bind(this));
            // window.addEventListener('mouseup', this._handleMouseUp.bind(this));
            document.addEventListener('click', this._handleClick.bind(this));
            window.addEventListener('dblclick', this._handleDblClick.bind(this));
            window.oncontextmenu = this._handleContextMenu.bind(this);
            window.addEventListener('keydown', this._handleKeyDown);
            window.addEventListener('keyup', this._handleKeyUp);
            // window.addEventListener('touchstart', this._handleTouchStart);
            // window.addEventListener('touchend', this._handleTouchEnd);
            // window.addEventListener('touchmove', this._handleTouchMove);
            window.addEventListener('change', this._handleChange);
            window.addEventListener("wheel", this._handleMouseWheel, { passive: false });
            window.addEventListener('focus', this._handleFocus, true);
            window.addEventListener('blur', this._handleBlur, true);
            document.addEventListener('touchstart', this._handleMouseDown, { passive: false });
            document.addEventListener('touchmove', this._handleMouseMove, { passive: false });
            // document.addEventListener('touchend', this._handleMouseUp, true);
            // document.addEventListener('touchcancel', this._handleMouseUp, true);
            if (window.PointerEvent) {
                document.addEventListener('pointerdown', this._handleMouseDown, true);
            }
            else {
                document.addEventListener('mousedown', this._handleMouseDown, true);
            }
        }
    }
    exports.GlobalEvents = GlobalEvents;
    ;
});
define("@ijstech/application/styles/index.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applicationStyle = void 0;
    const Theme = Styles.Theme.ThemeVars;
    exports.applicationStyle = Styles.style({
        height: '100%',
        $nest: {
            'body': {
                height: '100%'
            }
        }
    });
});
define("@ijstech/application/formatUtils.ts", ["require", "exports", "@ijstech/moment"], function (require, exports, moment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BigDecimal = exports.FormatUtils = void 0;
    class FormatUtils {
        static unixToFormattedDate(unixTimestamp) {
            return moment_1.moment.unix(unixTimestamp).format('YYYY-MM-DD HH:mm:ss');
        }
        static truncateTxHash(hash, length = 20) {
            return hash.substring(0, length) + '...';
        }
        static truncateWalletAddress(address) {
            return address.substring(0, 6) + '...' + address.substring(address.length - 4);
        }
        static formatNumber(value, options) {
            if (!value)
                return '0';
            const { decimalFigures, useSeparators = true, roundingMethod = 'round', minValue, shortScale = false } = options || {};
            let stringValue = (typeof value === 'string') ? value : value.toString();
            stringValue = stringValue.trim();
            if (stringValue === '0')
                return '0';
            if (minValue !== undefined) {
                const compareResult = this.compareToMinValue(stringValue, minValue.toString());
                if (compareResult === -1)
                    return `<${minValue}`;
            }
            const hasExponential = stringValue.includes('e');
            stringValue = hasExponential ? this.removeExponential(stringValue) : stringValue;
            let suffix = '';
            if (shortScale) {
                const { value: newValue, suffix: newSuffix } = this.scaleValue(stringValue);
                if (newValue)
                    stringValue = newValue;
                suffix = newSuffix;
            }
            let [integerPart, decimalPart] = stringValue.split('.');
            const formattedInteger = useSeparators ? integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ",") : integerPart;
            if (decimalFigures === undefined || decimalFigures < 0) {
                return (decimalPart ? `${formattedInteger}.${decimalPart}` : formattedInteger) + suffix;
            }
            let newValue = '';
            if (decimalFigures && decimalFigures > 0) {
                const { newDecimal, newInteger } = this.processDecimalPart(decimalPart, integerPart, options);
                const formattedInteger = useSeparators ? newInteger.replace(/\B(?=(\d{3})+(?!\d))/g, ",") : newInteger;
                newValue = newDecimal ? `${formattedInteger}.${newDecimal}` : formattedInteger;
            }
            else {
                const newInteger = this.roundIntegerPart(decimalPart, integerPart, roundingMethod);
                newValue = useSeparators ? newInteger.replace(/\B(?=(\d{3})+(?!\d))/g, ",") : newInteger;
            }
            return (newValue.length > 18 ? newValue.substring(0, 18) + '...' : newValue) + suffix;
        }
        static scaleValue(value) {
            let [integerPart] = value.split('.');
            const absBigInteger = BigInt(integerPart.replace(/\-|\s+/g, ''));
            const newBigValue = new BigDecimal(value);
            let newValue = '';
            let suffix = '';
            if (absBigInteger >= 1000000000) {
                newValue = newBigValue.divide(new BigDecimal('1000000000')).toString();
                suffix = 'B';
            }
            else if (absBigInteger >= 1000000) {
                newValue = newBigValue.divide(new BigDecimal('1000000')).toString();
                suffix = 'M';
            }
            else if (absBigInteger >= 1000) {
                newValue = newBigValue.divide(new BigDecimal('1000')).toString();
                suffix = 'K';
            }
            return { value: newValue, suffix };
        }
        static removeExponential(value) {
            let [numberPart, ePart] = value.split('e');
            numberPart = numberPart.replace('.', '');
            const powValue = Number(ePart) > 0 ? Number(ePart) : Number(ePart) * -1;
            const eValue = (10 ** powValue).toLocaleString('en-US', { useGrouping: false });
            const rightPart = Math.abs(numberPart.length - eValue.length);
            if (Number(ePart) < 0) {
                return '0.' + '0'.repeat(Math.abs(rightPart) - 1) + numberPart;
            }
            else {
                return numberPart + '0'.repeat(rightPart);
            }
        }
        static compareToMinValue(stringValue, minValue) {
            let [integerPart1, decimalPart1 = ''] = stringValue.split('.');
            let [integerPart2, decimalPart2 = ''] = minValue.split('.');
            const maxDecimals = Math.max(decimalPart1.length, decimalPart2.length);
            const bigValue1 = BigInt(integerPart1 + decimalPart1.padEnd(maxDecimals, '0'));
            const bigValue2 = BigInt(integerPart2 + decimalPart2.padEnd(maxDecimals, '0'));
            if (bigValue1 > bigValue2) {
                return 1;
            }
            else if (bigValue1 < bigValue2) {
                return -1;
            }
            else {
                return 0;
            }
        }
        static processDecimalPart(decimalPart, integerPart, options) {
            const { decimalFigures = 0, roundingMethod = 'round', hasTrailingZero = true } = options || {};
            let roundingValue = { newDecimal: decimalPart, newInteger: integerPart };
            if (decimalPart) {
                // let count = 0;
                // let endIndex = 0;
                // for (let i = 0; i < decimalPart.length; i++) {
                //     if (count >= decimalFigures) break;
                //     if (decimalPart[i] !== '0') count++;
                //     endIndex = i;
                // }
                const initialDecimalPart = decimalPart.slice(0, decimalFigures).replace(/0+$/g, '');
                switch (roundingMethod) {
                    case 'round':
                        roundingValue = this.customRound(decimalPart, integerPart, decimalFigures, 5, hasTrailingZero);
                        break;
                    case 'ceil':
                        if (integerPart.startsWith('-')) {
                            roundingValue.newDecimal = initialDecimalPart;
                        }
                        else {
                            roundingValue = this.customRound(decimalPart, integerPart, decimalFigures, 1, hasTrailingZero);
                        }
                        break;
                    default:
                        roundingValue.newDecimal = initialDecimalPart;
                }
            }
            else if (hasTrailingZero) {
                roundingValue.newDecimal = '0'.repeat(decimalFigures);
            }
            return { ...roundingValue };
        }
        static customRound(decimalPart, integerPart, decimalFigures, roundingNumber, hasTrailingZero) {
            const decimalArr = decimalPart.split('');
            let lastIndex = decimalArr.length - 1;
            let newInteger = integerPart;
            for (let i = decimalArr.length - 1; i >= 0; i--) {
                if (i < decimalFigures) {
                    if (decimalArr[i] === '10' && i === 0) {
                        newInteger = this.incrementLastDigit(integerPart);
                        lastIndex = -1;
                        break;
                    }
                    else if (decimalArr[i] !== '10') {
                        lastIndex = i + 1;
                        break;
                    }
                }
                if (+decimalArr[i] >= roundingNumber && i - 1 >= 0) {
                    decimalArr[i] = '0';
                    decimalArr[i - 1] = `${+decimalArr[i - 1] + 1}`;
                }
            }
            const newDecimal = lastIndex >= 0 ? decimalArr.slice(0, lastIndex).join('') : '';
            let roundingValue;
            if (hasTrailingZero && newDecimal.length < decimalFigures) {
                roundingValue = newDecimal + '0'.repeat(decimalFigures - newDecimal.length);
            }
            else {
                roundingValue = newDecimal.replace(/0+$/g, '');
            }
            return { newDecimal: roundingValue, newInteger };
        }
        static roundIntegerPart(decimalPart, integerPart, roundingMethod) {
            const firstDecimal = decimalPart && decimalPart.charAt(0);
            const notRounding = (integerPart.startsWith('-') && roundingMethod === 'ceil') ||
                roundingMethod === 'floor' ||
                !firstDecimal ||
                (roundingMethod === 'round' && +firstDecimal < 5) ||
                (roundingMethod === 'ceil' && +firstDecimal < 1);
            return notRounding ? integerPart : this.incrementLastDigit(integerPart);
        }
        static incrementLastDigit(integerPart) {
            let chars = integerPart.split('') || [];
            let isNegative = chars[0] === '-';
            isNegative && chars.shift();
            if (chars[chars.length - 1] === '9') {
                for (let i = chars.length - 1; i > 0; i--) {
                    const num = +chars[i];
                    if (num >= 9 && i - 1 > 0) {
                        chars[i] = '0';
                        chars[i - 1] = `${+chars[i - 1] + 1}`;
                    }
                }
            }
            else {
                chars[chars.length - 1] = `${(+chars[chars.length - 1]) + 1}`;
            }
            if (isNegative)
                chars.unshift('-');
            return chars.join('');
        }
    }
    exports.FormatUtils = FormatUtils;
    class BigDecimal {
        constructor(value) {
            let [integerPart, decimalPart = ''] = value.split('.');
            decimalPart = decimalPart.padEnd(BigDecimal.decimals, '0');
            this.bigVal = BigInt(integerPart + decimalPart);
        }
        static fromBigInt(bigVal) {
            return Object.assign(Object.create(BigDecimal.prototype), { bigVal });
        }
        toString() {
            const str = this.bigVal.toString().padStart(BigDecimal.decimals + 1, '0');
            return str.slice(0, -BigDecimal.decimals) + '.' + str.slice(-BigDecimal.decimals).replace(/\.?0+$/, "");
        }
        divide(value) {
            if (!value)
                throw new Error('Cannot divide to empty value');
            return BigDecimal.fromBigInt((this.bigVal * BigInt('1' + '0'.repeat(BigDecimal.decimals)) / value.bigVal));
        }
    }
    BigDecimal.decimals = 18;
    exports.BigDecimal = BigDecimal;
});
define("@ijstech/application", ["require", "exports", "@ijstech/base", "@ijstech/application/event-bus.ts", "@ijstech/application/globalEvent.ts", "@ijstech/application/styles/index.css.ts", "@ijstech/ipfs", "@ijstech/application/event-bus.ts", "@ijstech/application/formatUtils.ts"], function (require, exports, base_2, event_bus_1, globalEvent_1, index_css_1, ipfs_1, event_bus_2, formatUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FormatUtils = exports.EventBus = exports.application = exports.Application = exports.IpfsDataType = void 0;
    const API_IPFS_BASEURL = '/api/ipfs/v0';
    const dynamicImport = new Function('specifier', 'return import(specifier)');
    ;
    ;
    var IpfsDataType;
    (function (IpfsDataType) {
        IpfsDataType[IpfsDataType["Raw"] = 0] = "Raw";
        IpfsDataType[IpfsDataType["Directory"] = 1] = "Directory";
        IpfsDataType[IpfsDataType["File"] = 2] = "File";
        IpfsDataType[IpfsDataType["Metadata"] = 3] = "Metadata";
        IpfsDataType[IpfsDataType["Symlink"] = 4] = "Symlink";
        IpfsDataType[IpfsDataType["HAMTShard"] = 5] = "HAMTShard";
    })(IpfsDataType = exports.IpfsDataType || (exports.IpfsDataType = {}));
    ;
    ;
    ;
    function topologicalSort(edges) {
        let nodes = {}, sorted = [], visited = {};
        class TSortNode {
            constructor(id) {
                this.id = id;
                this.afters = [];
            }
        }
        ;
        edges.forEach((v) => {
            let from = v[0], to = v[1];
            if (!nodes[from])
                nodes[from] = new TSortNode(from);
            if (!nodes[to])
                nodes[to] = new TSortNode(to);
            nodes[from].afters.push(to);
        });
        Object.keys(nodes).forEach(function visit(idstr, ancestors) {
            let node = nodes[idstr], id = node.id;
            if (visited[idstr])
                return;
            if (!Array.isArray(ancestors))
                ancestors = [];
            ancestors.push(id);
            visited[idstr] = true;
            node.afters.forEach(function (afterID) {
                if (ancestors.indexOf(afterID) >= 0)
                    throw new Error('closed chain : ' + afterID + ' is in ' + id);
                visit(afterID.toString(), ancestors.map(function (v) { return v; }));
            });
            sorted.unshift(id);
        });
        return sorted;
    }
    ;
    class Application {
        static updateLocale() {
            for (let key in this._modules) {
                this._modules[key].updateLocale();
            }
            ;
        }
        ;
        static registerModule(uuid, module) {
            this._modules[uuid] = module;
        }
        ;
        static unregisterModule(uuid) {
            delete this._modules[uuid];
        }
        ;
        constructor() {
            this.modules = {};
            this.modulesId = {};
            this.scripts = {};
            this.loadedScripts = {};
            this.id = 0;
            this.LibHost = '';
            this.packageNames = new Set();
            this.packages = {};
            this.packageDependencies = {};
            // private _uploadModal: UploadModal;
            this.cidItems = {};
            this.bundleLibs = {};
            this.store = {};
            this.rootDir = '';
            this.assetsDir = '';
            this.dev = null;
            this._locale = 'en';
            this.globalEvents = new globalEvent_1.GlobalEvents();
        }
        get EventBus() {
            return event_bus_1.EventBus.getInstance();
        }
        static get Instance() {
            return this._instance || (this._instance = new this());
        }
        ;
        assets(name) {
            if (this._assets) {
                let items = name.split('/');
                let value = this._assets;
                let item = items.shift();
                while (value && item) {
                    value = value[item];
                    item = items.shift();
                }
                ;
                return value;
            }
            ;
        }
        ;
        resolvePackageSCConfigPath(packageName) {
            let options = this._initOptions;
            let rootDir = (options?.rootDir ? options?.rootDir : "");
            if (!rootDir.endsWith('/'))
                rootDir = rootDir + '/';
            let libDir = (options?.libDir ? options?.libDir + "/" : "libs/");
            let path = rootDir + libDir + packageName + '/scconfig.json';
            return path;
        }
        async calculatePackageModuleDir(packageName, modulePath) {
            let packageModulePath = await this.resolvePackageModulePath(packageName, modulePath || '*') || '';
            let currentModuleDir;
            if (packageModulePath.indexOf('://') > 0)
                currentModuleDir = packageModulePath.split('/').slice(0, -1).join('/');
            else if (!packageModulePath.startsWith('/'))
                currentModuleDir = this.LibHost + this.rootDir + packageModulePath.split('/').slice(0, -1).join('/');
            else
                currentModuleDir = this.LibHost + packageModulePath.split('/').slice(0, -1).join('/');
            return currentModuleDir;
        }
        async createElement(name, lazyLoad, attributes, modulePath) {
            name = name.split('/').pop() || name;
            let elementName = `i-${name}`;
            let result;
            let packageName = `@scom/${name}`;
            try {
                if (window.customElements.get(elementName)) {
                    let currentModuleDir = await this.calculatePackageModuleDir(packageName, modulePath || '*');
                    result = document.createElement(elementName);
                    result.currentModuleDir = currentModuleDir;
                    ;
                }
                else {
                    let scconfigPath = this.resolvePackageSCConfigPath(packageName);
                    if (scconfigPath) {
                        let scconfigResponse = await fetch(scconfigPath);
                        if (scconfigResponse.status == 200) {
                            let scconfig = await scconfigResponse.json();
                            if (scconfig) {
                                let promisesMap = {};
                                let packageModulePathMap = {};
                                for (let dependency of scconfig.dependencies) {
                                    if (dependency === '@ijstech/components' || this.packageNames.has(dependency))
                                        continue;
                                    let packageModulePath = await this.resolvePackageModulePath(dependency, modulePath || '*');
                                    if (!packageModulePath || this.packages[packageModulePath])
                                        continue;
                                    try {
                                        let m = window['require'](dependency);
                                        if (m) {
                                            if (!this.packageNames.has(dependency))
                                                this.packageNames.add(dependency);
                                            this.packages[packageModulePath] = m.default || m;
                                            continue;
                                        }
                                        ;
                                    }
                                    catch (err) {
                                    }
                                    ;
                                    packageModulePathMap[dependency] = packageModulePath;
                                    promisesMap[dependency] = this.getScript(packageModulePath);
                                }
                                ;
                                let dependenciesArr = Object.keys(promisesMap);
                                let scripts = await Promise.all(Object.values(promisesMap));
                                for (let i = 0; i < dependenciesArr.length; i++) {
                                    let dependency = dependenciesArr[i];
                                    let packageModulePath = packageModulePathMap[dependency];
                                    let script = scripts[i];
                                    if (script) {
                                        await this.dynamicImportPackage(script, dependency, packageModulePath);
                                    }
                                    ;
                                }
                            }
                        }
                        ;
                    }
                    ;
                    let loaded = await this.loadPackage(packageName, modulePath || '*');
                    if (loaded) {
                        let currentModuleDir = await this.calculatePackageModuleDir(packageName, modulePath || '*');
                        result = document.createElement(elementName);
                        result.currentModuleDir = currentModuleDir;
                    }
                }
                ;
                if (result) {
                    if (lazyLoad)
                        result.setAttribute('lazyLoad', 'true');
                    for (let name in attributes) {
                        result.setAttribute(name, attributes[name]);
                    }
                    ;
                }
                ;
            }
            catch (err) {
                console.dir(err);
            }
            ;
            return result;
        }
        ;
        fetch(input, init) {
            if (typeof (input) == 'string') {
                let url = input;
                if (url.indexOf('://') < 0 && !url.startsWith('/'))
                    input = `${this.rootDir}${url}`;
            }
            else if (input instanceof Request) {
                let req = input;
                if (req.url.indexOf('://') < 0 && !req.url.startsWith('/')) {
                    input = new Request(`${this.rootDir}${req.url}`);
                }
                ;
            }
            ;
            return fetch(input, init);
        }
        ;
        async postData(endpoint, data) {
            data = data || {};
            const response = await fetch(endpoint, {
                method: 'POST',
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'same-origin',
                headers: {
                    'Content-Type': 'application/json',
                },
                referrerPolicy: 'no-referrer',
                body: JSON.stringify(data)
            });
            return response.json();
        }
        ;
        // async showUploadModal(): Promise<void>{
        //     if (!this._uploadModal)
        //         this._uploadModal = new UploadModal();
        //     this._uploadModal.show();
        // };
        async getUploadUrl(item) {
            let { data } = await this.postData(`${API_IPFS_BASEURL}/upload`, { data: item });
            return data || {};
        }
        ;
        get i18n() {
            if (!this._i18n)
                this._i18n = new base_2.I18n();
            return this._i18n;
        }
        ;
        get locale() {
            return this._locale;
        }
        ;
        set locale(value) {
            if (this._locale != value) {
                this._locale = value;
                Application.updateLocale();
            }
            ;
        }
        ;
        get permissions() {
            if (!this._permissions)
                this._permissions = new base_2.Permissions();
            return this._permissions;
        }
        ;
        async uploadData(fileName, content) {
            let cid = await (0, ipfs_1.hashContent)(content);
            let item = {
                cid: cid.cid,
                name: fileName,
                size: cid.size,
                type: 'file'
            };
            let dir = await (0, ipfs_1.hashItems)([item]);
            let data = await this.getUploadUrl(dir);
            if (data?.[dir.cid] && data?.[cid.cid]) {
                let dirStatus = await this.upload(data[dir.cid], JSON.stringify(dir));
                let fileStatus = await this.upload(data[cid.cid], content);
                if (dirStatus == 200 && fileStatus == 200)
                    return { success: true, data: dir }; //result url: https://<ipfs-gateway>/ipfs/${result.data.cid/${result.data.links[0].name}}
                else
                    return { success: false, error: `Failed to upload file. Status code: ${fileStatus}` };
            }
            else
                return { success: false };
        }
        ;
        // async uploadFile(extensions?: string | string[]): Promise<IUploadResult> {
        //     return new Promise(async (resolve, reject) => {
        //         const input = document.createElement("input");
        //         input.type = "file";
        //         if (extensions){
        //             const accept = Array.isArray(extensions) ? extensions.map((ext) => `.${ext}`).join(",") : `.${extensions}`;
        //             input.accept = accept;
        //         };
        //         input.addEventListener("change", async () => {
        //             const file: UploadRawFile = <UploadRawFile>input.files?.[0];
        //             if (file) {
        //                 file.path = `/${file.name}`;                
        //                 file.cid = await hashFile(file);
        //                 let dir = await hashFiles([file]);
        //                 let {data} = await this.postData(`${API_IPFS_BASEURL}/upload`, {data: dir});
        //                 if (data?.[file.cid.cid]){
        //                     let result = await this.upload(data[file.cid.cid], file);
        //                 };
        //                 if (data?.[dir.cid]){
        //                     let result = await this.upload(data[dir.cid], JSON.stringify(dir));
        //                 };
        //                 resolve({
        //                     success: true,
        //                     data: dir
        //                 })
        //                 //result url: https://<ipfs-gateway>/ipfs/${result.data.cid/${result.data.links[0].name}}
        //             } 
        //             else {
        //                 reject({success: false, error: "No file selected"});
        //             }   
        //         });
        //         input.click();
        //     });
        // };
        async uploadTo(targetCid, items) {
            let cid = await (await fetch(`${API_IPFS_BASEURL}/stat/${targetCid}`)).json();
            if (cid?.links) {
                for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    let exists = false;
                    for (let k = 0; k < cid.links.length; k++) {
                        if (cid.links[k].name == item.cid.name) {
                            cid.links[k] = item.cid;
                            exists = true;
                            break;
                        }
                        ;
                    }
                    ;
                    if (!exists)
                        cid.links.push(item.cid);
                }
                ;
                let newCid = await (0, ipfs_1.hashItems)(cid.links);
                let uploadUrl = await this.getUploadUrl(newCid);
                for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    if (uploadUrl[item.cid.cid]) {
                        let data;
                        if (item.cid.type == 'dir')
                            data = item.data || JSON.stringify(item.cid);
                        else
                            data = item.data;
                        if (!data)
                            throw new Error(`Missing upload data: ${item.cid.name}`);
                        let result = await this.upload(uploadUrl[item.cid.cid], data);
                        if (result != 200)
                            throw new Error(`File upload failed: ${item.cid.name}`);
                    }
                    ;
                }
                ;
                if (uploadUrl[newCid.cid]) {
                    let result = await this.upload(uploadUrl[newCid.cid], JSON.stringify(newCid));
                    if (result != 200)
                        throw new Error(`File upload failed: ${newCid.cid}`);
                }
                ;
                return {
                    success: true,
                    data: newCid
                };
            }
            ;
            throw new Error(`Target CID not found: ${targetCid}`);
        }
        ;
        async upload(url, data) {
            return new Promise(async (resolve) => {
                if (typeof (data) == 'string') {
                    let result = await fetch(url, {
                        method: 'PUT',
                        body: data
                    });
                    resolve(result.status);
                }
                else {
                    const reader = new FileReader();
                    reader.onload = async () => {
                        let result = await fetch(url, {
                            method: 'PUT',
                            body: reader.result
                        });
                        resolve(result.status);
                    };
                    reader.onerror = () => {
                        resolve(0);
                    };
                    reader.readAsArrayBuffer(data);
                }
                ;
            });
        }
        ;
        async getCidItem(host, cid, paths) {
            if (paths.length > 0) {
                let cidItem = this.cidItems[cid];
                if (!cidItem) {
                    try {
                        let data = localStorage.getItem(cid);
                        if (data)
                            cidItem = JSON.parse(data);
                    }
                    catch (err) { }
                    ;
                    if (!cidItem)
                        cidItem = await (await fetch(`${host}/${cid}`)).json();
                    let id = await (0, ipfs_1.hashItems)(cidItem.links);
                    if (id.cid != cid)
                        throw new Error('CID not match');
                    try {
                        localStorage.setItem(cid, JSON.stringify(cidItem));
                    }
                    catch (err) { }
                    this.cidItems[cid] = cidItem;
                }
                ;
                if (cidItem && cidItem.links) {
                    let path = paths.shift();
                    for (let i = 0; i < cidItem.links.length; i++) {
                        if (cidItem.links[i].name == path) {
                            if (cidItem.links[i].type == 'dir')
                                return await this.getCidItem(host, cidItem.links[i].cid, paths);
                            else {
                                return cidItem.links[i];
                            }
                            ;
                        }
                        ;
                    }
                    ;
                }
                ;
            }
            ;
            return;
        }
        ;
        async verifyScript(modulePath, script) {
            if (this._initOptions?.ipfs && typeof (this._initOptions?.ipfs) == 'string') {
                try {
                    let paths = modulePath.split("/");
                    let cid = await this.getCidItem('/ipfs', this._initOptions.ipfs, paths);
                    if (!cid)
                        return false;
                    let scriptCid = await (0, ipfs_1.hashContent)(script);
                    return cid.cid == scriptCid.cid;
                }
                catch (err) {
                    return false;
                }
            }
            ;
            return true;
        }
        ;
        async getScript(modulePath) {
            if (this.scripts[modulePath])
                return this.scripts[modulePath];
            try {
                let result = await (await this.fetch(modulePath)).text();
                if (typeof (result) == 'string') {
                    if (await this.verifyScript(modulePath, result)) {
                        this.scripts[modulePath] = result;
                        return result;
                    }
                    ;
                }
                ;
            }
            catch (err) { }
            ;
            return '';
        }
        ;
        async loadScript(modulePath, script, forcedSave = false) {
            try {
                if (this.scripts[modulePath])
                    return true;
                if (!script)
                    script = await this.getContent(modulePath);
                if (script && (forcedSave || await this.verifyScript(modulePath, script))) {
                    this.scripts[modulePath] = script;
                    await dynamicImport(`data:text/javascript,${encodeURIComponent(script)}`);
                    return true;
                }
                ;
            }
            catch (err) { }
            ;
            return false;
        }
        ;
        async loadScriptWithIntegrity(modulePath, integrity = '', crossorigin = 'anonymous') {
            return new Promise(async (resolve, reject) => {
                try {
                    if (this.loadedScripts[modulePath])
                        return true;
                    let checkedIntegrity = integrity;
                    if (!checkedIntegrity && this._initOptions?.ipfs && typeof (this._initOptions?.ipfs) == 'string') {
                        try {
                            const paths = modulePath.split("/");
                            const cid = await this.getCidItem('/ipfs', this._initOptions.ipfs, paths);
                            if (cid)
                                checkedIntegrity = (0, ipfs_1.cidToHash)(cid?.cid);
                        }
                        catch (err) {
                        }
                    }
                    ;
                    const script = document.createElement('script');
                    script.src = modulePath;
                    if (checkedIntegrity)
                        script.integrity = checkedIntegrity;
                    script.crossOrigin = crossorigin;
                    script.async = true;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                    this.loadedScripts[modulePath] = true;
                }
                catch (err) {
                    reject(err);
                }
            });
        }
        async getContent(modulePath) {
            try {
                return await (await this.fetch(modulePath)).text();
            }
            catch (err) { }
            return '';
        }
        ;
        async getJSONContent(modulePath) {
            try {
                return await (await this.fetch(modulePath)).json();
            }
            catch (err) { }
            return;
        }
        ;
        async fetchDirectoryInfoByCID(ipfsCid) {
            try {
                const IPFS_API = `https://ipfs.scom.dev/ipfs/${ipfsCid}`;
                let result = await fetch(IPFS_API);
                let jsonContent = await result.json();
                if (jsonContent.links)
                    return jsonContent.links;
                return [];
            }
            catch (err) {
                console.log(err);
            }
            ;
            return [];
        }
        ;
        // async getModule(modulePath: string, options?: IModuleOptions): Promise<Module|null>{
        //     if (this.modules[modulePath])
        //         return this.modules[modulePath];
        //     let result = await this.newModule(modulePath, options);
        //     if (result)
        //         this.modules[modulePath] = result;
        //     return result;
        // };
        async resolvePackageDependencies(packageName, result) {
            result = result || [];
            let deps = this.packageDependencies[packageName];
            if (deps) {
                for (let i = 0; i < deps.length; i++) {
                    let p = deps[i];
                    if (!result.includes(p)) {
                        result.push(p);
                    }
                    ;
                }
                ;
            }
            else {
                let scConfigPath = this.resolvePackageSCConfigPath(packageName);
                let scconfig = await this.getJSONContent(scConfigPath);
                if (scconfig?.dependencies) {
                    this.packageDependencies[packageName] = scconfig?.dependencies;
                    for (let i = 0; i < scconfig.dependencies.length; i++) {
                        let p = scconfig.dependencies[i];
                        await this.resolvePackageDependencies(p, result);
                        if (!result.includes(p))
                            result.push(p);
                    }
                    ;
                }
                else
                    this.packageDependencies[packageName] = [];
            }
            ;
            return result;
        }
        ;
        async resolvePackageModulePath(packageName, modulePath) {
            let options = this._initOptions;
            if (options && options.modules && options.modules[packageName]) {
                let pack = options.modules[packageName];
                for (let i = 0; i < pack.dependencies?.length; i++) {
                    let n = pack.dependencies[i];
                    if (!base_2.RequireJS.defined(n))
                        await this.loadPackage(n);
                }
                ;
            }
            ;
            let rootDir = (options?.rootDir ? options?.rootDir : "");
            if (!rootDir.endsWith('/'))
                rootDir = rootDir + '/';
            let moduleDir = (options?.moduleDir ? options?.moduleDir + "/" : "modules/");
            let libDir = (options?.libDir ? options?.libDir + "/" : "libs/");
            if (!modulePath || modulePath == '*') {
                if (options?.modules?.[packageName])
                    modulePath = rootDir + moduleDir + options?.modules?.[packageName].path + '/index.js';
                else
                    modulePath = rootDir + libDir + packageName + '/index.js';
            }
            else if (modulePath.startsWith('{LIB}/')) {
                let libPath = base_2.LibPath || '';
                if (base_2.LibPath && !base_2.LibPath.endsWith('/'))
                    libPath = libPath + '/';
                modulePath = modulePath.replace('{LIB}/', libPath);
            }
            return modulePath;
        }
        ;
        async loadPackage(packageName, modulePath) {
            let packageModulePath = await this.resolvePackageModulePath(packageName, modulePath);
            if (!packageModulePath)
                return null;
            if (this.packages[packageModulePath])
                return this.packages[packageModulePath];
            let deps = await this.resolvePackageDependencies(packageName);
            for (let i = 0; i < deps.length; i++) {
                let p = deps[i];
                if (!base_2.RequireJS.defined(p) && !this.packageNames.has(p)) {
                    await this.loadPackage(p);
                }
            }
            ;
            try {
                let m = window['require'](packageName);
                if (m) {
                    if (!this.packageNames.has(packageName))
                        this.packageNames.add(packageName);
                    this.packages[packageModulePath] = m.default || m;
                    return m.default || m;
                }
                ;
            }
            catch (err) { }
            ;
            let script = await this.getScript(packageModulePath);
            if (script) {
                const importedPackage = await this.dynamicImportPackage(script, packageName, packageModulePath);
                return importedPackage;
            }
            ;
            return null;
        }
        ;
        async loadPackages(packages) {
            let paths = [];
            let packs = [];
            let pathIdx = {};
            let script = '';
            for (let i = 0; i < packages.length; i++) {
                let pack = packages[i];
                let m;
                try {
                    m = window['require'](pack);
                }
                catch (err) { }
                ;
                let path = this.getModulePath(pack);
                if (m) {
                    this.packages[path] = m.default || m;
                }
                else {
                    if (!this.packages[path]) {
                        packs.push(pack);
                        pathIdx[pack] = path;
                        paths.push(path);
                    }
                    ;
                }
            }
            ;
            if (packs.length > 0) {
                let edges = [];
                if (this._initOptions && this._initOptions.modules) {
                    for (let idx = packs.length - 1; idx >= 0; idx--) {
                        let pack = packs[idx];
                        let module = this._initOptions.modules[pack];
                        if (module && module.dependencies) {
                            for (let i = 0; i < module.dependencies.length; i++) {
                                let dependency = module.dependencies[i];
                                let depIdx = packs.indexOf(dependency);
                                if (depIdx > -1) {
                                    edges.push([dependency, pack]);
                                }
                                ;
                            }
                            ;
                        }
                        ;
                    }
                    ;
                    let sorted = topologicalSort(edges);
                    for (let i = 0; i < packs.length; i++) {
                        if (sorted.indexOf(packs[i]) < 0)
                            sorted.push(packs[i]);
                    }
                    ;
                    packs = sorted;
                    paths = packs.map((p) => pathIdx[p]);
                }
                ;
                let result = await Promise.all(paths.map(u => fetch(u)));
                for (let i = 0; i < paths.length; i++) {
                    let pack = packs[i];
                    let path = paths[i];
                    path = path.split('/').slice(0, -1).join('/');
                    if (this._initOptions && this._initOptions.modules && this._initOptions.modules[pack])
                        script += `application.currentModuleDir=application.rootDir+'modules/${this._initOptions.modules[pack].path}';\n`;
                    else
                        script += `application.currentModuleDir=application.rootDir+'libs/${pack}';\n`;
                    script += (await result[i].text()) + '\n';
                }
                ;
                await dynamicImport(`data:text/javascript,${encodeURIComponent(script)}`);
                for (let i = 0; i < paths.length; i++) {
                    let pack = packs[i];
                    let path = paths[i];
                    let m = window['require'](pack);
                    if (m) {
                        if (!this.packageNames.has(pack))
                            this.packageNames.add(pack);
                        this.packages[path] = m.default || m;
                    }
                    ;
                }
                ;
            }
            ;
        }
        ;
        async dynamicImportPackage(script, packageName, packageModulePath) {
            _currentDefineModule = null;
            this.currentModulePath = packageModulePath;
            if (packageModulePath.indexOf('://') > 0)
                this.currentModuleDir = packageModulePath.split('/').slice(0, -1).join('/');
            else if (!packageModulePath.startsWith('/'))
                this.currentModuleDir = this.LibHost + this.rootDir + packageModulePath.split('/').slice(0, -1).join('/');
            else
                this.currentModuleDir = this.LibHost + packageModulePath.split('/').slice(0, -1).join('/');
            if (!this.packageNames.has(packageName)) {
                await dynamicImport(`data:text/javascript,${encodeURIComponent(script)}`);
                this.packageNames.add(packageName);
            }
            this.currentModulePath = '';
            this.currentModuleDir = '';
            let m = window['require'](packageName);
            if (m) {
                this.packages[packageModulePath] = m.default || m;
                return m.default || m;
            }
            return null;
        }
        async loadModule(modulePath, options) {
            let module = await this.newModule(modulePath, options);
            if (module)
                document.body.append(module);
            return module;
        }
        ;
        getModulePath(module) {
            let options = this._initOptions;
            let modulePath = module;
            if (options && options.modules && options.modules[module] && options.modules[module].path) {
                modulePath = '';
                if (options.rootDir) {
                    modulePath += options.rootDir;
                    if (!modulePath.endsWith('/'))
                        modulePath += '/';
                }
                ;
                if (options.moduleDir) {
                    modulePath += options.moduleDir;
                    if (!modulePath.endsWith('/'))
                        modulePath += '/';
                }
                ;
                modulePath += options.modules[module].path;
                if (!modulePath.endsWith('.js'))
                    modulePath += '/index.js';
            }
            else if (options && options.dependencies && options.dependencies[module]) {
                let libDir = '';
                if (options?.libDir) {
                    libDir = options.libDir;
                    if (!libDir.endsWith('/'))
                        libDir += '/';
                    if (libDir.startsWith('/'))
                        libDir = libDir.substring(1);
                }
                else
                    libDir = 'libs/';
                modulePath = `${options?.rootDir ? options.rootDir : ""}`;
                if (modulePath && !modulePath.endsWith('/'))
                    modulePath += '/';
                modulePath += libDir + module + '/index.js';
            }
            ;
            return modulePath;
        }
        async initModule(modulePath, script) {
            if (this.modulesId[modulePath])
                return this.modulesId[modulePath];
            _currentDefineModule = null;
            this.currentModulePath = modulePath;
            if (modulePath.indexOf('://') > 0)
                this.currentModuleDir = modulePath.split('/').slice(0, -1).join('/');
            else if (!modulePath.startsWith('/'))
                this.currentModuleDir = this.LibHost + this.rootDir + modulePath.split('/').slice(0, -1).join('/');
            else
                this.currentModuleDir = this.LibHost + modulePath.split('/').slice(0, -1).join('/');
            await dynamicImport(`data:text/javascript,${encodeURIComponent(script)}`);
            document.getElementsByTagName('html')[0].classList.add(index_css_1.applicationStyle);
            this.currentModulePath = '';
            this.currentModuleDir = '';
            if (!_currentDefineModule && this.packages[modulePath]) {
                _currentDefineModule = this.packages[modulePath];
            }
            ;
            if (_currentDefineModule) {
                let module = _currentDefineModule.default || _currentDefineModule;
                if (module) {
                    this.id++;
                    let elmId = `i-module--${this.id}`;
                    let Module;
                    if (Object.keys(module).length === 1) {
                        Module = class extends module[Object.keys(module)[0]] {
                        };
                    }
                    else
                        Module = class extends module {
                        };
                    this.modulesId[modulePath] = elmId;
                    this.modules[modulePath] = Module;
                    customElements.define(elmId, Module);
                    return elmId;
                }
                ;
            }
            ;
            return null;
        }
        ;
        async init(scconfigPath, customData) {
            let scconfig = await this.getJSONContent(scconfigPath);
            if (!scconfig)
                return null;
            if (!scconfig.rootDir) {
                if (scconfigPath.indexOf('/') >= 0) {
                    let rootDir = scconfigPath.split('/').slice(0, -1).join('/');
                    let a = document.createElement('a');
                    a.href = rootDir;
                    rootDir = a.href.replace(/^[a-zA-Z]{3,5}:\/{2}[a-zA-Z0-9_.:-]+/, '');
                    if (!rootDir.startsWith('/'))
                        rootDir = '/' + rootDir;
                    if (!rootDir.endsWith('/'))
                        rootDir = rootDir + '/';
                    this.rootDir = rootDir;
                    scconfig.rootDir = rootDir;
                }
                else {
                    let rootDir = window.location.pathname;
                    if (rootDir.endsWith('.html') || rootDir.endsWith('.htm'))
                        rootDir = rootDir.substring(0, rootDir.lastIndexOf("/"));
                    if (!rootDir.endsWith('/'))
                        rootDir = rootDir + '/';
                    this.rootDir = rootDir;
                    scconfig.rootDir = rootDir;
                }
                ;
            }
            else {
                let rootDir = scconfig.rootDir;
                if (!rootDir.startsWith('/'))
                    rootDir = '/' + rootDir;
                if (!rootDir.endsWith('/'))
                    rootDir = rootDir + '/';
                this.rootDir = rootDir;
                scconfig.rootDir = rootDir;
            }
            ;
            if (customData)
                scconfig.customData = customData;
            return this.newModule(scconfig.main, scconfig);
        }
        ;
        async newModule(module, options) {
            if (options) {
                if (options.main) { // Root module
                    this._initOptions = options;
                    // if (options.bundle){
                    //     try{
                    //         let rootDir = (options?.rootDir ? options?.rootDir : "");
                    //         if (!rootDir.endsWith('/'))
                    //             rootDir += '/';
                    //         let content = await this.getScript(rootDir + 'bundle.json');
                    //         if (content){ 
                    //             this.bundleLibs = JSON.parse(content);
                    //         };
                    //     }
                    //     catch(err){
                    //         this.bundleLibs = {};
                    //     };
                    // };
                }
                ;
                if (!this._assets && options.assets)
                    this._assets = await this.loadPackage(options.assets) || {};
                if (options.dependencies) {
                    let packages = [];
                    for (let p in options.dependencies) {
                        if (p != options.main) {
                            packages.push(p);
                        }
                        ;
                    }
                    ;
                    await this.loadPackages(packages);
                    // for (let p in options.dependencies){
                    //     if (p != options.main){
                    //         let path = await this.resolvePackageModulePath(p, options.dependencies[p]);
                    //         if (path && !this.packages[path]){
                    //             await this.loadPackage(p, options.dependencies[p]);
                    //         };
                    //     };
                    // };
                }
                ;
            }
            ;
            if (this._initOptions?.geo?.enabled && !this.geoInfo) {
                const apiUrl = this._initOptions.geo.apiUrl || '/api/geo/v0';
                const geoResponse = await fetch(apiUrl);
                const geo = await geoResponse.json();
                this.geoInfo = geo;
            }
            ;
            let modulePath = module;
            if (this._initOptions) {
                if (modulePath != this._initOptions.main && this._initOptions.geo?.enabled) {
                    try {
                        if (this._initOptions.geo.blockedCountries.includes(this.geoInfo?.country)) {
                            module = this._initOptions.geo.moduleOnBlocking;
                            modulePath = this.getModulePath(this._initOptions.geo.moduleOnBlocking);
                        }
                        else {
                            modulePath = this.getModulePath(module);
                        }
                    }
                    catch (err) {
                        console.log(err);
                        module = this._initOptions.geo.moduleOnBlocking;
                        modulePath = this.getModulePath(this._initOptions.geo.moduleOnBlocking);
                    }
                }
                else {
                    modulePath = this.getModulePath(module);
                }
            }
            ;
            let elmId = this.modulesId[modulePath];
            if (elmId && modulePath) {
                let Module = this.modules[modulePath];
                return new Module(null, options);
                // return <any>(document.createElement(elmId));
            }
            ;
            let script;
            if (options && options.script)
                script = options.script;
            else {
                if (this._initOptions && this._initOptions.modules && this._initOptions.modules[module] && this._initOptions.modules[module].dependencies) {
                    let dependencies = this._initOptions.modules[module].dependencies;
                    // console.dir(dependencies)
                    await this.loadPackages(dependencies);
                    // for (let i = 0; i < dependencies.length; i ++){
                    //     let dep = dependencies[i];
                    //     let path = this.getModulePath(dep);
                    //     if (!this.packages[path]){
                    //         await this.loadPackage(dep, path)
                    //     };
                    // };              
                }
                ;
                try {
                    let m = window['require'](module);
                    if (m) {
                        let module = m.default || m;
                        if (module) {
                            this.currentModulePath = modulePath;
                            if (modulePath.indexOf('://') > 0)
                                this.currentModuleDir = modulePath.split('/').slice(0, -1).join('/');
                            else if (!modulePath.startsWith('/'))
                                this.currentModuleDir = this.LibHost + this.rootDir + modulePath.split('/').slice(0, -1).join('/');
                            else
                                this.currentModuleDir = this.LibHost + modulePath.split('/').slice(0, -1).join('/');
                            this.id++;
                            let elmId = `i-module--${this.id}`;
                            let Module = class extends module {
                            };
                            this.modulesId[modulePath] = elmId;
                            this.modules[modulePath] = Module;
                            customElements.define(elmId, Module);
                            let result = new Module(null, options);
                            return result;
                        }
                        ;
                    }
                }
                catch (err) { }
                ;
                if (this.bundleLibs[module])
                    script = this.bundleLibs[module];
                else
                    script = await this.getScript(modulePath);
            }
            ;
            if (script) {
                let elmId = await this.initModule(modulePath, script);
                if (elmId) {
                    let Module = this.modules[modulePath];
                    let result = new Module(null, options);
                    return result;
                }
                ;
                // _currentDefineModule = null;
                // this.currentModulePath = modulePath;
                // if (modulePath.indexOf('://') > 0)
                //     this.currentModuleDir = modulePath.split('/').slice(0, -1).join('/')
                // else
                //     this.currentModuleDir = application.LibHost + modulePath.split('/').slice(0, -1).join('/')
                // await import(`data:text/javascript,${encodeURIComponent(script)}`);
                // document.getElementsByTagName('html')[0].classList.add(applicationStyle);
                // this.currentModulePath = '';
                // this.currentModuleDir = '';
                // if (!_currentDefineModule && this.packages[modulePath]) {
                //     _currentDefineModule = this.packages[modulePath];
                // };
                // if (_currentDefineModule){
                //     let module = _currentDefineModule.default || _currentDefineModule;   
                //     if (module){
                //         this.id ++;
                //         elmId = `i-module--${this.id}`;
                //         this.modulesId[modulePath] = elmId;
                //         let Module = class extends module{};
                //         customElements.define(elmId, Module);
                //         let result = new (<any>Module)(null, options);                 
                //         // let result = <any>(document.createElement(elmId));
                //         return <any>result;
                //     };
                // };
            }
            ;
            return null;
        }
        ;
        async copyToClipboard(value) {
            if (!value)
                return false;
            try {
                if (navigator.clipboard) {
                    await navigator.clipboard.writeText(value);
                    return true;
                }
                else {
                    const input = document.createElement('input');
                    input.value = value;
                    input.style.position = 'fixed';
                    input.style.opacity = '0';
                    document.body.appendChild(input);
                    input.focus();
                    input.select();
                    const result = document.execCommand('copy');
                    document.body.removeChild(input);
                    return result;
                }
            }
            catch (err) {
                console.log('debug: copy', err);
                return false;
            }
            ;
        }
        ;
        xssSanitize(value) {
            //TODO: sanitize untrusted script to prevent XSS attacks
            //https://github.com/cure53/DOMPurify
            return DOMPurify.sanitize(value);
        }
        ;
    }
    Application._modules = {};
    exports.Application = Application;
    ;
    window['application'] = Application.Instance;
    exports.application = Application.Instance;
    Object.defineProperty(exports, "EventBus", { enumerable: true, get: function () { return event_bus_2.EventBus; } });
    Object.defineProperty(exports, "FormatUtils", { enumerable: true, get: function () { return formatUtils_1.FormatUtils; } });
    exports.default = exports.application;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/checkbox/style/checkbox.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-checkbox', {
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        userSelect: 'none',
        '$nest': {
            '.i-checkbox': {
                display: 'inline-flex',
                alignItems: 'center',
                position: 'relative',
                maxWidth: '100%'
            },
            '.i-checkbox_input': {
                cursor: 'pointer',
                whiteSpace: 'nowrap',
                display: 'inline-flex',
                position: 'relative'
            },
            '.checkmark': {
                width: 15,
                height: 15,
                display: 'inline-block',
                position: 'relative',
                backgroundColor: Theme.background.paper,
                border: `1px solid ${Theme.divider}`,
                // zIndex: -1,
                boxSizing: 'border-box',
                transition: 'border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46)'
            },
            '.i-checkbox_label': {
                boxSizing: 'border-box',
                color: Theme.text.primary,
                display: 'inline-block',
                paddingLeft: 8,
                maxWidth: '100%'
            },
            'input': {
                opacity: 0,
                width: 0,
                height: 0,
                position: 'absolute',
                top: 0,
                left: 0
            },
            '&.is-checked': {
                '$nest': {
                    '.i-checkbox_label': {
                        color: Theme.colors.info.main
                    },
                    '.checkmark': {
                        backgroundColor: Theme.colors.info.main
                    },
                    '.checkmark:after': {
                        transform: 'rotate(45deg) scaleY(1)'
                    },
                    '.is-indeterminate .checkmark:after': {
                        transform: 'none'
                    }
                }
            },
            '&:not(.disabled):hover input ~ .checkmark': {
                borderColor: Theme.colors.info.main
            },
            '&.disabled': {
                cursor: 'not-allowed'
            },
            '.checkmark:after': {
                content: "''",
                boxSizing: 'content-box',
                border: `1px solid ${Theme.background.paper}`,
                borderLeft: 0,
                borderTop: 0,
                height: 7.5,
                left: '35%',
                top: 1,
                transform: 'rotate(45deg) scaleY(0)',
                width: 3.5,
                transition: 'transform .15s ease-in .05s',
                transformOrigin: 'center',
                display: 'inline-block',
                position: 'absolute'
            },
            '.is-indeterminate .checkmark': {
                backgroundColor: Theme.colors.info.main
            },
            '.is-indeterminate .checkmark:after': {
                width: '80%',
                height: 0,
                top: '50%',
                left: '10%',
                borderRight: 0,
                transform: 'none'
            },
        }
    });
});
define("@ijstech/checkbox/checkbox.ts", ["require", "exports", "@ijstech/base", "@ijstech/types", "@ijstech/application", "@ijstech/checkbox/style/checkbox.css.ts"], function (require, exports, base_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkbox = void 0;
    const DEFAULT_VALUES = {
        indeterminate: false,
        checked: false,
        captionWidth: 0,
        readOnly: false,
        caption: ''
    };
    let Checkbox = class Checkbox extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                height: 30
            });
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionSpanElm && this._caption?.startsWith('$'))
                this.captionSpanElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            const value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(this._caption) ||
                    application_1.application.i18n?.get(this._caption) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this.captionSpanElm.style.display = !value ? 'none' : '';
            if (!this.captionSpanElm)
                return;
            this.captionSpanElm.textContent = this.caption;
        }
        get captionWidth() {
            return this._captionWidth;
        }
        set captionWidth(value) {
            if (!value)
                return;
            this._captionWidth = value;
            this.setElementPosition(this.captionSpanElm, 'width', value);
        }
        get height() {
            return this.offsetHeight;
        }
        set height(value) {
            this.setPosition('height', value);
        }
        get indeterminate() {
            return this._indeterminate;
        }
        set indeterminate(value) {
            this._indeterminate = value;
            if (this.inputSpanElm)
                value
                    ? this.inputSpanElm.classList.add('is-indeterminate')
                    : this.inputSpanElm.classList.remove('is-indeterminate');
            this.inputElm.indeterminate = value;
        }
        get checked() {
            return this._checked;
        }
        set checked(value) {
            this._checked = value;
            this.addClass(value, 'is-checked');
            this.inputElm && (this.inputElm.checked = value);
        }
        get value() {
            return this.inputElm.value;
        }
        set value(data) {
            this.inputElm.value = data;
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            if (this.inputElm) {
                this.inputElm.disabled = !value;
            }
        }
        get readOnly() {
            return this._readOnly;
        }
        set readOnly(value) {
            this._readOnly = value;
            if (this.inputElm) {
                this.inputElm.readOnly = value;
            }
        }
        _handleChange(event) {
            if (this.readOnly || this._designMode)
                return;
            this.checked = this.inputElm.checked || false;
            this.addClass(this.checked, 'is-checked');
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, event);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, event);
        }
        addClass(value, className) {
            if (value)
                this.classList.add(className);
            else
                this.classList.remove(className);
        }
        init() {
            if (!this.captionSpanElm) {
                this.wrapperElm = this.createElement('label', this);
                if (this.height)
                    this.wrapperElm.style.height = this.height + 'px';
                this.wrapperElm.classList.add('i-checkbox');
                this.inputSpanElm = this.createElement('span', this.wrapperElm);
                this.inputSpanElm.classList.add('i-checkbox_input');
                this.inputElm = this.createElement('input', this.inputSpanElm);
                this.inputElm.type = 'checkbox';
                const disabled = this.getAttribute('enabled') === false;
                this.inputElm.disabled = disabled;
                this.readOnly = this.getAttribute('readOnly', true, DEFAULT_VALUES.readOnly);
                this.checkmarklElm = this.createElement('span');
                this.checkmarklElm.classList.add('checkmark');
                this.inputSpanElm.appendChild(this.checkmarklElm);
                this.inputElm.addEventListener('input', this._handleChange.bind(this));
                this.captionSpanElm = this.createElement('span', this.wrapperElm);
                this.captionSpanElm.classList.add('i-checkbox_label');
                this.captionWidth = this.getAttribute('captionWidth', true);
                this.caption = this.getAttribute('caption', true);
                this.value = this.caption;
                this.checked = this.getAttribute('checked', true, DEFAULT_VALUES.checked);
                this.indeterminate = this.getAttribute('indeterminate', true);
                this.onChanged = this.getAttribute('onChanged', true) || this.onChanged;
                super.init();
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('cchecked')
    ], Checkbox.prototype, "_checked", void 0);
    Checkbox = __decorate([
        (0, base_1.customElements)('i-checkbox', {
            icon: 'check-square',
            group: types_1.GroupType.FIELDS,
            className: 'Checkbox',
            props: {
                checked: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.checked
                },
                indeterminate: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.indeterminate
                },
                caption: {
                    type: 'string',
                    default: DEFAULT_VALUES.caption
                },
                captionWidth: {
                    type: 'number',
                    default: DEFAULT_VALUES.captionWidth
                },
                readOnly: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.readOnly
                }
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    checked: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.checked
                    },
                    indeterminate: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.indeterminate
                    },
                    caption: {
                        type: 'string'
                    },
                    readOnly: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.readOnly
                    }
                }
            }
        })
    ], Checkbox);
    exports.Checkbox = Checkbox;
});
define("@ijstech/checkbox", ["require", "exports", "@ijstech/checkbox/checkbox.ts"], function (require, exports, checkbox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkbox = void 0;
    Object.defineProperty(exports, "Checkbox", { enumerable: true, get: function () { return checkbox_1.Checkbox; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/image/style/image.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Styles.cssRule("i-image", {
        position: 'relative',
        $nest: {
            'img': {
                maxHeight: '100%',
                maxWidth: '100%',
                height: 'inherit',
                verticalAlign: 'middle',
                objectFit: 'contain',
                overflow: 'hidden',
                width: '100%'
            }
        }
    });
});
define("@ijstech/image/image.ts", ["require", "exports", "@ijstech/base", "@ijstech/style", "@ijstech/types", "@ijstech/image/style/image.css.ts"], function (require, exports, base_1, Styles, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Image = void 0;
    let Image = class Image extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            // private _dataUrl: string;
            this._rotate = 0;
            this._usedFallback = false;
        }
        get fallbackUrl() {
            return this._fallbackUrl;
        }
        set fallbackUrl(value) {
            this._fallbackUrl = value;
        }
        get rotate() {
            return this._rotate;
        }
        set rotate(value) {
            if (value == undefined)
                return;
            value = parseInt(value);
            if (value != this._rotate) {
                if (this.imageElm) {
                    if (this._rotate != 0)
                        this.imageElm.classList.remove(Styles.rotate(this._rotate));
                    this.imageElm.classList.add(Styles.rotate(value));
                }
                this._rotate = value;
            }
        }
        get url() {
            return this._url;
        }
        set url(value) {
            if (value?.startsWith('this.'))
                return;
            this._url = value;
            if (!this.imageElm)
                this.imageElm = this.createElement('img', this);
            this.imageElm.src = value ?? '';
            this.imageElm.style.display = 'none';
            const self = this;
            this.imageElm.onerror = function () {
                if (self._fallbackUrl && !self._usedFallback) {
                    this.src = self._fallbackUrl;
                    self._usedFallback = true;
                }
            };
            this.imageElm.onload = function () {
                self.imageElm.style.display = '';
            };
            if (this._borderValue) {
                this._border = new base_1.Border(this.imageElm, this._borderValue);
            }
            if (this._objectFit)
                this.imageElm.style.objectFit = this._objectFit;
        }
        get objectFit() {
            return this._objectFit;
        }
        set objectFit(value) {
            this._objectFit = value;
            if (this.imageElm) {
                this.imageElm.style.objectFit = value;
            }
        }
        get border() {
            return this._border;
        }
        set border(value) {
            this._borderValue = value;
            if (this.imageElm) {
                this._border = new base_1.Border(this.imageElm, value);
            }
        }
        // get dataUrl(): string {
        //     return this._dataUrl;
        // }
        // set dataUrl(value: string) {
        //     this._dataUrl = value;
        //     if (value) {
        //         if (!this.imageElm) this.imageElm = <HTMLImageElement>this.createElement('img', this);
        //     }
        //     if (this.imageElm) this.imageElm.src = value;
        // }
        // private async fetchData(url: string) {
        //     if (!url) return;
        //     await fetch(url)
        //         .then((response) => response.blob())
        //         .then((imageBlob) => {
        //             const imageObjectURL = URL.createObjectURL(imageBlob);
        //             this.dataUrl = imageObjectURL;
        //         });
        // }
        init() {
            super.init();
            (0, base_1.setAttributeToProperty)(this, 'fallbackUrl');
            (0, base_1.setAttributeToProperty)(this, 'url');
            (0, base_1.setAttributeToProperty)(this, 'objectFit', 'contain');
            this.rotate = this.getAttribute('rotate', true);
            const border = this.getAttribute('border', true);
            if (border) {
                this._borderValue = border;
                if (this.imageElm) {
                    this._border = new base_1.Border(this.imageElm, border);
                    this.style.border = 'none';
                }
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Image = __decorate([
        (0, base_1.customElements)('i-image', {
            icon: 'image',
            group: types_1.GroupType.BASIC,
            className: 'Image',
            props: {
                rotate: {
                    type: 'number'
                },
                url: {
                    type: 'string',
                    default: ''
                },
                fallbackUrl: {
                    type: 'string',
                    default: ''
                },
                objectFit: {
                    type: 'string',
                    default: 'contain'
                },
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    rotate: {
                        type: 'number'
                    },
                    url: {
                        type: 'string'
                    },
                    fallbackUrl: {
                        type: 'string'
                    },
                    objectFit: {
                        type: 'string',
                        enum: ['contain', 'cover', 'fill', 'none', 'scale-down'],
                        default: 'contain'
                    }
                }
            }
        })
    ], Image);
    exports.Image = Image;
});
define("@ijstech/image", ["require", "exports", "@ijstech/image/image.ts"], function (require, exports, image_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Image = void 0;
    Object.defineProperty(exports, "Image", { enumerable: true, get: function () { return image_1.Image; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/icon/style/icon.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    const spinnerAnim = Styles.keyframes({
        "0%": {
            transform: 'rotate(0deg)'
        },
        "100%": {
            transform: 'rotate(360deg)'
        },
    });
    Styles.cssRule('i-icon', {
        display: 'inline-block',
        $nest: {
            "svg": {
                fill: Theme.text.primary,
                verticalAlign: 'top',
                width: "100%",
                height: "100%"
            },
            '&.is-spin': {
                animation: `${spinnerAnim} 2s linear infinite`
            }
        }
    });
});
define("@ijstech/icon/icon.ts", ["require", "exports", "@ijstech/base", "@ijstech/image", "@ijstech/types", "@ijstech/icon/style/icon.css.ts"], function (require, exports, base_1, image_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Icon = void 0;
    let _iconLoaded = false;
    async function loadIconFile() {
        if (_iconLoaded)
            return;
        _iconLoaded = true;
        try {
            let res = await fetch(`${base_1.LibPath}assets/icon/solid.svg`);
            let text = await res.text();
            let span = document.createElement('span');
            span.innerHTML = text;
            document.body.appendChild(span);
        }
        catch (err) {
            _iconLoaded = false;
        }
        ;
    }
    ;
    let Icon = class Icon extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            loadIconFile();
        }
        init() {
            if (!this.initialized) {
                super.init();
                let fill = this.getAttribute('fill', true);
                if (fill)
                    this.fill = fill;
                this._size = this.getAttribute('size', true);
                this._name = this.getAttribute('name');
                this._updateIcon();
                const image = this.getAttribute('image', true);
                if (image && image.url) {
                    image.height = image.height || this.height || "16px";
                    image.width = image.width || this.width || "16px";
                    this.image = new image_1.Image(this, image);
                }
                this.spin = this.getAttribute('spin', true, false);
            }
        }
        get fill() {
            return this._fill;
        }
        set fill(color) {
            this._fill = color;
            let svg = this.querySelector("svg");
            if (svg)
                svg.style.fill = color;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._name = value;
            this._updateIcon();
        }
        get image() {
            if (!this._image) {
                this._image = image_1.Image.create({
                    width: this.width || 16,
                    height: this.height || 16
                });
            }
            return this._image;
        }
        set image(image) {
            if (this._image && this.contains(this._image))
                this.removeChild(this._image);
            this._image = image;
            if (this._image)
                this.prepend(this._image);
        }
        get spin() {
            return this._spin;
        }
        set spin(value) {
            this._spin = value;
            if (value)
                this.classList.add('is-spin');
            else
                this.classList.remove('is-spin');
            this._parent && this._parent.refresh();
        }
        _updateIcon() {
            if (this._name)
                this.innerHTML = `<svg${this._fill ? ` style="fill: ${this._fill}"` : ""}><use xlink:href="#${this.name}"></use></svg>`;
            else
                this.innerHTML = '';
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Icon = __decorate([
        (0, base_1.customElements)('i-icon', {
            icon: 'icons',
            group: types_1.GroupType.BASIC,
            className: 'Icon',
            props: {
                name: {
                    type: 'string',
                    default: ''
                },
                fill: {
                    type: 'string',
                    default: ''
                },
                image: {
                    type: 'object',
                    default: {}
                },
                spin: {
                    type: 'boolean',
                    default: false
                }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    name: {
                        type: 'string'
                    },
                    fill: {
                        type: 'string',
                        format: 'color'
                    },
                    image: {
                        type: 'object',
                        properties: {
                            url: {
                                type: 'string'
                            },
                            width: {
                                type: 'number'
                            },
                            height: {
                                type: 'number'
                            }
                        }
                    },
                    spin: {
                        type: 'boolean',
                        default: false
                    }
                }
            }
        })
    ], Icon);
    exports.Icon = Icon;
});
define("@ijstech/icon", ["require", "exports", "@ijstech/icon/icon.ts"], function (require, exports, icon_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Icon = void 0;
    Object.defineProperty(exports, "Icon", { enumerable: true, get: function () { return icon_1.Icon; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/combo-box/style/combo-box.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemListStyle = void 0;
    let Theme = Styles.Theme.ThemeVars;
    exports.ItemListStyle = Styles.style({
        display: 'none',
        position: 'absolute',
        margin: "0.05rem 0 0",
        backgroundColor: "#fff",
        border: "1px solid rgba(0,0,0,.15)",
        borderRadius: "0.25rem",
        zIndex: "99999",
        $nest: {
            "> ul": {
                maxHeight: "100px",
                overflowY: "scroll",
                overflowX: "hidden",
                listStyle: "none",
                margin: 0,
                padding: 0,
                borderRadius: 'inherit'
            },
            "> ul > li": {
                display: "block",
                width: "100%",
                padding: "0.25rem 0.5rem",
                backgroundColor: "transparent",
                wordBreak: 'break-word',
                // whiteSpace: "nowrap",
                // textOverflow: "ellipsis",
                cursor: "pointer",
                borderRadius: 'inherit'
            },
            "> ul > li .highlight": {
                backgroundColor: Theme.colors.warning.light,
            },
            "> ul > li.matched": {
                backgroundColor: Theme.colors.primary.light,
            },
            "> ul > li:hover": {
                backgroundColor: Theme.colors.primary.light,
            },
            '.selection-item': {
                display: 'grid',
                gridTemplateColumns: '25px 1fr',
                gap: 5,
                alignItems: 'center',
                fontFamily: Theme.typography.fontFamily
            },
            '.selection-icon': {
                height: 20,
                width: 20,
            },
            '.selection-title': {
                display: 'block',
                color: Theme.combobox.fontColor,
                fontWeight: 'bold'
            },
            '.selection-description': {
                display: 'block',
                color: Theme.combobox.fontColor,
                fontSize: Theme.typography.fontSize
            }
        }
    });
    Styles.cssRule("i-combo-box", {
        position: "relative",
        display: "flex",
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        color: Theme.text.primary,
        alignItems: 'center',
        $nest: {
            '&.i-combo-box-multi': {
                height: 'auto !important'
            },
            "> .icon-btn": {
                display: "inline-flex",
                flexWrap: 'nowrap',
                whiteSpace: 'nowrap',
                background: 'inherit',
                padding: "8px",
                marginLeft: "-1px",
                cursor: "pointer",
                height: '100%',
                alignItems: "center",
                position: 'absolute',
                right: 0,
                border: `0.5px solid ${Theme.divider}`,
                borderLeft: 'none',
                borderRadius: "inherit",
                borderTopLeftRadius: '0px !important',
                borderBottomLeftRadius: '0px !important',
            },
            "> .icon-btn:hover": {
                backgroundColor: Theme.action.hoverBackground,
            },
            "> .icon-btn i-icon": {
                display: "inline-block",
                width: "12px",
                height: "12px",
            },
            '.selection': {
                display: 'inline-flex',
                alignItems: 'center',
                flexWrap: 'wrap',
                maxWidth: 'calc(100% - 32px)',
                height: '100%',
                border: `0.5px solid ${Theme.divider}`,
                borderRight: 'none !important',
                background: Theme.combobox.background,
                borderRadius: 'inherit',
                borderTopRightRadius: '0px !important',
                borderBottomRightRadius: '0px !important',
                padding: '2px 4px',
                transition: 'all .3s cubic-bezier(.645,.045,.355,1)',
                gap: 5,
                flexGrow: 1,
                maxHeight: '100%',
                $nest: {
                    '.selection-item': {
                        border: `1px solid ${Theme.divider}`,
                        backgroundColor: 'rgba(0, 0, 0, 0.12)',
                        color: Theme.combobox.fontColor,
                        borderRadius: 3,
                        display: 'inline-flex',
                        alignItems: 'center',
                        padding: '3px 5px',
                        gap: 4,
                        maxWidth: 'clamp(100px, 50%, 200px)',
                        userSelect: 'none',
                        $nest: {
                            '.close-icon': {
                                cursor: 'pointer',
                                opacity: '0.5'
                            },
                            '.close-icon:hover': {
                                opacity: 1
                            },
                            '> span:first-child': {
                                display: 'inline-block',
                                overflow: 'hidden',
                                whiteSpace: 'pre',
                                textOverflow: 'ellipsis'
                            }
                        }
                    },
                    'input': {
                        padding: '1px 0.5rem',
                        border: 'none',
                        boxShadow: 'none',
                        outline: 'none',
                        width: 'auto !important',
                        maxWidth: '100%',
                        flex: 1,
                        background: Theme.combobox.background,
                        color: Theme.combobox.fontColor,
                        fontSize: 'inherit'
                    }
                }
            },
        }
    });
});
define("@ijstech/combo-box/combo-box-item.ts", ["require", "exports", "@ijstech/base"], function (require, exports, base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboBoxItem = void 0;
    let ComboBoxItem = class ComboBoxItem extends base_1.Control {
        get value() {
            return this._value;
        }
        set value(data) {
            this._value = data;
        }
        get label() {
            return this._label;
        }
        set label(data) {
            this._label = data;
        }
        init() {
            super.init();
            this.value = this.getAttribute('value', true);
            this.label = this.textContent || this.getAttribute('label', true);
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    ComboBoxItem = __decorate([
        (0, base_1.customElements)('i-combo-box-item')
    ], ComboBoxItem);
    exports.ComboBoxItem = ComboBoxItem;
});
define("@ijstech/combo-box/combo-box.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/style", "@ijstech/combo-box/style/combo-box.css.ts", "@ijstech/types", "@ijstech/combo-box/combo-box-item.ts", "@ijstech/application", "@ijstech/combo-box/style/combo-box.css.ts"], function (require, exports, base_2, icon_1, style_1, combo_box_css_1, types_1, combo_box_item_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboBox = void 0;
    const DEFAULT_VALUES = {
        mode: 'single',
        readOnly: false,
        icon: {
            width: 16,
            height: 16,
            fill: style_1.Theme.ThemeVars.text.primary,
            name: 'angle-down'
        }
    };
    let ComboBox = class ComboBox extends base_2.Control {
        constructor(parent, options) {
            super(parent, options, {
                mode: DEFAULT_VALUES.mode
            });
            this.newItem = null;
            this.isListShown = false;
        }
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
            if (Array.isArray(this.items)) {
                const selectedItem = this.items.find(item => item.value === value);
                this.selectedItem = selectedItem;
            }
        }
        get selectedItem() {
            return this._selectedItem;
        }
        set selectedItem(value) {
            if (!value) {
                this.clear();
                return;
            }
            const isValueValid = this.isValueValid(value);
            this.updateItems(value, isValueValid);
        }
        get selectedItems() {
            return this._selectedItems;
        }
        set selectedItems(value) {
            if (!value || value.length === 0) {
                this.clear();
                return;
            }
            let isValueValid = false;
            let validValue = [];
            if (this.isMulti) {
                validValue = [...value].filter(item => this.isValueValid(item));
                isValueValid = !!validValue.length;
            }
            else {
                validValue = value;
                isValueValid = this.isValueValid(value[0]);
            }
            this.updateItems(value, isValueValid);
        }
        renderSelectedItems() {
            if (this.inputElm) {
                this.inputElm.value = '';
                this.inputElm.style.display = "none";
            }
            const selectionItems = Array.from(this.inputWrapElm.querySelectorAll('.selection-item'));
            selectionItems.forEach(elm => this.inputWrapElm.removeChild(elm));
            if (!this._selectedItems || !this._selectedItems?.length)
                return;
            this._selectedItems.forEach(item => {
                const itemElm = this.createElement('div');
                itemElm.classList.add('selection-item');
                const content = this.createElement('span', itemElm);
                content.textContent = this.getTranslatedText(item.label || '');
                itemElm.appendChild(content);
                const closeButton = this.createElement('span', itemElm);
                closeButton.classList.add("close-icon");
                closeButton.innerHTML = "&times;";
                closeButton.addEventListener('click', (event) => this.handleRemove(event, item));
                this.inputWrapElm.appendChild(itemElm);
                this.inputWrapElm.insertBefore(itemElm, this.inputElm);
            });
        }
        renderInvalidItems() {
            this.inputElm.value = '';
            this.inputElm.style.display = "";
            const selectionItems = Array.from(this.inputWrapElm.querySelectorAll('.selection-item'));
            selectionItems.forEach(elm => this.inputWrapElm.removeChild(elm));
        }
        updateItems(value, isValid) {
            if (isValid) {
                this._selectedItem = Array.isArray(value) ? value[0] : value;
                this._selectedItems = Array.isArray(value) ? value : [value];
                this._value = this._selectedItem?.value;
                if (this.mode === 'single') {
                    this.inputElm.value = this.getTranslatedText(this._selectedItem?.label || '');
                }
                else {
                    this.renderSelectedItems();
                }
                if (this.callback)
                    this.callback(value);
            }
            else if (this.isMulti) {
                this._selectedItems = Array.isArray(value) ? value : [value];
                this.renderInvalidItems();
            }
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.labelElm && this._caption?.startsWith('$'))
                this.labelElm.textContent = i18n.get(this._caption) || '';
            if (this.inputElm && this._placeholder?.startsWith('$'))
                this.inputElm.placeholder = i18n.get(this._placeholder) || '';
        }
        get caption() {
            return this.getTranslatedText(this._caption || '');
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this.labelElm.style.display = !value ? 'none' : '';
            if (!this.labelElm)
                return;
            this.labelElm.textContent = this.caption;
        }
        get captionWidth() {
            return this._captionWidth;
        }
        set captionWidth(value) {
            this._captionWidth = value;
            this.setElementPosition(this.labelElm, 'width', value);
        }
        get items() {
            return this._items;
        }
        set items(items) {
            this._items = Array.isArray(items) ? items : [];
            if (this.listElm) {
                this.listElm.innerHTML = "";
                if (this._value !== undefined) {
                    this.value = this._value;
                }
                this.renderItems();
            }
        }
        get icon() {
            if (!this._icon) {
                this._icon = new icon_1.Icon(undefined, DEFAULT_VALUES.icon);
                if (this.iconElm)
                    this.iconElm.appendChild(this._icon);
            }
            return this._icon;
        }
        set icon(value) {
            if (this.iconElm) {
                if (this._icon && this.iconElm.contains(this._icon))
                    this.iconElm.removeChild(this._icon);
                this._icon = value;
                if (this._icon)
                    this.iconElm.appendChild(this._icon);
            }
        }
        get searchStr() {
            return this._searchStr;
        }
        set searchStr(str) {
            this._searchStr = str || '';
        }
        get placeholder() {
            return this.getTranslatedText(this._placeholder || '');
        }
        set placeholder(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._placeholder = value;
            if (this.inputElm)
                this.inputElm.placeholder = this.placeholder;
        }
        getTranslatedText(value) {
            if (typeof value === 'string' && value.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        get mode() {
            return this._mode;
        }
        set mode(value) {
            this._mode = value;
            if (this.isMulti)
                this.classList.add('i-combo-box-multi');
            else
                this.classList.remove('i-combo-box-multi');
        }
        get isMulti() {
            return this.mode === 'tags' || this.mode === 'multiple';
        }
        set border(value) {
            super.border = value;
            const hasBorderSide = this.border.bottom || this.border.top || this.border.left || this.border.right;
            if (this.border.style || hasBorderSide) {
                this.inputWrapElm && (this.inputWrapElm.style.borderStyle = 'none');
                this.iconElm && (this.iconElm.style.borderStyle = 'none');
            }
        }
        get border() {
            return super.border;
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            if (this.inputElm) {
                this.inputElm.disabled = !value;
            }
        }
        get readOnly() {
            return this._readOnly;
        }
        set readOnly(value) {
            this._readOnly = value;
            if (this.inputElm) {
                this.inputElm.readOnly = value;
            }
        }
        get background() {
            return this._background;
        }
        set background(value) {
            super.background = value;
            if (value && value.color !== undefined) {
                this.style.setProperty('--combobox-background', value.color);
            }
            else {
                this.style.removeProperty('--combobox-background');
            }
        }
        get font() {
            return this._font;
        }
        set font(value) {
            super.font = value;
            if (value && value.color !== undefined) {
                this.style.setProperty('--combobox-font_color', value.color);
            }
            else {
                this.style.removeProperty('--combobox-font_color');
            }
        }
        isValueValid(value) {
            if (!value)
                return false;
            const index = this.getItemIndex(this.items, value);
            return index >= 0;
        }
        getItemIndex(items, item) {
            const value = item?.value?.toString();
            if (!value && value !== '')
                return -1;
            const index = items.findIndex((_item) => {
                return _item.value.toString().toLowerCase() === value.toLowerCase();
            });
            return index;
        }
        openList() {
            this.isListShown = true;
            window.document.body.append(this.listElm);
            this.listElm.classList.add("show");
            this.listElm.style.display = 'block';
            this.calculatePositon();
            if (!this.searchStr)
                this.renderItems();
        }
        calculatePositon() {
            let parentElement = this.linkTo || this;
            let rect = parentElement.getBoundingClientRect();
            const scrollTop = document.documentElement.scrollTop || window.pageYOffset;
            const scrollLeft = document.documentElement.scrollLeft || window.pageXOffset;
            const top = rect.top + scrollTop + rect.height;
            const left = rect.left + scrollLeft; // + this.captionSpanElm.offsetWidth;
            const width = rect.right - rect.left; // - this.captionSpanElm.offsetWidth;
            this.listElm.style.top = top + 'px';
            this.listElm.style.left = left + 'px';
            this.listElm.style.width = width + 'px';
        }
        closeList() {
            this.isListShown = false;
            this.listElm.remove();
            this.listElm.style.display = 'none';
            this.listElm.classList.remove("show");
            this.searchStr = "";
            if (this.isMulti)
                return;
            const label = this.getTranslatedText(this.selectedItem?.label || '');
            if (label && this.inputElm)
                this.inputElm.value = label;
        }
        toggleList() {
            this.isListShown ? this.closeList() : this.openList();
        }
        escapeRegExp(text) {
            return text ? text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : text;
        }
        renderItems() {
            if (this.mode === 'tags' && this.newItem) {
                if (this.searchStr)
                    this.newItem.label = this.searchStr;
                const liElm = this.listElm.querySelector(`li[data-key="${this.newItem.value}"]`);
                if (liElm) {
                    if (this.searchStr) {
                        liElm.textContent = this.searchStr;
                        liElm.classList.add("matched");
                        liElm.innerHTML = `<span class="highlight">${this.searchStr}</span>`;
                    }
                    else {
                        liElm.remove();
                        this.newItem = null;
                    }
                }
                else {
                    const ul = this.listElm.querySelector('ul');
                    ul && this.add(this.newItem, ul);
                }
            }
            const regExp = new RegExp(this.escapeRegExp(this.searchStr), "g");
            this.listElm.innerHTML = "";
            if (this.searchStr)
                this.openList();
            const ulElm = this.createElement("ul", this.listElm);
            let creatingNew = false;
            for (let item of this.items) {
                const label = this.getTranslatedText(item.label || '');
                const isMatchedPart = this.searchStr && label.toLowerCase().includes(this.searchStr.toLowerCase());
                const isMatchedDone = this.searchStr && label.toLowerCase() === this.searchStr.toLowerCase();
                if (item.isNew && isMatchedPart && !isMatchedDone)
                    creatingNew = true;
                if (!this.searchStr || isMatchedDone || isMatchedPart) {
                    const liElm = this.createElement("li", ulElm);
                    liElm.setAttribute('data-key', item.value);
                    liElm.addEventListener("click", (event) => {
                        event.stopPropagation();
                        this.onItemClick(event, liElm, item);
                    });
                    if (this.selectedItems?.length && this.isMulti) {
                        const index = this.getItemIndex(this.selectedItems, item);
                        if (index >= 0)
                            liElm.classList.add("matched");
                    }
                    else if (item?.value === this.selectedItem?.value) {
                        liElm.classList.add("matched");
                    }
                    let displayItem = '';
                    if (item.description) {
                        displayItem =
                            `<div class="selection-item">
                   <div class="selection-icon">
                       ${item.icon ? `<img src="${item.icon}" style="height: 18px; width: 18px;"/>` : ''}
                   </div>
                   <div>
                      <span class="selection-title">${this.searchStr ? label.replace(regExp, `<span class="highlight">${this.searchStr}</span>`) : label}</span>
                      <span class="selection-description">${this.searchStr ? item.description.replace(regExp, `<span class="highlight">${this.searchStr}</span>`) : item.description}</span>
                   </div>
               </div>`;
                    }
                    else {
                        displayItem = this.searchStr
                            ? label.replace(regExp, `<span class="highlight">${this.searchStr}</span>`)
                            : label;
                    }
                    liElm.innerHTML = displayItem;
                }
            }
            if (!ulElm.innerHTML || creatingNew) {
                if (this.mode === 'tags') {
                    if (!this.newItem)
                        this.newItem = {
                            value: new Date().getTime().toString(),
                            label: this.searchStr
                        };
                    const liElm = this.listElm.querySelector(`li[data-key="${this.newItem.label}"]`);
                    if (!liElm)
                        this.add(this.newItem, ulElm);
                }
                else if (!ulElm.innerHTML)
                    ulElm.innerHTML = `<li style="text-align:center;">${application_1.application.i18n.get('no_data')}</li>`;
            }
        }
        add(item, parent) {
            const liElm = this.createElement("li");
            liElm.setAttribute('data-key', item.value);
            liElm.addEventListener("click", (event) => {
                event.stopPropagation();
                this.onItemClick(event, liElm, item);
            });
            liElm.classList.add("matched");
            liElm.innerHTML = `<span class="highlight">${this.searchStr}</span>`;
            parent.prepend(liElm);
        }
        handleRemove(event, item) {
            event.stopPropagation();
            if (!this.enabled)
                return;
            const liElm = this.listElm.querySelector(`li[data-key="${item.value}"]`);
            if (liElm) {
                liElm.classList.remove('matched');
                if (this.mode === 'tags' && item.isNew) {
                    liElm.remove();
                    this.items = this.items.filter(data => data.value !== item.value);
                }
            }
            const selectedItems = this.selectedItems || [];
            const selectedIndex = this.getItemIndex(selectedItems, item);
            if (selectedIndex >= 0)
                selectedItems.splice(selectedIndex, 1);
            this.selectedItems = selectedItems;
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, event);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, event);
        }
        onItemClick(event, liElm, item) {
            if (this.newItem?.value === item.value) {
                item = { ...this.newItem, value: this.newItem.label, isNew: true };
                this.items.push(item);
            }
            this.newItem = null;
            if (this.isMulti && this.selectedItems?.length) {
                const index = this.getItemIndex(this.selectedItems, item);
                const selectedItems = this.selectedItems || [];
                if (index >= 0) {
                    selectedItems.splice(index, 1);
                }
                else {
                    selectedItems.push(item);
                }
                this.selectedItems = selectedItems;
                liElm.classList.toggle("matched");
                this.closeList();
            }
            else {
                this.selectedItem = item;
                this.closeList();
            }
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, event);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, event);
        }
        clear() {
            this._selectedItems = [];
            this._selectedItem = undefined;
            this.inputElm.style.display = "";
            this.inputElm.value = '';
            this._value = '';
            const selectionItems = Array.from(this.inputWrapElm.querySelectorAll('.selection-item'));
            selectionItems.forEach(elm => this.inputWrapElm.removeChild(elm));
        }
        init() {
            const _items = [];
            this.childNodes.forEach(node => {
                if (node instanceof combo_box_item_1.ComboBoxItem) {
                    _items.push({ value: node.value, label: node.label || '' });
                }
            });
            this.clearInnerHTML();
            super.init();
            if (!this.inputElm) {
                this.calculatePositon = this.calculatePositon.bind(this);
                this.callback = this.getAttribute("parentCallback", true);
                const placeholder = this.getAttribute('placeholder', true);
                this.mode = this.getAttribute("mode", true);
                this._items = this.getAttribute("items", true, []);
                this.captionSpanElm = this.createElement("span", this);
                this.labelElm = this.createElement("label", this.captionSpanElm);
                this.inputWrapElm = this.createElement("div", this);
                this.inputWrapElm.classList.add("selection");
                this.inputElm = this.createElement("input", this.inputWrapElm);
                const disabled = this.getAttribute('enabled') === false;
                this.inputElm.disabled = disabled;
                this.readOnly = this.getAttribute('readOnly', true, false);
                this.inputElm.addEventListener("click", (e) => {
                    if (!this._enabled || this._readOnly || this._designMode)
                        return false;
                    this.openList();
                    if (this.onClick)
                        this.onClick(this, e);
                });
                this.inputElm.addEventListener("keyup", () => {
                    if (!this._enabled || this._readOnly || this._designMode)
                        return false;
                    this.searchStr = this.inputElm.value;
                    this.renderItems();
                });
                this.inputWrapElm.appendChild(this.inputElm);
                placeholder && (this.placeholder = placeholder);
                this.iconElm = this.createElement("span", this);
                this.iconElm.classList.add("icon-btn");
                this.iconElm.addEventListener("click", () => {
                    if (!this._enabled || this._readOnly || this._designMode)
                        return false;
                    this.toggleList();
                });
                let iconAttr = this.getAttribute('icon', true, {});
                iconAttr = { ...DEFAULT_VALUES.icon, ...iconAttr };
                if (iconAttr?.image?.url) {
                    iconAttr.name = '';
                }
                const icon = new icon_1.Icon(undefined, iconAttr);
                this.icon = icon;
                const value = this.getAttribute('value', true);
                const selectedItems = this.getAttribute('selectedItems', true);
                const selectedItem = this.getAttribute('selectedItem', true);
                if (selectedItem)
                    this.selectedItem = selectedItem;
                if (selectedItems)
                    this.selectedItems = selectedItems;
                this.listElm = this.createElement("div");
                this.listElm.classList.add(combo_box_css_1.ItemListStyle);
                this.listElm.classList.add("item-list");
                if (_items.length) {
                    this.items = [..._items];
                }
                this.value = value;
                this.renderItems();
                document.addEventListener("click", (e) => {
                    if (!this._enabled)
                        return false;
                    // Clicked outside the box
                    if (!this.contains(e.target))
                        this.closeList();
                });
                window.addEventListener('resize', this.calculatePositon);
            }
        }
        disconnectedCallback() {
            window.removeEventListener('resize', this.calculatePositon);
            super.disconnectedCallback();
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_2.observable)('value')
    ], ComboBox.prototype, "_value", void 0);
    ComboBox = __decorate([
        (0, base_2.customElements)('i-combo-box', {
            icon: 'tasks',
            group: types_1.GroupType.FIELDS,
            className: 'ComboBox',
            props: {
                selectedItem: { type: 'object' },
                selectedItems: {
                    type: 'array',
                    default: []
                },
                items: {
                    type: 'array',
                    default: []
                },
                icon: {
                    type: 'object',
                    default: { name: 'angle-down' }
                },
                mode: {
                    type: 'string',
                    default: DEFAULT_VALUES.mode
                },
                readOnly: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.readOnly
                },
                placeholder: {
                    type: 'string',
                    default: ''
                }
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    items: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: ['value', 'label'],
                            properties: {
                                value: {
                                    type: 'string'
                                },
                                label: {
                                    type: 'string'
                                }
                            }
                        }
                    },
                    placeholder: {
                        type: 'string'
                    },
                    readOnly: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.readOnly
                    },
                    mode: {
                        type: 'string',
                        enum: ['single', 'multiple', 'tags'],
                        default: DEFAULT_VALUES.mode
                    },
                    icon: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string',
                                default: 'angle-down'
                            },
                            fill: {
                                type: 'string'
                            },
                            width: {
                                type: 'number'
                            },
                            height: {
                                type: 'number'
                            },
                            image: {
                                type: 'object',
                                properties: {
                                    url: {
                                        type: 'string'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        })
    ], ComboBox);
    exports.ComboBox = ComboBox;
});
define("@ijstech/combo-box", ["require", "exports", "@ijstech/combo-box/combo-box.ts", "@ijstech/combo-box/combo-box-item.ts"], function (require, exports, combo_box_1, combo_box_item_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboBoxItem = exports.ComboBox = void 0;
    Object.defineProperty(exports, "ComboBox", { enumerable: true, get: function () { return combo_box_1.ComboBox; } });
    Object.defineProperty(exports, "ComboBoxItem", { enumerable: true, get: function () { return combo_box_item_2.ComboBoxItem; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/datepicker/style/datepicker.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-datepicker', {
        display: 'inline-block',
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        '$nest': {
            "*": {
                boxSizing: "border-box",
            },
            '> span': {
                overflow: 'hidden',
            },
            '> span > label': {
                boxSizing: 'border-box',
                color: Theme.text.primary,
                display: 'inline-block',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                verticalAlign: 'middle',
                textAlign: 'right',
                paddingRight: 4,
                height: '100%'
            },
            '> input': {
                borderRadius: "inherit",
                padding: "1px 0.5rem",
                border: `0.5px solid ${Theme.divider}`,
                boxSizing: 'border-box',
                outline: 'none',
                fontSize: 'inherit',
                color: Theme.input.fontColor,
                background: 'transparent',
                verticalAlign: 'top',
                borderTopRightRadius: '0px !important',
                borderBottomRightRadius: '0px !important',
                borderRight: 'none !important',
                height: '100%'
            },
            '> input[type=text]:focus': {
                borderColor: Theme.colors.info.main
            },
            'i-icon': {
                fill: Theme.colors.primary.contrastText,
            },
            '.datepicker-toggle': {
                display: 'inline-flex',
                position: 'relative',
                // backgroundColor: "#6c757d",
                backgroundColor: 'transparent',
                border: `0.5px solid ${Theme.divider}`,
                padding: "7px",
                marginLeft: "-1px",
                cursor: "pointer",
                justifyContent: 'center',
                alignItems: 'center',
                verticalAlign: 'top',
                borderRadius: "inherit",
                borderTopLeftRadius: '0px !important',
                borderBottomLeftRadius: '0px !important',
                height: '100%'
            },
            "> .datepicker-toggle:hover": {
                backgroundColor: "#545b62",
            },
            '.datepicker': {
                position: 'absolute',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%',
                border: 0,
                padding: 0,
                opacity: 0,
                cursor: 'pointer',
            },
            '.datepicker::-webkit-calendar-picker-indicator': {
                position: 'absolute',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%',
                margin: 0,
                padding: 0,
                cursor: 'pointer',
            }
        }
    });
});
define("@ijstech/datepicker/datepicker.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/moment", "@ijstech/style", "@ijstech/types", "@ijstech/application", "@ijstech/datepicker/style/datepicker.css.ts"], function (require, exports, base_1, icon_1, moment_1, style_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Datepicker = void 0;
    const defaultCaptionWidth = 40;
    const DEFAULT_VALUES = {
        type: 'date',
        captionWidth: 0
    };
    let Datepicker = class Datepicker extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                height: 25,
                width: 100
            });
            this._caption = '';
            this._isInternalUpdate = false;
            this._onDatePickerChange = (event) => {
                const pickerValue = this.datepickerElm.value;
                if (!pickerValue) {
                    this.inputElm.placeholder = this.placeholder;
                    this.inputElm.value = '';
                    this.emitChange(event);
                    return;
                }
                // RequireJS.require(['@moment'], (moment: Moment) => {
                let _moment = this._type === 'time' ? (0, moment_1.moment)(pickerValue, 'HH:mm:ss') : (0, moment_1.moment)(pickerValue);
                this.valueFormat = _moment.utc().toISOString();
                this.emitChange(event);
                // })
            };
            // private _dateInputMask = (event: KeyboardEvent) => {
            //     const key: string = event.key;
            //     const isNumeric = key != ' ' && !isNaN(Number(key));
            //     const separator = this._type === 'time' ? ':' : '/';
            //     if (!isNumeric) {
            //         event.preventDefault();
            //     }
            //     var len: number = this.inputElm.value.length;
            //     if (len === 2) {
            //         this.inputElm.value += separator;
            //     }
            //     if (this._type !== 'time' && len === 5) {
            //         this.inputElm.value += separator;
            //     }
            //     if (this._type === 'dateTime') {
            //         if (len === 10) {
            //             this.inputElm.value += ' ';
            //         }
            //         if (len === 13) {
            //             this.inputElm.value += ':';
            //         }
            //     }
            // }
            // private _onFocus = () => {
            //     this.inputElm.placeholder = this.formatString;
            //     if (!this.inputElm.value) return;
            //     if (this.value) {
            //         // For checking isValid
            //         this.inputElm.value = this.value.format(this.defaultDateTimeFormat);
            //     }
            // }
            this._onBlur = (event) => {
                if (this.onBlur) {
                    this.onBlur(this);
                }
                if (!this.inputElm.value) {
                    const oldVal = this.value;
                    this.clear();
                    const isChanged = oldVal !== this.value;
                    if (event && isChanged) {
                        this.emitChange(event);
                    }
                    return;
                }
                ;
                // RequireJS.require(['@moment'], (moment: typeof Moment) => {
                const temp = (0, moment_1.moment)(this.inputElm.value, this.formatString, true).format(this.datepickerFormat);
                const _moment = (0, moment_1.moment)(temp, this.datepickerFormat, true);
                const oldVal = this.value;
                if (this.minDate && _moment.isBefore(this.minDate)) {
                    this.valueFormat = this.minDate.utc().toISOString();
                }
                else {
                    this.valueFormat = _moment.utc().toISOString();
                }
                const isChanged = (oldVal && this.value && !oldVal.isSame(this.value)) || (!oldVal || !this.value);
                if (isChanged)
                    this.emitChange(event);
                // })
            };
        }
        _handleClick(event) {
            return super._handleClick(event, true);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.labelElm && this._caption?.startsWith('$'))
                this.labelElm.textContent = i18n.get(this._caption) || '';
            if (this.inputElm && this._placeholder?.startsWith('$'))
                this.inputElm.placeholder = i18n.get(this._placeholder) || '';
        }
        get caption() {
            return this.getTranslatedText(this._caption || '');
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this.labelElm.style.display = !value ? 'none' : '';
            if (!this.labelElm)
                return;
            this.labelElm.textContent = this.caption;
        }
        get captionWidth() {
            return this.labelElm.offsetWidth;
        }
        set captionWidth(value) {
            this._captionWidth = value;
            this.setElementPosition(this.labelElm, 'width', value);
            const width = this.width - this.captionWidth - (this._iconWidth || 0);
            this.inputElm.style.width = `${width}px`;
        }
        get height() {
            return this.offsetHeight;
        }
        set height(value) {
            this.setPosition('height', value);
        }
        get width() {
            return this.offsetWidth;
        }
        set width(value) {
            this.setPosition('width', value);
            const width = typeof this._width === 'string' ? this._width : `${this._width}px`;
            let captionWidth = typeof this._captionWidth === 'string' ? this._captionWidth : `${this._captionWidth}px`;
            if (!this._caption)
                captionWidth = '0px';
            const iconWidth = `${this._iconWidth || 0}px`;
            this.inputElm.style.width = `calc(${width} - ${captionWidth} - ${iconWidth} - ${this.border.width || '0px'})`;
        }
        set border(value) {
            super.border = value;
            if (this.border.width !== undefined)
                this.width = this._width;
            const hasBorderSide = this.border.bottom || this.border.top || this.border.left || this.border.right;
            if (hasBorderSide || this.border.style) {
                this.toggleElm && (this.toggleElm.style.borderStyle = 'none');
                this.inputElm && (this.inputElm.style.borderStyle = 'none');
            }
        }
        get border() {
            return super.border;
        }
        get value() {
            return this._value;
        }
        set value(value) {
            if (this._isInternalUpdate)
                return;
            if (!value) {
                this.clear();
                return;
            }
            const isSameDate = this._value && value.isSame(this._value);
            if (!isSameDate) {
                this._isInternalUpdate = true;
                this._valueFormat = value.utc().toISOString();
                this.updateValue(value);
                this._isInternalUpdate = false;
            }
        }
        get minDate() {
            return this._minDate;
        }
        set minDate(value) {
            this._minDate = value;
            let strMinDate;
            if (!value) {
                strMinDate = "";
            }
            else {
                strMinDate = value.format("YYYY-MM-DDTHH:mm");
            }
            if (this.datepickerElm)
                this.datepickerElm.min = strMinDate;
        }
        get defaultDateTimeFormat() {
            switch (this._type) {
                case 'date':
                    return 'DD/MM/YYYY';
                case 'dateTime':
                    return 'DD/MM/YYYY HH:mm';
                case 'time':
                    return 'HH:mm';
            }
        }
        get dateTimeFormat() {
            return this._dateTimeFormat ?? '';
        }
        set dateTimeFormat(format) {
            this._dateTimeFormat = format ?? '';
        }
        get datepickerFormat() {
            switch (this._type) {
                case 'date':
                    return 'YYYY-MM-DD';
                case 'dateTime':
                    return 'YYYY-MM-DD\THH:mm:ss';
                case 'time':
                    return 'HH:mm:ss';
            }
        }
        get maxLength() {
            switch (this._type) {
                case 'date':
                    return 10;
                case 'dateTime':
                    return 16;
                case 'time':
                    return 5;
            }
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            this.inputElm.disabled = !value;
            this.datepickerElm.disabled = !value;
        }
        get placeholder() {
            return this.getTranslatedText(this._placeholder || '');
        }
        set placeholder(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._placeholder = value;
            if (this.inputElm)
                this.inputElm.placeholder = this.placeholder;
        }
        getTranslatedText(value) {
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        get type() {
            return this._type;
        }
        set type(value) {
            this._type = value;
            if (this.toggleIconElm) {
                this.toggleIconElm.name = this._type === 'time' ? 'clock' : 'calendar';
            }
            if (this.datepickerElm) {
                const inputType = this._type === 'dateTime' ? 'datetime-local' : this._type;
                this.datepickerElm.setAttribute('type', inputType);
            }
        }
        set designMode(value) {
            this._designMode = value;
            if (this.inputElm) {
                this.inputElm.readOnly = value;
            }
            if (this.datepickerElm) {
                this.datepickerElm.readOnly = value;
            }
        }
        get valueFormat() {
            return this._valueFormat;
        }
        set valueFormat(value) {
            if (this._isInternalUpdate)
                return;
            const newMoment = (0, moment_1.moment)(value);
            if (!newMoment.isValid()) {
                this.clear();
                return;
            }
            if (value !== this._valueFormat) {
                this._isInternalUpdate = true;
                this._valueFormat = value;
                this.updateValue(newMoment);
                this._isInternalUpdate = false;
            }
        }
        get formatString() {
            return this.dateTimeFormat || this.defaultDateTimeFormat;
        }
        emitChange(event) {
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, event);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, event);
        }
        updateValue(value) {
            this.inputElm.placeholder = this.placeholder;
            if (value.isValid()) {
                this._value = value;
                this.inputElm.value = value.format(this.formatString);
                this.datepickerElm.value = value.format(this.datepickerFormat);
                if (this.callback)
                    this.callback(this.inputElm.value);
            }
            else if (this.value) {
                this.inputElm.value = this.value.format(this.formatString);
                this.datepickerElm.value = this.value.format(this.datepickerFormat);
            }
        }
        clear() {
            this._value = undefined;
            this.inputElm.value = '';
            this._valueFormat = '';
            this.datepickerElm.value = '';
            this.callback && this.callback('');
        }
        init() {
            if (!this.captionSpanElm) {
                base_1.RequireJS.config({
                    paths: {
                        '@moment': `${base_1.LibPath}lib/moment/2.29.1/moment.js`
                    }
                });
                this.callback = this.getAttribute("parentCallback", true);
                this.dateTimeFormat = this.getAttribute('dateTimeFormat', true);
                this._type = this.getAttribute('type', true, DEFAULT_VALUES.type);
                const height = this.getAttribute('height', true);
                this._iconWidth = typeof height === 'number' ? height : +(height.replace('px', ''));
                this.captionSpanElm = this.createElement('span', this);
                this.labelElm = this.createElement('label', this.captionSpanElm);
                this.inputElm = this.createElement('input', this);
                this.inputElm.setAttribute('type', 'text');
                this.inputElm.setAttribute('autocomplete', 'disabled');
                this.inputElm.pattern = this.formatString;
                this.placeholder = this.getAttribute('placeholder', true);
                this.toggleElm = this.createElement('span', this);
                this.toggleElm.classList.add('datepicker-toggle');
                this.toggleElm.style.width = this._iconWidth + 'px';
                this.toggleIconElm = new icon_1.Icon(this, {
                    name: this._type === 'time' ? 'clock' : 'calendar',
                    width: 12,
                    height: 12,
                    fill: style_1.Theme.ThemeVars.text.primary
                });
                this.toggleElm.appendChild(this.toggleIconElm);
                this.datepickerElm = this.createElement('input');
                const inputType = this._type === 'dateTime' ? 'datetime-local' : this._type;
                this.datepickerElm.setAttribute('type', inputType);
                this.datepickerElm.classList.add('datepicker');
                this.datepickerElm.addEventListener('input', (event) => {
                    event.stopPropagation();
                    this._onDatePickerChange(event);
                });
                this.toggleElm.appendChild(this.datepickerElm);
                const minDate = this.getAttribute('minDate', true);
                this.minDate = minDate;
                this.caption = this.getAttribute('caption', true);
                this.captionWidth = this.getAttribute('captionWidth', true, this._caption ? defaultCaptionWidth : 0);
                super.init();
                this.valueFormat = this.getAttribute('valueFormat', true);
            }
        }
        _handleBlur(event, stopPropagation) {
            event.stopPropagation();
            event.preventDefault();
            this._onBlur(event);
            return true;
        }
        ;
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('valueFormat')
    ], Datepicker.prototype, "_valueFormat", void 0);
    Datepicker = __decorate([
        (0, base_1.customElements)('i-datepicker', {
            icon: 'calendar',
            group: types_1.GroupType.FIELDS,
            className: 'Datepicker',
            props: {
                caption: { type: 'string', default: '' },
                captionWidth: { type: 'number', default: DEFAULT_VALUES.captionWidth },
                value: { type: 'object' },
                placeholder: { type: 'string', default: '' },
                type: { type: 'string', default: DEFAULT_VALUES.type },
                dateTimeFormat: { type: 'string', default: '' }
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['date', 'dateTime', 'time'],
                        default: DEFAULT_VALUES.type
                    },
                    placeholder: {
                        type: 'string'
                    },
                    caption: {
                        type: 'string'
                    },
                    dateTimeFormat: {
                        type: 'string'
                    }
                }
            }
        })
    ], Datepicker);
    exports.Datepicker = Datepicker;
});
define("@ijstech/datepicker", ["require", "exports", "@ijstech/datepicker/datepicker.ts"], function (require, exports, datepicker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Datepicker = void 0;
    Object.defineProperty(exports, "Datepicker", { enumerable: true, get: function () { return datepicker_1.Datepicker; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/range/style/range.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-range', {
        position: 'relative',
        display: 'inline-block',
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        '$nest': {
            "*": {
                boxSizing: "border-box",
            },
            '> span': {
                overflow: 'hidden',
            },
            '> span > label': {
                boxSizing: 'border-box',
                color: Theme.text.primary,
                display: 'inline-block',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                verticalAlign: 'middle',
                textAlign: 'right',
                paddingRight: 4,
                height: '100%'
            },
            '.slider': {
                position: 'relative',
                display: 'inline-block',
            },
            'input[type="range"]': {
                '-webkit-appearance': 'none',
                appearance: 'none',
                background: '#d3d3d3',
                backgroundImage: `linear-gradient(var(--track-color, ${Theme.colors.info.main}), var(--track-color, ${Theme.colors.info.main}))`,
                backgroundSize: '0% 100%',
                backgroundRepeat: 'no-repeat !important',
                borderRadius: '0.5rem',
                opacity: 0.7,
                border: 0,
                margin: 0,
                width: 'inherit',
                boxSizing: 'border-box',
                outline: 'none',
                verticalAlign: 'middle'
            },
            'input[type="range"]:not(:disabled)': {
                cursor: 'pointer',
            },
            'input[type="range"]:hover': {
                opacity: 1
            },
            'input[type="range"]:focus': {
                outline: 'none',
            },
            'input[type="range"]::-webkit-slider-runnable-track': {
                '-webkit-appearance': 'none',
                boxShadow: 'none',
                border: 'none',
                background: 'transparent',
                borderRadius: '0.5rem',
                height: '0.3rem',
                marginLeft: '-6.5px',
                marginRight: '-6.5px'
            },
            'input[type="range"]::-webkit-slider-thumb': {
                '-webkit-appearance': 'none',
                appearance: 'none',
                marginTop: '-5px',
                backgroundColor: `var(--track-color, ${Theme.colors.info.main})`,
                borderRadius: '0.5rem',
                height: '1rem',
                width: '1rem',
            },
            '.range-labels': {
                display: 'flex',
                justifyContent: 'space-between',
                height: 'auto',
                overflow: 'hidden',
                listStyle: 'none',
            },
            '.range-labels li': {
                padding: '0 0.25rem'
            },
            '&.--step input[type="range"]': {
                opacity: 1,
                $nest: {
                    '&::-webkit-slider-runnable-track': {
                        zIndex: 2
                    },
                    '&::-webkit-slider-thumb': {
                        zIndex: 2
                    }
                }
            },
            '.slider-step': {
                position: "absolute",
                zIndex: 0,
                top: 2,
                left: 0,
                right: 0,
                bottom: 0,
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                background: 'transparent'
            },
            '.step-dot': {
                position: 'relative',
                zIndex: 1,
                display: 'flex',
                justifyContent: 'center',
                width: '3px',
                height: '10px',
                backgroundColor: "#a7a9ac"
            },
            '.tooltip': {
                visibility: 'hidden',
                minWidth: 35,
                maxWidth: 70,
                overflowWrap: 'break-word',
                backgroundColor: 'rgba(0, 0, 0, 0.78)',
                color: '#fff',
                textAlign: 'center',
                borderRadius: '6px',
                padding: '8px',
                position: 'absolute',
                zIndex: 1,
                bottom: '150%',
                left: '0%',
                marginLeft: '-20px',
                opacity: 0,
                transition: 'opacity 0.3s',
                $nest: {
                    '&::after': {
                        content: "''",
                        position: 'absolute',
                        top: '100%',
                        left: '50%',
                        marginLeft: '-5px',
                        borderWidth: '5px',
                        borderStyle: 'solid',
                        borderColor: 'rgba(0, 0, 0, 0.78) transparent transparent transparent'
                    }
                }
            },
            'input[type="range"]:hover + .tooltip': {
                visibility: 'visible',
                opacity: 1,
            }
        }
    });
});
define("@ijstech/range/range.ts", ["require", "exports", "@ijstech/base", "@ijstech/application", "@ijstech/types", "@ijstech/range/style/range.css.ts"], function (require, exports, base_1, application_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Range = void 0;
    const DEFAULT_VALUES = {
        captionWidth: 40,
        value: 0,
        min: 0,
        max: 100,
        step: 1,
        stepDots: false,
        tooltipVisible: false
    };
    let Range = class Range extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                height: 25,
                width: 100
            });
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.labelElm && this._caption?.startsWith('$'))
                this.labelElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            const value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(this._caption) ||
                    application_1.application.i18n?.get(this._caption) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this.labelElm.style.display = !value ? 'none' : '';
            if (!this.labelElm)
                return;
            this.labelElm.textContent = this.caption;
        }
        get captionWidth() {
            return this.labelElm.offsetWidth;
        }
        set captionWidth(value) {
            this._captionWidth = value;
            this.setElementPosition(this.labelElm, 'width', value);
            const captionWidth = this.caption ? this.captionWidth : 0;
            const width = this.width - captionWidth;
            this.inputContainerElm.style.width = `${width}px`;
            // if (this.labels) {
            //   this.rangeLabelListElm.style.paddingLeft = captionWidth;
            // }
        }
        get value() {
            return this._value;
        }
        set value(value) {
            if (value === null)
                value = +this.inputElm.min;
            this._value = value;
            this.inputElm.value = value.toString();
            const min = Number(this.inputElm.min);
            const max = Number(this.inputElm.max);
            this.inputElm.style.backgroundSize = (this._value - min) * 100 / (max - min) + '% 100%';
            this.onUpdateTooltip(false);
            if (this.callback)
                this.callback(value);
        }
        get width() {
            return this.offsetWidth;
        }
        set width(value) {
            this.setPosition('width', value);
            const width = typeof value === 'string' ? value : `${value}px`;
            let captionWidth = typeof this._captionWidth === 'string' ? this._captionWidth : `${this._captionWidth}px`;
            if (!this.caption)
                captionWidth = '0px';
            this.inputContainerElm.style.width = `calc(${width} - ${captionWidth})`;
            // if (this.labels) {
            //   this.rangeLabelListElm.style.paddingLeft = captionWidth;
            // }
        }
        // get _ratio(): number {
        //   var min = this.inputElm.min === '' ? 0 : parseInt(this.inputElm.min);
        //   var max = this.inputElm.max === '' ? 100 : parseInt(this.inputElm.max);
        //   return (this.value - min) / (max - min);
        // }
        // get labels(): string[] {
        //   return this._labels;
        // }
        // set labels(labels: string[]) {
        //   this._labels = labels;
        // }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            this.inputElm.disabled = !value;
        }
        set designMode(value) {
            this._designMode = value;
            if (this.inputElm) {
                this.inputElm.disabled = value || this.enabled === false;
            }
        }
        get tooltipVisible() {
            return this._tooltipVisible;
        }
        set tooltipVisible(value) {
            this._tooltipVisible = value;
            this.tooltipElm.style.display = value ? 'block' : 'none';
        }
        get trackColor() {
            return this._trackColor;
        }
        set trackColor(value) {
            this._trackColor = value;
            if (value)
                this.style.setProperty('--track-color', value);
            else
                this.style.removeProperty('--track-color');
        }
        get min() {
            return Number(this.inputElm.min) || 0;
        }
        set min(value) {
            this.inputElm.min = value.toFixed();
        }
        get max() {
            return Number(this.inputElm.max) || 0;
        }
        set max(value) {
            this.inputElm.max = value.toFixed();
        }
        get step() {
            return Number(this.inputElm.step) || 0;
        }
        set step(value) {
            this.inputElm.step = value.toFixed();
        }
        onSliderChange(event) {
            if (this._designMode) {
                event.preventDefault();
                return false;
            }
            this.value = +this.inputElm.value;
            const min = Number(this.inputElm.min);
            const max = Number(this.inputElm.max);
            this.inputElm.style.backgroundSize = (this._value - min) * 100 / (max - min) + '% 100%';
            if (typeof this.onChanged === 'function')
                this.onChanged(this, event);
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, event);
            this.onUpdateTooltip(false);
        }
        // renderLabels() {
        //   this.labels.forEach((label: string) => {
        //     const labelElm = <HTMLElement>this.createElement('li', this.rangeLabelListElm);
        //     labelElm.innerHTML = label;
        //   })
        // }
        onUpdateTooltip(init) {
            let inputValue = this._value;
            let formattedValue = typeof this.tooltipFormatter === 'function' ? this.tooltipFormatter(inputValue) : inputValue;
            const min = Number(this.inputElm.min);
            const max = Number(this.inputElm.max);
            if (init) {
                this.tooltipElm.style.marginLeft = `-${this.tooltipElm.clientWidth / 2}px`;
            }
            this.tooltipElm.textContent = `${formattedValue}`;
            this.tooltipElm.style.left = (this._value - min) * 100 / (max - min) + '%';
        }
        init() {
            if (!this.captionSpanElm) {
                this.callback = this.getAttribute("parentCallback", true);
                const min = this.getAttribute("min", true, DEFAULT_VALUES.min);
                const max = this.getAttribute("max", true, DEFAULT_VALUES.max);
                // const labels = this.getAttribute("labels", true) || '';
                const step = this.getAttribute("step", true, DEFAULT_VALUES.step);
                const stepDots = this.getAttribute("stepDots", true, DEFAULT_VALUES.stepDots);
                const tooltipVisible = this.getAttribute("tooltipVisible", true, DEFAULT_VALUES.tooltipVisible);
                this.tooltipFormatter = this.getAttribute("tooltipFormatter", true) || this.tooltipFormatter;
                this.captionSpanElm = this.createElement('span', this);
                this.labelElm = this.createElement('label', this.captionSpanElm);
                this.inputContainerElm = this.createElement('div', this);
                this.inputContainerElm.classList.add("slider");
                this.inputElm = this.createElement('input', this.inputContainerElm);
                this.inputElm.setAttribute('autocomplete', 'disabled');
                this.inputElm.type = 'range';
                this.inputElm.min = min;
                this.inputElm.max = max;
                this.inputElm.disabled = this._designMode || this.enabled === false;
                if (step !== 0) {
                    this.inputElm.step = step;
                }
                this.inputElm.addEventListener('input', this.onSliderChange.bind(this));
                if (this.onMouseUp)
                    this.inputElm.addEventListener('mouseup', (e) => {
                        if (this._designMode) {
                            e.preventDefault();
                            return false;
                        }
                        this.onMouseUp(this, e);
                    });
                if (this.onKeyUp)
                    this.inputElm.addEventListener('keyup', (e) => {
                        if (this._designMode) {
                            e.preventDefault();
                            return false;
                        }
                        const keys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'PageUp', 'PageDown'];
                        if (keys.includes(e.key))
                            this.onKeyUp(this, e);
                    });
                this.tooltipElm = this.createElement('span', this.inputContainerElm);
                this.tooltipElm.classList.add('tooltip');
                this.tooltipVisible = tooltipVisible || this.tooltipFormatter || false;
                this.captionWidth = this.getAttribute('captionWidth', true, DEFAULT_VALUES.captionWidth);
                this.caption = this.getAttribute('caption', true);
                if (stepDots) {
                    this.classList.add('--step');
                    const stepContainer = this.createElement('div', this);
                    stepContainer.classList.add('slider-step');
                    stepContainer.style.width = '100%';
                    if (this.caption) {
                        stepContainer.style.paddingLeft = this.captionWidth + "px";
                    }
                    const dotNums = typeof stepDots === 'boolean' ? (max - min) / (step || 1) + 1 : stepDots;
                    for (let i = 0; i < dotNums; i++) {
                        const dotElm = this.createElement('span', stepContainer);
                        dotElm.classList.add('step-dot');
                    }
                }
                this.value = this.getAttribute('value', true, DEFAULT_VALUES.value);
                if (this._value > 0) {
                    this.inputElm.style.backgroundSize = (this._value - min) * 100 / (max - min) + '% 100%';
                }
                const trackColor = this.getAttribute('trackColor', true);
                if (trackColor !== undefined)
                    this.trackColor = trackColor;
                // if (labels) {
                //   this.rangeLabelListElm = <HTMLUListElement>this.createElement('ul', this);
                //   this.rangeLabelListElm.classList.add('range-labels');
                //   this.rangeLabelListElm.style.paddingLeft = this.captionWidth + 'px';
                //   this.labels = JSON.parse(labels);
                //   this.renderLabels();
                // }
                this.onUpdateTooltip(true);
                super.init();
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('value')
    ], Range.prototype, "_value", void 0);
    Range = __decorate([
        (0, base_1.customElements)("i-range", {
            icon: 'sliders-h',
            group: types_1.GroupType.FIELDS,
            className: 'Range',
            props: {
                caption: { type: 'string', default: '' },
                captionWidth: { type: 'number', default: DEFAULT_VALUES.captionWidth },
                value: { type: 'number', default: DEFAULT_VALUES.value },
                min: { type: 'number', default: DEFAULT_VALUES.min },
                max: { type: 'number', default: DEFAULT_VALUES.max },
                step: { type: 'number', default: DEFAULT_VALUES.step },
                stepDots: { type: 'boolean', default: DEFAULT_VALUES.stepDots },
                tooltipVisible: { type: 'boolean', default: DEFAULT_VALUES.tooltipVisible },
                trackColor: { type: 'string', default: '' }
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    caption: { type: 'string' },
                    value: { type: 'number', default: DEFAULT_VALUES.value },
                    min: { type: 'number', default: DEFAULT_VALUES.min },
                    max: { type: 'number', default: DEFAULT_VALUES.max },
                    step: { type: 'number', default: DEFAULT_VALUES.step },
                    stepDots: { type: 'boolean', default: DEFAULT_VALUES.stepDots },
                    tooltipVisible: { type: 'boolean', default: DEFAULT_VALUES.tooltipVisible },
                    trackColor: { type: 'string', format: 'color' }
                }
            }
        })
    ], Range);
    exports.Range = Range;
});
define("@ijstech/range", ["require", "exports", "@ijstech/range/range.ts"], function (require, exports, range_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Range = void 0;
    Object.defineProperty(exports, "Range", { enumerable: true, get: function () { return range_1.Range; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/radio/radio.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.captionStyle = void 0;
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-radio-group', {
        display: 'inline-flex',
        alignItems: 'start',
        gap: '5px',
        '$nest': {
            '.radio-wrapper': {
                display: 'inline-flex',
                alignItems: 'baseline',
                cursor: 'pointer',
            },
            'input[type="radio"]': {
                cursor: 'pointer',
            }
        }
    });
    exports.captionStyle = Styles.style({
        fontFamily: Theme.typography.fontFamily,
        fontSize: 'inherit',
        '$nest': {
            'span': {
                color: Theme.text.primary
            }
        },
    });
});
define("@ijstech/radio/radio.ts", ["require", "exports", "@ijstech/base", "@ijstech/style", "@ijstech/radio/radio.css.ts", "@ijstech/types", "@ijstech/application"], function (require, exports, base_1, style_1, radio_css_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadioGroup = exports.Radio = void 0;
    let Radio = class Radio extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
        }
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value || '';
            this.inputElm.value = value;
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionSpanElm && this._caption?.startsWith('$'))
                this.captionSpanElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            const value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(this._caption) ||
                    application_1.application.i18n?.get(this._caption) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value);
            this._caption = value || '';
            if (!this.captionSpanElm)
                return;
            this.captionSpanElm.textContent = this.caption;
        }
        get captionWidth() {
            return this._captionWidth;
        }
        set captionWidth(value) {
            this._captionWidth = value;
            this.setElementPosition(this.captionSpanElm, 'width', value);
        }
        set font(value) {
            if (!this.captionSpanElm)
                return;
            this.captionSpanElm.style.color = value.color || '';
            this.captionSpanElm.style.fontSize = value.size || '';
            this.captionSpanElm.style.fontFamily = value.name || '';
            this.captionSpanElm.style.fontStyle = value.style || '';
            this.captionSpanElm.style.textTransform = value.transform || 'none';
            this.captionSpanElm.style.fontWeight = value.bold ? 'bold' : `${value.weight || ''}`;
            this.captionSpanElm.style.textShadow = value.shadow || 'none';
        }
        get font() {
            if (!this.captionSpanElm)
                return {};
            return {
                color: this.captionSpanElm.style.color,
                name: this.captionSpanElm.style.fontFamily,
                size: this.captionSpanElm.style.fontSize,
                bold: this.captionSpanElm.style.fontStyle.indexOf('bold') >= 0,
                style: this.captionSpanElm.style.fontStyle,
                transform: this.captionSpanElm.style.textTransform,
                weight: this.captionSpanElm.style.fontWeight,
                shadow: this.captionSpanElm.style.textShadow
            };
        }
        add(item) {
            item.parent = this.labelElm;
            this.labelElm.appendChild(item);
            return item;
        }
        _handleClick(event) {
            if (this._designMode) {
                event.preventDefault();
                return false;
            }
            if (event.target !== this.inputElm)
                return true;
            const checked = this.inputElm.checked || false;
            if (checked)
                this.classList.add('is-checked');
            else
                this.classList.remove('is-checked');
            return super._handleClick(event);
        }
        init() {
            if (!this.labelElm) {
                const items = [];
                if (this.children.length > 0) {
                    for (const child of this.children) {
                        if (child instanceof base_1.Control) {
                            items.push(child);
                        }
                    }
                }
                super.init();
                this.classList.add(radio_css_1.captionStyle);
                this.labelElm = this.createElement('label', this);
                this.labelElm.classList.add('radio-wrapper');
                this.inputElm = this.createElement('input', this.labelElm);
                this.inputElm.type = 'radio';
                const disabled = this.getAttribute('enabled') === false;
                this.inputElm.disabled = disabled;
                this.value = this.getAttribute('value');
                this.captionSpanElm = this.createElement('span', this.labelElm);
                this.captionSpanElm.classList.add('i-radio_label');
                this.caption = this.getAttribute('caption', true, '');
                this.captionWidth = this.getAttribute('captionWidth', true);
                const font = this.getAttribute('font', true);
                if (font)
                    this.font = font;
                else
                    this.labelElm.style.color = style_1.Theme.ThemeVars.text.primary;
                if (items.length) {
                    for (const child of items) {
                        this.labelElm.appendChild(child);
                    }
                }
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Radio = __decorate([
        (0, base_1.customElements)('i-radio', {
            icon: 'check-circle',
            className: 'Radio',
            group: types_1.GroupType.FIELDS,
            props: {
                value: {
                    type: 'string',
                    default: ''
                },
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    value: {
                        type: 'string'
                    }
                }
            }
        })
    ], Radio);
    exports.Radio = Radio;
    let RadioGroup = class RadioGroup extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this._radioItems = [];
            this._group = [];
        }
        get selectedValue() {
            return this._selectedValue;
        }
        set selectedValue(value) {
            this._selectedValue = value;
            this._group.forEach((item) => {
                const inputElm = item.querySelector('input');
                if (inputElm)
                    inputElm.checked = item.value === value;
                if (item.value === value) {
                    item.classList.add('is-checked');
                }
                else {
                    item.classList.remove('is-checked');
                }
            });
        }
        get radioItems() {
            return this._radioItems;
        }
        set radioItems(value) {
            this._radioItems = value;
            this.renderUI();
        }
        get layout() {
            return this._layout || 'vertical';
        }
        set layout(value) {
            this._layout = value || 'vertical';
            if (value === 'horizontal') {
                this.style.flexDirection = 'row';
            }
            else {
                this.style.flexDirection = 'column';
            }
        }
        renderUI() {
            const newGroup = [];
            for (const radio of this._group) {
                if (radio.tag === 'added') {
                    newGroup.push(radio);
                }
                else {
                    radio.remove();
                }
            }
            this._group = newGroup;
            if (!this.name)
                this.name = new Date().getTime().toString();
            this.radioItems.forEach((item) => {
                const elm = new Radio(this, item);
                this.appendItem(elm);
            });
        }
        appendItem(elm) {
            this.appendChild(elm);
            elm.onClick = this._handleChange.bind(this);
            const inputElm = elm.getElementsByTagName('input')[0];
            inputElm && inputElm.setAttribute('name', this.name);
            if (this.selectedValue && elm.value === this.selectedValue)
                inputElm.checked = true;
            this._group.push(elm);
        }
        _handleChange(source, event) {
            if (this._designMode) {
                event.preventDefault();
                return true;
            }
            event.stopPropagation();
            const selectedValue = this.selectedValue;
            const value = source.value;
            this._selectedValue = value;
            this._group.forEach(item => item.classList.remove('is-checked'));
            source.classList.add('is-checked');
            if (selectedValue !== value) {
                if (typeof this.onChanged === 'function')
                    this.onChanged(this, event);
                if (typeof this.onObserverChanged === 'function')
                    this.onObserverChanged(this, event);
            }
        }
        add(options) {
            if (!this.name) {
                this.name = new Date().getTime().toString();
            }
            const elm = new Radio(this, options);
            elm.tag = 'added';
            options.tag = 'added';
            this.appendItem(elm);
            this._radioItems.push(options);
            return elm;
        }
        delete(index) {
            if (index >= 0) {
                const radio = this._group[index];
                if (radio) {
                    this._group.splice(index, 1);
                    this._radioItems.splice(index, 1);
                    radio.remove();
                }
            }
        }
        init() {
            if (!this.initialized) {
                const radios = [];
                if (this.children.length > 0) {
                    for (const child of this.children) {
                        if (child instanceof Radio) {
                            radios.push(child);
                        }
                    }
                }
                this.setAttribute('role', 'radiogroup');
                if (this.options?.onChanged)
                    this.onChanged = this.options.onChanged;
                (0, base_1.setAttributeToProperty)(this, 'selectedValue');
                (0, base_1.setAttributeToProperty)(this, 'layout', 'vertical');
                if (radios.length) {
                    this.clearInnerHTML();
                    this._group = [];
                    this._radioItems = [];
                    for (const radio of radios) {
                        this._radioItems.push({
                            caption: radio.caption,
                            value: radio.value
                        });
                        if (!this.name)
                            this.name = new Date().getTime().toString();
                        this.appendItem(radio);
                    }
                }
                else {
                    (0, base_1.setAttributeToProperty)(this, 'radioItems');
                }
                super.init();
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('selectedValue')
    ], RadioGroup.prototype, "_selectedValue", void 0);
    RadioGroup = __decorate([
        (0, base_1.customElements)("i-radio-group", {
            icon: 'check-circle',
            className: 'RadioGroup',
            group: types_1.GroupType.FIELDS,
            props: {
                layout: {
                    type: 'string',
                    default: 'vertical',
                },
                selectedValue: { type: 'string', default: '' },
                radioItems: { type: 'array', default: [] },
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    layout: {
                        type: 'string',
                        enum: ['vertical', 'horizontal'],
                        default: 'vertical'
                    },
                    radioItems: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                caption: { type: 'string' },
                                value: { type: 'string' }
                            }
                        }
                    },
                }
            }
        })
    ], RadioGroup);
    exports.RadioGroup = RadioGroup;
});
define("@ijstech/radio", ["require", "exports", "@ijstech/radio/radio.ts"], function (require, exports, radio_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadioGroup = exports.Radio = void 0;
    Object.defineProperty(exports, "Radio", { enumerable: true, get: function () { return radio_1.Radio; } });
    Object.defineProperty(exports, "RadioGroup", { enumerable: true, get: function () { return radio_1.RadioGroup; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/modal/style/modal.css.ts", ["require", "exports", "@ijstech/base", "@ijstech/style"], function (require, exports, base_1, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getModalMediaQueriesStyleClass = exports.titleStyle = exports.getBodyStyle = exports.modalStyle = exports.getModalStyle = exports.getAbsoluteWrapperStyle = exports.getFixedWrapperStyle = exports.getNoBackdropStyle = exports.getWrapperStyle = exports.getOverlayStyle = void 0;
    let Theme = Styles.Theme.ThemeVars;
    const zIndex = 900;
    const getOverlayStyle = () => {
        return Styles.style({
            backgroundColor: 'rgba(12, 18, 52, 0.7)',
            position: 'fixed',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            opacity: 0,
            visibility: 'hidden',
            zIndex: zIndex,
            transition: 'visibility 0s linear .25s, opacity .25s',
            $nest: {
                '&.show': {
                    opacity: '1',
                    visibility: 'visible',
                    transition: 'visibility 0s linear, opacity .25s'
                }
            }
        });
    };
    exports.getOverlayStyle = getOverlayStyle;
    const getWrapperStyle = () => {
        return Styles.style({
            position: 'fixed',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            opacity: 0,
            visibility: 'hidden',
            transform: 'scale(0.8)',
            transition: 'visibility 0s linear .25s,opacity .25s 0s,transform .25s',
            zIndex: zIndex,
            overflow: 'auto',
            $nest: {
                '&.show': {
                    opacity: '1',
                    visibility: 'visible',
                    transform: 'scale(1)',
                    transition: 'visibility 0s linear 0s,opacity .25s 0s,transform .25s'
                }
            }
        });
    };
    exports.getWrapperStyle = getWrapperStyle;
    const getNoBackdropStyle = () => {
        return Styles.style({
            position: 'inherit',
            top: 0,
            left: 0,
            opacity: 0,
            visibility: 'hidden',
            transform: 'scale(0.8)',
            transition: 'visibility 0s linear .25s,opacity .25s 0s,transform .25s',
            zIndex: zIndex,
            // overflow: 'auto',
            // width: '100%',
            maxWidth: 'inherit',
            $nest: {
                '.modal': {
                    margin: '0'
                },
                '&.show': {
                    opacity: '1',
                    visibility: 'visible',
                    transform: 'scale(1)',
                    transition: 'visibility 0s linear 0s,opacity .25s 0s,transform .25s'
                }
            }
        });
    };
    exports.getNoBackdropStyle = getNoBackdropStyle;
    const getFixedWrapperStyle = (paddingLeft, paddingTop) => {
        return Styles.style({
            paddingLeft: paddingLeft,
            paddingTop: paddingTop,
            width: '100%',
            height: '100%'
        });
    };
    exports.getFixedWrapperStyle = getFixedWrapperStyle;
    const getAbsoluteWrapperStyle = (left, top) => {
        return Styles.style({
            left: left,
            top: top,
            width: 'inherit',
            height: 'inherit'
        });
    };
    exports.getAbsoluteWrapperStyle = getAbsoluteWrapperStyle;
    const getModalStyle = (left, top) => {
        return Styles.style({
            left: left,
            top: top
        });
    };
    exports.getModalStyle = getModalStyle;
    exports.modalStyle = Styles.style({
        fontFamily: 'Helvetica',
        fontSize: '14px',
        padding: '10px 10px 5px 10px',
        backgroundColor: Theme.background.modal,
        position: 'relative',
        // margin: '0 auto 30px',
        borderRadius: '2px',
        // minWidth: '300px',
        width: 'inherit',
        maxWidth: '100%'
    });
    exports.getBodyStyle = Styles.style({
        height: '100%',
        overflow: 'hidden'
    });
    exports.titleStyle = Styles.style({
        fontSize: '18px',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        $nest: {
            'span': {
                color: Theme.colors.primary.main
            },
            'i-icon': {
                display: 'inline-block',
                cursor: 'pointer'
            }
        }
    });
    const getModalMediaQueriesStyleClass = (mediaQueries) => {
        let styleObj = (0, base_1.getControlMediaQueriesStyle)(mediaQueries);
        for (let mediaQuery of mediaQueries) {
            let mediaQueryRule = (0, base_1.getMediaQueryRule)(mediaQuery);
            if (mediaQueryRule) {
                const nestObj = styleObj['$nest'][mediaQueryRule]['$nest'] || {};
                const ruleObj = styleObj['$nest'][mediaQueryRule];
                styleObj['$nest'][mediaQueryRule] = {
                    ...ruleObj,
                    $nest: {
                        ...nestObj,
                        '&.show > .modal-overlay': {},
                        '.modal-wrapper': {},
                        '.modal': {}
                    }
                };
                const { showBackdrop, padding, position, maxWidth: maxWidthValue, maxHeight: maxHeightValue, minWidth: minWidthValue, width: widthValue, height: heightValue, popupPlacement, overflow, border } = mediaQuery.properties || {};
                if (showBackdrop) {
                    if (showBackdrop) {
                        styleObj['$nest'][mediaQueryRule]['$nest']['&.show > .modal-overlay']['visibility'] = 'visible !important';
                        styleObj['$nest'][mediaQueryRule]['$nest']['&.show > .modal-overlay']['opacity'] = '1 !important';
                    }
                    else {
                        styleObj['$nest'][mediaQueryRule]['$nest']['&.show > .modal-overlay']['visibility'] = 'hidden !important';
                        styleObj['$nest'][mediaQueryRule]['$nest']['&.show > .modal-overlay']['opacity'] = '0 !important';
                    }
                }
                if (position) {
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal-wrapper']['position'] = `${position} !important`;
                }
                if (maxWidthValue !== undefined && maxWidthValue !== null) {
                    const maxWidth = `${(0, base_1.getSpacingValue)(maxWidthValue)} !important`;
                    styleObj['$nest'][mediaQueryRule]['maxWidth'] = maxWidth;
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['maxWidth'] = maxWidth;
                }
                if (maxHeightValue !== undefined && maxHeightValue !== null) {
                    const maxHeight = `${(0, base_1.getSpacingValue)(maxHeightValue)} !important`;
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['maxHeight'] = maxHeight;
                }
                if (heightValue !== undefined && heightValue !== null) {
                    const height = `${(0, base_1.getSpacingValue)(heightValue)} !important`;
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['height'] = height;
                }
                if (widthValue !== undefined && widthValue !== null) {
                    const width = `${(0, base_1.getSpacingValue)(widthValue)} !important`;
                    styleObj['$nest'][mediaQueryRule]['width'] = width;
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['width'] = width;
                }
                if (minWidthValue !== undefined && minWidthValue !== null) {
                    const minWidth = `${(0, base_1.getSpacingValue)(minWidthValue)} !important`;
                    styleObj['$nest'][mediaQueryRule]['minWidth'] = minWidth;
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['minWidth'] = minWidth;
                }
                if (popupPlacement) {
                    const placement = popupPlacement;
                    let positionObj = {
                        top: 'unset',
                        left: 'unset',
                        right: 'unset',
                        bottom: 'unset'
                    };
                    if (placement === 'bottom') {
                        positionObj.top = 'auto !important';
                        positionObj.left = '0 !important';
                        positionObj.bottom = '0 !important';
                    }
                    else if (placement === 'top') {
                        positionObj.top = '0 !important';
                        positionObj.left = '0 !important';
                    }
                    else if (placement === 'center') {
                        positionObj.top = '50% !important';
                        positionObj.left = '50% !important';
                    }
                    for (let pos in positionObj) {
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal-wrapper'][pos] = positionObj[pos];
                    }
                }
                if (border) {
                    const { radius, width, style, color, bottom, top, left, right } = border;
                    if (width !== undefined && width !== null)
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['border'] = `${width || ''} ${style || ''} ${color || ''}!important`;
                    if (radius) {
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal-wrapper']['borderRadius'] = 'inherit';
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['borderRadius'] = `${(0, base_1.getSpacingValue)(radius)} !important`;
                    }
                    if (bottom)
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['borderBottom'] = `${(0, base_1.getSpacingValue)(bottom.width || '')} ${bottom.style || ''} ${bottom.color || ''}!important`;
                    if (top)
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['borderTop'] = `${(0, base_1.getSpacingValue)(top.width || '') || ''} ${top.style || ''} ${top.color || ''}!important`;
                    if (left)
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['borderLeft'] = `${(0, base_1.getSpacingValue)(left.width || '')} ${left.style || ''} ${left.color || ''}!important`;
                    if (right)
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['borderRight'] = `${(0, base_1.getSpacingValue)(right.width || '')} ${right.style || ''} ${right.color || ''}!important`;
                }
                if (padding) {
                    const { top = 0, right = 0, bottom = 0, left = 0 } = padding;
                    styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['padding'] = `${(0, base_1.getSpacingValue)(top)} ${(0, base_1.getSpacingValue)(right)} ${(0, base_1.getSpacingValue)(bottom)} ${(0, base_1.getSpacingValue)(left)} !important`;
                }
                if (overflow) {
                    if (typeof overflow === 'string') {
                        styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['overflow'] = `${overflow} !important`;
                    }
                    else {
                        const { x, y } = overflow || {};
                        if (x === y) {
                            styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['overflow'] = `${x} !important`;
                        }
                        else {
                            if (x)
                                styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['overflowX'] = `${x} !important`;
                            if (y)
                                styleObj['$nest'][mediaQueryRule]['$nest']['.modal']['overflowY'] = `${y} !important`;
                        }
                    }
                }
            }
        }
        return Styles.style(styleObj);
    };
    exports.getModalMediaQueriesStyleClass = getModalMediaQueriesStyleClass;
});
define("@ijstech/modal/modal.ts", ["require", "exports", "@ijstech/base", "@ijstech/base", "@ijstech/icon", "@ijstech/style", "@ijstech/modal/style/modal.css.ts", "@ijstech/types", "@ijstech/application"], function (require, exports, base_2, base_3, icon_1, Styles, modal_css_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Modal = void 0;
    const Theme = Styles.Theme.ThemeVars;
    const showEvent = new Event('show');
    const DEFAULT_VALUES = {
        showBackdrop: true,
        popupPlacement: 'center',
        closeOnBackdropClick: true,
        isChildFixed: false,
        closeOnScrollChildFixed: false
    };
    let Modal = class Modal extends base_2.Container {
        constructor(parent, options) {
            super(parent, options, {
                showBackdrop: true,
                closeOnBackdropClick: true,
                popupPlacement: 'center'
            });
            this._visible = false;
            this._title = '';
            this.hasInitializedChildFixed = false;
            this.mapScrollTop = {};
            this.boundHandleModalMouseDown = this.handleModalMouseDown.bind(this);
            this.boundHandleModalMouseUp = this.handleModalMouseUp.bind(this);
        }
        get visible() {
            return this._visible;
        }
        set visible(value) {
            if (value) {
                this._visible = true;
                this.style.display = 'block';
                this.wrapperDiv.classList.add('show');
                this.positionAtChildFixed(true);
                this.dispatchEvent(showEvent);
                if (this.showBackdrop) {
                    this.overlayDiv.classList.add('show');
                    document.body.style.overflow = 'hidden';
                    const parentModal = this.parentElement?.closest('i-modal');
                    if (parentModal) {
                        parentModal.wrapperDiv.style.overflow = 'hidden';
                        parentModal.wrapperDiv.scrollTop = 0;
                    }
                    this.wrapperDiv.style.overflow = 'hidden auto';
                }
                document.addEventListener('mousedown', this.boundHandleModalMouseDown);
                document.addEventListener('mouseup', this.boundHandleModalMouseUp);
            }
            else {
                this.positionAtChildFixed(false);
                this._visible = false;
                this.style.display = 'none';
                this.wrapperDiv.classList.remove('show');
                this.overlayDiv.classList.remove('show');
                if (this.showBackdrop) {
                    const parentModal = this.parentElement?.closest('i-modal');
                    if (parentModal) {
                        parentModal.wrapperDiv.style.overflow = 'hidden auto';
                        document.body.style.overflow = parentModal.visible ? 'hidden' : 'hidden auto';
                    }
                    else {
                        document.body.style.overflow = 'hidden auto';
                    }
                }
                if (this.isChildFixed) {
                    this.wrapperDiv.style.display = 'none';
                }
                if (typeof this.onClose === 'function')
                    this.onClose(this);
                document.removeEventListener('mousedown', this.boundHandleModalMouseDown);
                document.removeEventListener('mouseup', this.boundHandleModalMouseUp);
            }
        }
        get onOpen() {
            return this._onOpen;
        }
        set onOpen(callback) {
            this._onOpen = callback;
        }
        get title() {
            return this.getTranslatedText(this._title || '');
        }
        set title(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._title = value;
            const titleElm = this.titleSpan.querySelector('span');
            titleElm && (titleElm.textContent = this.title);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            const titleElm = this.titleSpan.querySelector('span');
            if (titleElm && this._title?.startsWith('$'))
                titleElm.textContent = i18n.get(this._title) || '';
        }
        getTranslatedText(value) {
            const parent = this._parent || this.linkTo || this.parentElement;
            if (!value)
                return '';
            if (value?.startsWith('$')) {
                const translated = parent?.parentModule?.i18n?.get(value) ||
                    this.body?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        get popupPlacement() {
            return this._placement;
        }
        set popupPlacement(value) {
            this._placement = value;
        }
        get closeIcon() {
            return this._closeIcon;
        }
        set closeIcon(elm) {
            if (this._closeIcon && this.titleSpan.contains(this._closeIcon))
                this.titleSpan.removeChild(this._closeIcon);
            this._closeIcon = elm;
            if (this._closeIcon) {
                this._closeIcon.classList.add('i-modal-close');
                this._closeIcon.onClick = () => this.visible = false;
                this.titleSpan.appendChild(this._closeIcon);
            }
        }
        get closeOnBackdropClick() {
            return this._closeOnBackdropClick;
        }
        set closeOnBackdropClick(value) {
            this._closeOnBackdropClick = typeof value === 'boolean' ? value : true;
        }
        get showBackdrop() {
            return this._showBackdrop;
        }
        set showBackdrop(value) {
            this._showBackdrop = typeof value === 'boolean' ? value : true;
            if (this._showBackdrop) {
                const wrapperStyle = (0, modal_css_1.getWrapperStyle)();
                this.setTargetStyle(this.wrapperDiv, 'showBackdrop', wrapperStyle);
                this.style.position = 'unset';
            }
            else {
                this.updateNoBackdropMd();
                const noBackdropStyle = (0, modal_css_1.getNoBackdropStyle)();
                this.setTargetStyle(this.wrapperDiv, 'showBackdrop', noBackdropStyle);
            }
        }
        updateNoBackdropMd() {
            if (!this.showBackdrop) {
                this.style.position = 'absolute';
                let left = '0px';
                let parent = this._parent || this.linkTo || this.parentElement || document.body;
                const isOutside = !(parent instanceof Range) && !parent?.contains(this);
                let top = `${isOutside ? window.scrollY : 0}px`;
                this.setTargetStyle(this, 'modal', (0, modal_css_1.getModalStyle)(left, top));
            }
        }
        get item() {
            return this.modalDiv.children[0];
        }
        set item(value) {
            if (value instanceof base_2.Control) {
                this.modalDiv.innerHTML = '';
                value && this.modalDiv.appendChild(value);
            }
        }
        get body() {
            return this.bodyDiv?.children?.[0];
        }
        set body(value) {
            if (value instanceof base_2.Control) {
                this.bodyDiv.innerHTML = '';
                value && this.bodyDiv.appendChild(value);
            }
        }
        get position() {
            return this._wrapperPositionAt;
        }
        set position(value) {
            this._wrapperPositionAt = value;
        }
        get isChildFixed() {
            return this._isChildFixed;
        }
        set isChildFixed(value) {
            this._isChildFixed = value;
            if (value) {
                this.setChildFixed();
            }
            else {
                this.style.position = 'unset';
            }
        }
        get closeOnScrollChildFixed() {
            return this._closeOnScrollChildFixed;
        }
        set closeOnScrollChildFixed(value) {
            this._closeOnScrollChildFixed = value;
        }
        get mediaQueries() {
            return this._mediaQueries;
        }
        set mediaQueries(value) {
            this._mediaQueries = value;
            let style = (0, modal_css_1.getModalMediaQueriesStyleClass)(this._mediaQueries);
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        setChildFixed() {
            this.style.position = 'fixed';
            this.zIndex = 9999;
            this.mapScrollTop = {};
            const getScrollY = (elm) => {
                let scrollID = elm.getAttribute('scroll-id');
                if (!scrollID) {
                    scrollID = base_3.IdUtils.generateUUID();
                    elm.setAttribute('scroll-id', scrollID);
                }
                this.mapScrollTop[scrollID] = elm.scrollTop;
            };
            const onParentScroll = (e) => {
                if (this.visible && this.closeOnScrollChildFixed) {
                    this.visible = false;
                }
                if (e && !e.target.offsetParent && e.target.getAttribute) {
                    getScrollY(e.target);
                }
                if (this.visible && !this.closeOnScrollChildFixed) {
                    this.positionAtChildFixed(true);
                }
            };
            let parentElement = this.parentNode;
            while (parentElement) {
                this.hasInitializedChildFixed = true;
                parentElement.addEventListener('scroll', (e) => onParentScroll(e));
                parentElement = parentElement.parentNode;
                if (parentElement === document.body) {
                    document.addEventListener('scroll', (e) => onParentScroll(e));
                    break;
                }
                else if (parentElement && !parentElement.offsetParent && parentElement.scrollTop && typeof parentElement.getAttribute === 'function') {
                    getScrollY(parentElement);
                }
            }
        }
        positionAtChildFixed(value) {
            if (this.isChildFixed) {
                if (!this.hasInitializedChildFixed) {
                    this.setChildFixed();
                }
                if (this.wrapperDiv) {
                    this.wrapperDiv.style.position = !value ? 'unset' : 'relative';
                    this.wrapperDiv.style.display = !value ? 'none' : 'block';
                }
                if (value && this.parentElement) {
                    const { x, y, height } = this.parentElement.getBoundingClientRect();
                    const mdClientRect = this.getBoundingClientRect();
                    const { innerHeight, innerWidth } = window;
                    const elmHeight = mdClientRect.height + (height || 20);
                    const elmWidth = mdClientRect.width;
                    let totalScrollY = 0;
                    for (const key in this.mapScrollTop) {
                        totalScrollY += this.mapScrollTop[key];
                    }
                    const parent = this.getWrapperParent(this.parentElement);
                    const newY = parent ? 0 : y;
                    let left = '';
                    let top = '';
                    if ((y + elmHeight) > innerHeight) {
                        const elmTop = newY - elmHeight + totalScrollY;
                        top = `${elmTop < 0 ? 0 : elmTop}px`;
                    }
                    else {
                        top = `${newY + totalScrollY}px`;
                    }
                    if ((x + elmWidth) > innerWidth) {
                        left = `${innerWidth - elmWidth}px`;
                    }
                    else {
                        left = `${x}px`;
                    }
                    this.setTargetStyle(this, 'modal', (0, modal_css_1.getModalStyle)(left, top));
                }
            }
        }
        getWrapperParent(rootParent) {
            if (!this.linkTo)
                return null;
            let parent = null;
            for (let child of rootParent.children) {
                if (child.contains(this.linkTo)) {
                    parent = child;
                    break;
                }
            }
            return parent;
        }
        positionAt(placement) {
            if (this.showBackdrop) {
                this.positionAtFix(placement);
            }
            else {
                this.updateNoBackdropMd();
                this.positionAtAbsolute(placement);
            }
        }
        positionAtFix(placement) {
            let parent = document.body;
            let coords = this.getWrapperFixCoords(parent, placement);
            const wrapperPositionStyle = (0, modal_css_1.getFixedWrapperStyle)(coords.left + "px", coords.top + "px");
            this.setTargetStyle(this.wrapperDiv, 'wrapperPosition', wrapperPositionStyle);
            // const innerModal = this.querySelector('i-modal') as Modal;
            // if (innerModal) {
            //     innerModal.wrapperDiv.style.width = '0px';
            //     innerModal.wrapperDiv.style.height = '0px';
            // }
        }
        positionAtAbsolute(placement) {
            let parent = this._parent || this.linkTo || this.parentElement || document.body;
            let coords;
            if (this.position === 'fixed') {
                coords = this.getWrapperFixCoords(parent, placement);
            }
            else {
                coords = this.getWrapperAbsoluteCoords(parent, placement);
            }
            const wrapperPositionStyle = (0, modal_css_1.getAbsoluteWrapperStyle)(coords.left + "px", coords.top + "px");
            this.setTargetStyle(this.wrapperDiv, 'wrapperPosition', wrapperPositionStyle);
        }
        getWrapperFixCoords(parent, placement) {
            const parentCoords = parent.getBoundingClientRect();
            let left = 0;
            let top = 0;
            const parentHeight = this.showBackdrop ? (parentCoords.height || window.innerHeight) - 1 : (parent.offsetHeight || parentCoords.height);
            const { wrapperLeft, wrapperTop } = this.getWrapperOffsets(parent);
            let parentTop = Math.max(parent.offsetTop || 0, parentCoords.top) + wrapperTop;
            let parentLeft = parentCoords.left + wrapperLeft;
            let parentWidth = parent.offsetWidth || parentCoords.width;
            let parentRight = parentLeft + parentWidth;
            const viewportWidth = document.documentElement.clientWidth;
            const viewportHeight = document.documentElement.clientHeight;
            switch (placement) {
                case "center":
                    top = parentHeight / 2 - this.modalDiv.offsetHeight / 2;
                    left = parentCoords.width / 2 - this.modalDiv.offsetWidth / 2 - 1;
                    break;
                case "top":
                    top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
                    left = parentLeft + (parentWidth - this.modalDiv.offsetWidth) / 2 - 1;
                    break;
                case "topLeft":
                    top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
                    left = parentLeft;
                    break;
                case "topRight":
                    top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
                    left = parentLeft + parentWidth - this.modalDiv.offsetWidth - 1;
                    break;
                case "bottom":
                    top = parentTop + parentHeight;
                    if (this.showBackdrop)
                        top = top - this.modalDiv.offsetHeight - 1;
                    left = parentLeft + (parentWidth - this.modalDiv.offsetWidth) / 2 - 1;
                    break;
                case "bottomLeft":
                    top = parentTop + parentHeight;
                    if (this.showBackdrop)
                        top = top - this.modalDiv.offsetHeight;
                    left = parentLeft;
                    break;
                case "bottomRight":
                    top = parentTop + parentHeight;
                    if (this.showBackdrop)
                        top = top - this.modalDiv.offsetHeight;
                    left = parentLeft + parentWidth - this.modalDiv.offsetWidth - 1;
                    break;
                case "rightTop":
                    top = parentTop;
                    left = this.showBackdrop ? parentCoords.right : parentRight;
                    if (left + this.modalDiv.offsetWidth > viewportWidth) {
                        left = viewportWidth - this.modalDiv.offsetWidth;
                    }
                    if (top + this.modalDiv.offsetHeight > viewportHeight) {
                        top = viewportHeight - this.modalDiv.offsetHeight;
                    }
                    break;
                case "left":
                    left = this.showBackdrop ? 0 : parentLeft - this.modalDiv.offsetWidth;
                    top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
                    break;
                case "right":
                    top = (this.showBackdrop ? 0 : parentTop) + parentHeight / 2 - this.modalDiv.offsetHeight / 2;
                    left = this.showBackdrop ?
                        parentLeft + parentWidth - this.modalDiv.offsetWidth :
                        parentLeft + parentWidth + this.modalDiv.offsetWidth / 2;
                    if (left + this.modalDiv.offsetWidth > viewportWidth) {
                        left = viewportWidth - this.modalDiv.offsetWidth;
                    }
                    if (top + this.modalDiv.offsetHeight > viewportHeight) {
                        top = viewportHeight - this.modalDiv.offsetHeight;
                    }
                    break;
            }
            left = left < 0 ? parentLeft : left;
            top = top < 0 ? parentTop : top;
            return { top, left };
        }
        getWrapperOffsets(parent) {
            let wrapperTop = 0;
            let wrapperLeft = 0;
            if (this.isChildFixed) {
                if (parent.nodeName === 'I-MODAL') {
                    const wrapper = parent.querySelector('.modal-wrapper');
                    if (wrapper) {
                        wrapperTop = wrapper.offsetTop;
                        wrapperLeft = wrapper.offsetLeft;
                    }
                }
            }
            return { wrapperTop, wrapperLeft };
        }
        // private getWrapperAbsoluteCoords(parent: Control | Container | HTMLElement, placement: modalPopupPlacementType) {
        //     const parentCoords = parent.getBoundingClientRect();
        //     let left = 0;
        //     let top = 0;
        //     let max;
        //     const isOutside = !parent?.contains(this);
        //     const viewportWidth = document.documentElement.clientWidth;
        //     const viewportHeight = document.documentElement.clientHeight;
        //     switch (placement) {
        //         case "center":
        //             left = (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
        //             top = (parentCoords.height - this.modalDiv.offsetHeight) / 2;
        //             break;
        //         case "top":
        //         case "topLeft":
        //             if (this.isChildFixed) {
        //                 top = this.getParentOccupiedTop();
        //                 left = this.getParentOccupiedLeft();
        //                 break;
        //             }
        //         case "topRight":
        //             if (this.isChildFixed) {
        //                 top = this.getParentOccupiedTop();
        //                 left = parentCoords.width - this.getParentOccupiedRight() - this.wrapperDiv.offsetWidth;
        //                 break;
        //             }
        //             if (parentCoords.top - this.modalDiv.offsetHeight >= 0) {
        //                 top = -this.modalDiv.offsetHeight;
        //             } else {
        //                 if (window.innerHeight < this.modalDiv.offsetHeight + parentCoords.bottom) {
        //                     max = window.innerHeight - this.modalDiv.offsetHeight - parentCoords.y;
        //                     top = (parentCoords.height - this.modalDiv.offsetHeight) / 2;
        //                     top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
        //                 } else {
        //                     top = parentCoords.height;
        //                 }
        //             }
        //             break;
        //         case "bottom":
        //         case "bottomLeft":
        //             if (this.isChildFixed) {
        //                 left = 0;
        //                 top = parentCoords.height;
        //                 break;
        //             }
        //         case "bottomRight":
        //             if (this.isChildFixed) {
        //                 top = parentCoords.height;
        //                 left = parentCoords.width - this.wrapperDiv.offsetWidth;
        //                 break;
        //             }
        //             if (window.innerHeight < this.modalDiv.offsetHeight + parentCoords.bottom) {
        //                 if (parentCoords.y - this.modalDiv.offsetHeight < 0) {
        //                     max = window.innerHeight - this.modalDiv.offsetHeight - parentCoords.y;
        //                     top = (parentCoords.height - this.modalDiv.offsetHeight) / 2;
        //                     top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
        //                 } else {
        //                     top = -this.modalDiv.offsetHeight;
        //                 }
        //             } else {
        //                 top = isOutside ? parentCoords.top - this.modalDiv.offsetHeight : parentCoords.height;
        //             }
        //             break;
        //         case "rightTop":
        //             top = isOutside ? parentCoords.top - this.modalDiv.offsetHeight : 0;
        //             left = isOutside ? parentCoords.left + parentCoords.width : parentCoords.width;
        //             if (left + this.modalDiv.offsetWidth > viewportWidth) {
        //                 left = viewportWidth - this.modalDiv.offsetWidth;
        //             }
        //             if (top < 0 && top + this.modalDiv.offsetHeight > 0) {
        //                 top = 0;
        //             }
        //             if (top + this.modalDiv.offsetHeight > viewportHeight) {
        //                 top = viewportHeight - this.modalDiv.offsetHeight;
        //             }
        //             break;
        //         case "left":
        //             max = window.innerHeight - this.modalDiv.offsetHeight - parentCoords.y;
        //             if (isOutside) {
        //                 top = parentCoords.top + parentCoords.height / 2 - this.modalDiv.offsetHeight / 2;
        //                 left = Math.max(parentCoords.left - this.modalDiv.offsetWidth, 0);
        //                 if (top + this.modalDiv.offsetHeight > viewportHeight) {
        //                     top = viewportHeight - this.modalDiv.offsetHeight;
        //                 }
        //             } else {
        //                 top = (parentCoords.height - this.modalDiv.offsetHeight) / 2;
        //                 top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
        //                 left = -this.wrapperDiv.offsetWidth - 8
        //             }
        //             break;
        //     }
        //     if (this.isChildFixed) {
        //         if (placement !== 'bottomRight' && placement !== 'left') left = left < 0 ? parentCoords.left : left;
        //         if (placement !== 'left') top = top < 0 ? parentCoords.top : top;
        //         return { top, left };
        //     }
        //     if (placement === 'topRight' || placement === 'bottomRight') {
        //         if (isOutside) {
        //             left = parentCoords.left + parentCoords.width - this.wrapperDiv.offsetWidth;
        //             if (left + this.modalDiv.offsetWidth > viewportWidth) {
        //                 left = viewportWidth - this.modalDiv.offsetWidth;
        //             }
        //         } else {
        //             if (parentCoords.right - this.wrapperDiv.offsetWidth >= 0) {
        //                 left = parentCoords.width - this.wrapperDiv.offsetWidth;
        //             } else {
        //                 left = -parentCoords.left;
        //             }
        //         }
        //     } else if (['top', 'topLeft', 'bottom', 'bottomLeft'].includes(placement)) {
        //         if (isOutside) {
        //             left = parentCoords.left;
        //             if (left + this.modalDiv.offsetWidth > viewportWidth) {
        //                 left = viewportWidth - this.modalDiv.offsetWidth;
        //             }
        //         } else {
        //             if (window.innerWidth >= parentCoords.left + this.wrapperDiv.offsetWidth) {
        //                 left = 0;
        //             } else {
        //                 if (parentCoords.right - this.wrapperDiv.offsetWidth >= 0) {
        //                     left = Math.min(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
        //                 } else {
        //                     left = Math.max(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
        //                 }
        //             }
        //         }
        //     }
        //     return { top, left }
        // }
        getWrapperAbsoluteCoords(parent, placement) {
            const parentCoords = parent.getBoundingClientRect();
            const viewportWidth = document.documentElement.clientWidth;
            const viewportHeight = document.documentElement.clientHeight;
            const isOutside = !parent?.contains(this);
            let left = 0;
            let top = 0;
            const constrainToViewport = (value, dimension) => {
                const lowercasePlacement = placement.toLowerCase();
                if (dimension === 'width') {
                    if (isOutside) {
                        if (value + this.modalDiv.offsetWidth > viewportWidth) {
                            value = viewportWidth - this.modalDiv.offsetWidth;
                        }
                        else if (value < 0) {
                            value = 0;
                        }
                    }
                    else {
                        if (lowercasePlacement.includes('right')) {
                            if (lowercasePlacement === 'righttop' || lowercasePlacement === 'right') {
                                if (parentCoords.right + this.wrapperDiv.offsetWidth > viewportWidth) {
                                    value = viewportWidth - parentCoords.left - this.wrapperDiv.offsetWidth;
                                }
                            }
                            else {
                                if (parentCoords.right - this.wrapperDiv.offsetWidth < 0) {
                                    value = -parentCoords.left;
                                }
                            }
                        }
                        else {
                            if (lowercasePlacement === 'left') {
                                if (parentCoords.left - this.wrapperDiv.offsetWidth < 0) {
                                    value = 0;
                                }
                            }
                            else {
                                if (value + parentCoords.left < 0) {
                                    value = -parentCoords.left;
                                }
                            }
                        }
                        if (value + parentCoords.left + this.modalDiv.offsetWidth > viewportWidth) {
                            value = Math.max(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
                        }
                    }
                }
                if (dimension === 'height') {
                    if (isOutside) {
                        if (value + this.modalDiv.offsetHeight > viewportHeight) {
                            value = viewportHeight - this.modalDiv.offsetHeight;
                        }
                        else if (value < 0) {
                            value = 0;
                        }
                    }
                    else {
                        if (lowercasePlacement.includes('bottom')) {
                            if (parentCoords.bottom + this.wrapperDiv.offsetHeight > viewportHeight) {
                                value = viewportHeight - parentCoords.top - this.wrapperDiv.offsetHeight;
                            }
                        }
                        else {
                            if (parentCoords.top - this.wrapperDiv.offsetHeight < 0) {
                                value = 0;
                            }
                        }
                    }
                }
                return value;
            };
            let parentLeft = isOutside ? parentCoords.left : 0;
            let parentTop = isOutside ? parentCoords.top : 0;
            let parentRight = isOutside ? parentCoords.right : parentCoords.width;
            switch (placement) {
                case "center":
                    left = (parentCoords.width - this.wrapperDiv.offsetWidth) / 2 + parentLeft;
                    top = (parentCoords.height - this.modalDiv.offsetHeight) / 2 + parentTop;
                    break;
                case "top":
                case "topLeft":
                case "topRight":
                    top = parentTop - this.modalDiv.offsetHeight;
                    left = placement === "topRight" ? parentCoords.width - this.wrapperDiv.offsetWidth : parentLeft;
                    if (placement === "top") {
                        left += (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
                    }
                    break;
                case "bottom":
                case "bottomLeft":
                case "bottomRight":
                    top = parentTop + parentCoords.height;
                    left = placement === "bottomRight" ? parentRight - this.wrapperDiv.offsetWidth : parentLeft;
                    if (placement === "bottom") {
                        left += (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
                    }
                    break;
                case "rightTop":
                    top = parentTop - this.modalDiv.offsetHeight;
                    left = parentRight;
                    break;
                case "right":
                    top = parentTop + parentCoords.height / 2 - this.modalDiv.offsetHeight / 2;
                    left = parentRight;
                    break;
                case "left":
                    top = parentTop + parentCoords.height / 2 - this.modalDiv.offsetHeight / 2;
                    left = parentLeft - this.modalDiv.offsetWidth;
                    break;
            }
            left = constrainToViewport(left, 'width');
            top = constrainToViewport(top, 'height');
            // Additional adjustments if the modal is fixed
            if (this.isChildFixed) {
                if (['bottomRight', 'left'].indexOf(placement) === -1) {
                    left = Math.max(left, parentCoords.left);
                }
                if (placement !== 'left') {
                    top = Math.max(top, parentCoords.top);
                }
            }
            return { top, left };
        }
        _handleOnShow(event) {
            if (this.popupPlacement && this.enabled)
                this.positionAt(this.popupPlacement);
            const parent = this._parent || this.linkTo || this;
            const i18nData = parent?.parentModule?.i18n || this.body?.i18n || application_1.application.i18n;
            i18nData && this.updateLocale(i18nData);
            if (i18nData && this.body) {
                this.body.updateLocale(i18nData);
            }
            if (this.enabled && this._onOpen) {
                event.preventDefault();
                this._onOpen(this);
            }
        }
        handleModalMouseDown(event) {
            this.insideClick = true;
            this.setInsideClick(event);
        }
        handleModalMouseUp(event) {
            if (!this.closeOnBackdropClick && !this.showBackdrop) {
                this.setInsideClick(event);
            }
            if (!this.insideClick) {
                if (typeof this.onBeforeClose === 'function')
                    this.onBeforeClose(this);
                else
                    this.visible = false;
            }
        }
        setInsideClick(event) {
            const target = event.target;
            if (this.closeOnBackdropClick) {
                this.insideClick = this.showBackdrop ? target !== this.wrapperDiv : this.modalDiv.contains(target);
            }
            else if (!this.showBackdrop) {
                let parent = this._parent || this.linkTo || this.parentElement;
                if (parent instanceof Range) {
                    const commonAncestor = parent.commonAncestorContainer;
                    const wrapNode = commonAncestor?.nodeType === 3 ? commonAncestor.parentElement : commonAncestor;
                    if (wrapNode)
                        parent = wrapNode;
                }
                this.insideClick = this.modalDiv.contains(target) || parent?.contains(target);
            }
        }
        updateModal(name, value) {
            if (!isNaN(Number(value)))
                this.modalDiv.style[name] = value + 'px';
            else
                this.modalDiv.style[name] = value;
            this.style[name] = '';
        }
        refresh() {
            super.refresh(true);
            if (this.visible && this.popupPlacement) {
                this.positionAt(this.popupPlacement);
            }
        }
        get background() {
            return this._background;
        }
        set background(value) {
            if (!this._background) {
                this._background = new base_2.Background(this.modalDiv, value);
            }
            else {
                this._background.setBackgroundStyle(value);
            }
        }
        get width() {
            return (!isNaN(this._width) ? this._width : this.offsetWidth);
        }
        set width(value) {
            this._width = value;
            this.updateModal('width', value);
        }
        get height() {
            return this._height;
        }
        set height(value) {
            this._height = value;
            this.updateModal('height', value);
        }
        get border() {
            return this._border;
        }
        set border(value) {
            this._border = new base_2.Border((this.showBackdrop ? this.modalDiv : this.wrapperDiv), value);
            if (!this.showBackdrop) {
                this.modalDiv.style.borderRadius = 'inherit';
            }
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (!this._padding)
                this._padding = new base_2.SpaceValue(this.modalDiv, value, 'padding');
            else
                this._padding.update(value);
        }
        get boxShadow() {
            return (this.showBackdrop ? this.modalDiv : this.wrapperDiv).style.boxShadow;
        }
        set boxShadow(value) {
            (this.showBackdrop ? this.modalDiv : this.wrapperDiv).style.boxShadow = value;
        }
        get overflow() {
            if (!this._overflow) {
                this._overflow = new base_2.Overflow((this.showBackdrop ? this.modalDiv : this.wrapperDiv));
            }
            return this._overflow;
        }
        set overflow(value) {
            if (!this._overflow) {
                this._overflow = new base_2.Overflow((this.showBackdrop ? this.modalDiv : this.wrapperDiv), value);
            }
            else {
                this._overflow.setOverflowStyle(value);
            }
        }
        removeTargetStyle(target, propertyName) {
            let style = this.propertyClassMap[propertyName];
            if (style)
                target.classList.remove(style);
        }
        setTargetStyle(target, propertyName, value) {
            this.removeTargetStyle(target, propertyName);
            if (value) {
                this.propertyClassMap[propertyName] = value;
                target.classList.add(value);
            }
        }
        init() {
            if (!this.wrapperDiv) {
                this.onBeforeClose = this.getAttribute('onBeforeClose', true) || this.onBeforeClose;
                this.onClose = this.getAttribute('onClose', true) || this.onClose;
                this.onOpen = this.getAttribute('onOpen', true) || this.onOpen;
                this.popupPlacement = this.getAttribute('popupPlacement', true, DEFAULT_VALUES.popupPlacement);
                this.closeOnBackdropClick = this.getAttribute('closeOnBackdropClick', true, DEFAULT_VALUES.closeOnBackdropClick);
                this.wrapperDiv = this.createElement('div', this);
                this.wrapperDiv.classList.add('modal-wrapper');
                this.showBackdrop = this.getAttribute('showBackdrop', true, DEFAULT_VALUES.showBackdrop);
                this.modalDiv = this.createElement('div', this.wrapperDiv);
                this.titleSpan = this.createElement('div', this.modalDiv);
                this.titleSpan.classList.add(modal_css_1.titleStyle, 'i-modal_header');
                this.createElement('span', this.titleSpan);
                this.title = this.getAttribute('title', true);
                const closeIconAttr = this.getAttribute('closeIcon', true);
                if (closeIconAttr) {
                    closeIconAttr.height = closeIconAttr.height || '16px';
                    closeIconAttr.width = closeIconAttr.width || '16px';
                    closeIconAttr.fill = closeIconAttr.fill || Theme.colors.primary.main;
                    this.closeIcon = new icon_1.Icon(undefined, closeIconAttr);
                }
                this.bodyDiv = this.createElement('div', this.modalDiv);
                this.bodyDiv.classList.add('i-modal_body');
                while (this.childNodes.length > 1) {
                    this.bodyDiv.appendChild(this.childNodes[0]);
                }
                this.overlayDiv = this.createElement('div', this);
                this.prepend(this.overlayDiv);
                const overlayStyle = (0, modal_css_1.getOverlayStyle)();
                this.overlayDiv.classList.add(overlayStyle);
                this.overlayDiv.classList.add('modal-overlay');
                this.modalDiv.classList.add(modal_css_1.modalStyle);
                this.modalDiv.classList.add('modal');
                this.addEventListener('show', this._handleOnShow.bind(this));
                window.addEventListener('keydown', event => {
                    if (!this.visible)
                        return;
                    if (event.key === 'Escape') {
                        this.visible = false;
                    }
                });
                // document.body.addEventListener('click', event => {
                //     if (!this.visible || this.showBackdrop || !this.closeOnBackdropClick) return
                //     const target = event.target as HTMLElement;
                //     let parent = this._parent || this.linkTo || this.parentElement;
                //     if (!this.modalDiv.contains(target) && !parent?.contains(target)) {
                //         this.visible = false
                //     }
                // });
                const isChildFixed = this.getAttribute('isChildFixed', true);
                if (isChildFixed)
                    this.isChildFixed = isChildFixed;
                const closeOnScrollChildFixed = this.getAttribute('closeOnScrollChildFixed', true);
                this.closeOnScrollChildFixed = closeOnScrollChildFixed;
                const itemAttr = this.getAttribute('item', true);
                if (itemAttr)
                    this.item = itemAttr;
                super.init();
                const maxWidth = this.getAttribute('maxWidth', true);
                if (maxWidth !== undefined)
                    this.updateModal('maxWidth', this.maxWidth);
                const minHeight = this.getAttribute('minHeight', true);
                if (minHeight !== undefined)
                    this.updateModal('minHeight', this.minHeight);
                const minWidth = this.getAttribute('minWidth', true);
                if (minWidth !== undefined)
                    this.updateModal('minWidth', this.minWidth);
                const height = this.getAttribute('height', true);
                if (height !== undefined)
                    this.updateModal('height', this.height);
                const maxHeight = this.getAttribute('maxHeight', true);
                if (maxHeight !== undefined)
                    this.updateModal('maxHeight', this.maxHeight);
                let border = this.getAttribute('border', true);
                if (border) {
                    this._border = new base_2.Border((this.showBackdrop ? this.modalDiv : this.wrapperDiv), border);
                    this.style.border = 'none';
                    if (!this.showBackdrop) {
                        this.modalDiv.style.borderRadius = 'inherit';
                    }
                }
                let padding = this.getAttribute('padding', true);
                if (padding) {
                    this._padding = new base_2.SpaceValue(this.modalDiv, padding, 'padding');
                }
                let boxShadow = this.getAttribute('boxShadow', true);
                if (boxShadow)
                    this.boxShadow = boxShadow;
                let overflow = this.getAttribute('overflow', true);
                if (overflow) {
                    this._overflow = new base_2.Overflow((this.showBackdrop ? this.modalDiv : this.wrapperDiv), overflow);
                    if (overflow === 'hidden')
                        this.bodyDiv.classList.add(modal_css_1.getBodyStyle);
                }
                this.mediaQueries = this.getAttribute('mediaQueries', true, []);
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Modal = __decorate([
        (0, base_2.customElements)('i-modal', {
            icon: 'stop',
            group: types_1.GroupType.BASIC,
            className: 'Modal',
            props: {
                title: { type: 'string' },
                showBackdrop: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.showBackdrop
                },
                closeIcon: {
                    type: 'object',
                    default: {}
                },
                popupPlacement: {
                    type: 'string',
                    default: DEFAULT_VALUES.popupPlacement
                },
                closeOnBackdropClick: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.closeOnBackdropClick
                },
                isChildFixed: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.isChildFixed
                },
                closeOnScrollChildFixed: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.closeOnScrollChildFixed
                }
            },
            events: {
                onOpen: [
                    { name: 'target', type: 'Control', isControl: true }
                ],
                onClose: [
                    { name: 'target', type: 'Control', isControl: true }
                ],
                onBeforeClose: [
                    { name: 'target', type: 'Control', isControl: true }
                ],
            },
            dataSchema: {
                type: 'object',
                properties: {
                    title: {
                        type: 'string'
                    },
                    showBackdrop: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.showBackdrop
                    },
                    closeIcon: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string'
                            },
                            fill: {
                                type: 'string',
                                format: 'color'
                            },
                            width: {
                                type: 'number'
                            },
                            height: {
                                type: 'number'
                            },
                            image: {
                                type: 'object',
                                properties: {
                                    url: {
                                        type: 'string'
                                    }
                                }
                            }
                        }
                    },
                    popupPlacement: {
                        type: 'string',
                        enum: ['center', 'bottom', 'bottomLeft', 'bottomRight', 'top', 'topLeft', 'topRight', 'rightTop', 'left', 'right'],
                        default: DEFAULT_VALUES.popupPlacement
                    },
                    closeOnBackdropClick: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.closeOnBackdropClick
                    },
                    isChildFixed: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.isChildFixed
                    },
                    closeOnScrollChildFixed: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.closeOnScrollChildFixed
                    }
                }
            }
        })
    ], Modal);
    exports.Modal = Modal;
});
define("@ijstech/modal", ["require", "exports", "@ijstech/modal/modal.ts"], function (require, exports, modal_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Modal = void 0;
    Object.defineProperty(exports, "Modal", { enumerable: true, get: function () { return modal_1.Modal; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/layout/interfaces.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("@ijstech/layout/style/panel.css.ts", ["require", "exports", "@ijstech/base", "@ijstech/style", "@ijstech/base"], function (require, exports, base_1, Styles, base_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHoverStyleClass = exports.getGridLayoutMediaQueriesStyleClass = exports.getTemplateAreasStyleClass = exports.getTemplateRowsStyleClass = exports.getTemplateColumnsStyleClass = exports.alignContentEndStyle = exports.alignContentCenterStyle = exports.alignContentStartStyle = exports.alignContentStretchStyle = exports.alignContentSpaceAroundStyle = exports.alignContentSpaceBetweenStyle = exports.alignSelfEndStyle = exports.alignSelfCenterStyle = exports.alignSelfStartStyle = exports.alignSelfStretchStyle = exports.alignSelfAutoStyle = exports.alignItemsEndStyle = exports.alignItemsCenterStyle = exports.alignItemsStartStyle = exports.alignItemsBaselineStyle = exports.alignItemsStretchStyle = exports.justifyContentSpaceEvenlyStyle = exports.justifyContentSpaceAroundStyle = exports.justifyContentSpaceBetweenStyle = exports.justifyContentEndStyle = exports.justifyContentCenterStyle = exports.justifyContentStartStyle = exports.getStackMediaQueriesStyleClass = exports.getStackDirectionStyleClass = exports.gridStyle = exports.hStackStyle = exports.vStackStyle = exports.overflowStyle = exports.panelStyle = void 0;
    exports.panelStyle = Styles.style({
        display: 'block',
        clear: 'both',
        position: 'relative'
    });
    exports.overflowStyle = Styles.style({
        overflow: 'hidden'
    });
    exports.vStackStyle = Styles.style({
        display: 'flex',
        flexDirection: 'column'
    });
    exports.hStackStyle = Styles.style({
        display: 'flex',
        flexDirection: 'row'
    });
    exports.gridStyle = Styles.style({
        display: 'grid'
    });
    const getStackDirectionStyleClass = (direction, reverse) => {
        const flexDirection = direction == 'vertical' ? 'column' : 'row';
        return Styles.style({
            display: 'flex',
            flexDirection: reverse ? `${flexDirection}-reverse` : flexDirection
        });
    };
    exports.getStackDirectionStyleClass = getStackDirectionStyleClass;
    const getStackMediaQueriesStyleClass = (mediaQueries, currentDirection) => {
        let styleObj = (0, base_1.getControlMediaQueriesStyle)(mediaQueries);
        for (let mediaQuery of mediaQueries) {
            let mediaQueryRule = (0, base_2.getMediaQueryRule)(mediaQuery);
            if (mediaQueryRule) {
                styleObj['$nest'][mediaQueryRule] = styleObj['$nest'][mediaQueryRule] || {};
                const { direction, justifyContent, alignItems, alignSelf, gap, reverse } = mediaQuery.properties || {};
                if (direction) {
                    styleObj['$nest'][mediaQueryRule]['flexDirection'] = `${direction == 'vertical' ? 'column' : 'row'} !important`;
                }
                if (justifyContent) {
                    styleObj['$nest'][mediaQueryRule]['justifyContent'] = `${justifyContent} !important`;
                }
                if (alignItems) {
                    styleObj['$nest'][mediaQueryRule]['alignItems'] = `${alignItems} !important`;
                }
                if (alignSelf) {
                    styleObj['$nest'][mediaQueryRule]['alignSelf'] = `${alignSelf} !important`;
                }
                if (gap !== undefined && gap !== null) {
                    styleObj['$nest'][mediaQueryRule]['gap'] = `${(0, base_2.getSpacingValue)(gap)} !important`;
                }
                if (reverse !== undefined && reverse !== null) {
                    const direct = direction || currentDirection || 'horizontal';
                    styleObj['$nest'][mediaQueryRule]['flexDirection'] = `${direct === 'vertical' ? 'column' : 'row'}${reverse ? '-reverse' : ''} !important`;
                }
            }
        }
        return Styles.style(styleObj);
    };
    exports.getStackMediaQueriesStyleClass = getStackMediaQueriesStyleClass;
    exports.justifyContentStartStyle = Styles.style({
        justifyContent: 'flex-start'
    });
    exports.justifyContentCenterStyle = Styles.style({
        justifyContent: 'center'
    });
    exports.justifyContentEndStyle = Styles.style({
        justifyContent: 'flex-end'
    });
    exports.justifyContentSpaceBetweenStyle = Styles.style({
        justifyContent: 'space-between'
    });
    exports.justifyContentSpaceAroundStyle = Styles.style({
        justifyContent: 'space-around'
    });
    exports.justifyContentSpaceEvenlyStyle = Styles.style({
        justifyContent: 'space-evenly'
    });
    exports.alignItemsStretchStyle = Styles.style({
        alignItems: 'stretch'
    });
    exports.alignItemsBaselineStyle = Styles.style({
        alignItems: 'baseline'
    });
    exports.alignItemsStartStyle = Styles.style({
        alignItems: 'flex-start'
    });
    exports.alignItemsCenterStyle = Styles.style({
        alignItems: 'center'
    });
    exports.alignItemsEndStyle = Styles.style({
        alignItems: 'flex-end'
    });
    exports.alignSelfAutoStyle = Styles.style({
        alignSelf: 'auto'
    });
    exports.alignSelfStretchStyle = Styles.style({
        alignSelf: 'stretch'
    });
    exports.alignSelfStartStyle = Styles.style({
        alignSelf: 'flex-start'
    });
    exports.alignSelfCenterStyle = Styles.style({
        alignSelf: 'center'
    });
    exports.alignSelfEndStyle = Styles.style({
        alignSelf: 'flex-end'
    });
    exports.alignContentSpaceBetweenStyle = Styles.style({
        alignContent: 'space-between'
    });
    exports.alignContentSpaceAroundStyle = Styles.style({
        alignContent: 'space-around'
    });
    exports.alignContentStretchStyle = Styles.style({
        alignContent: 'stretch'
    });
    exports.alignContentStartStyle = Styles.style({
        alignContent: 'flex-start'
    });
    exports.alignContentCenterStyle = Styles.style({
        alignContent: 'center'
    });
    exports.alignContentEndStyle = Styles.style({
        alignContent: 'flex-end'
    });
    const getTemplateColumnsStyleClass = (columns) => {
        return Styles.style({
            gridTemplateColumns: columns.join(' ')
        });
    };
    exports.getTemplateColumnsStyleClass = getTemplateColumnsStyleClass;
    const getTemplateRowsStyleClass = (rows) => {
        return Styles.style({
            gridTemplateRows: rows.join(' ')
        });
    };
    exports.getTemplateRowsStyleClass = getTemplateRowsStyleClass;
    const getTemplateAreasStyleClass = (templateAreas) => {
        let templateAreasStr = '';
        for (let i = 0; i < templateAreas.length; i++) {
            templateAreasStr += '"' + templateAreas[i].join(' ') + '" ';
        }
        return Styles.style({
            gridTemplateAreas: templateAreasStr
        });
    };
    exports.getTemplateAreasStyleClass = getTemplateAreasStyleClass;
    const getGridLayoutMediaQueriesStyleClass = (mediaQueries) => {
        let styleObj = (0, base_1.getControlMediaQueriesStyle)(mediaQueries, { display: 'grid' });
        for (let mediaQuery of mediaQueries) {
            let mediaQueryRule = (0, base_2.getMediaQueryRule)(mediaQuery);
            if (mediaQueryRule) {
                styleObj['$nest'][mediaQueryRule] = styleObj['$nest'][mediaQueryRule] || {};
                const { templateColumns, templateRows, templateAreas, gap } = mediaQuery.properties || {};
                if (templateColumns) {
                    const templateColumnsStr = templateColumns.join(' ');
                    styleObj['$nest'][mediaQueryRule]['gridTemplateColumns'] = `${templateColumnsStr} !important`;
                }
                if (templateRows) {
                    const templateRowsStr = templateRows.join(' ');
                    styleObj['$nest'][mediaQueryRule]['gridTemplateRows'] = `${templateRowsStr} !important`;
                }
                if (templateAreas) {
                    let templateAreasStr = '';
                    for (let i = 0; i < templateAreas.length; i++) {
                        templateAreasStr += '"' + templateAreas[i].join(' ') + '" ';
                    }
                    styleObj['$nest'][mediaQueryRule]['gridTemplateAreas'] = `${templateAreasStr} !important`;
                }
                if (gap !== undefined && gap !== null) {
                    if (gap.row) {
                        styleObj['$nest'][mediaQueryRule]['rowGap'] = `${(0, base_2.getSpacingValue)(gap.row)}!important`;
                    }
                    if (gap.column) {
                        styleObj['$nest'][mediaQueryRule]['columnGap'] = `${(0, base_2.getSpacingValue)(gap.column)}!important`;
                    }
                }
            }
        }
        return Styles.style(styleObj);
    };
    exports.getGridLayoutMediaQueriesStyleClass = getGridLayoutMediaQueriesStyleClass;
    const getHoverStyleClass = (hover) => {
        return Styles.style({
            $nest: {
                '&:hover': {
                    backgroundColor: hover.backgroundColor,
                    color: hover.fontColor,
                    opacity: hover.opacity
                }
            }
        });
    };
    exports.getHoverStyleClass = getHoverStyleClass;
});
define("@ijstech/layout/stack.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout/style/panel.css.ts", "@ijstech/types"], function (require, exports, base_3, panel_css_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VStack = exports.HStack = exports.StackLayout = void 0;
    const DEFAULT_VALUES = {
        wrap: 'nowrap',
        direction: 'horizontal',
        justifyContent: 'start',
        alignItems: 'stretch',
        alignSelf: 'start',
        alignContent: 'start',
        reverse: false
    };
    let StackLayout = class StackLayout extends base_3.Container {
        constructor(parent, options) {
            super(parent, options);
            this._reverse = false;
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        get direction() {
            return this._direction;
        }
        set direction(value) {
            this._direction = value;
            if (value) {
                let style = (0, panel_css_1.getStackDirectionStyleClass)(value, this.reverse);
                this.setStyle('direction', style);
            }
        }
        get reverse() {
            return this._reverse ?? false;
        }
        set reverse(value) {
            this._reverse = value ?? false;
            let style = (0, panel_css_1.getStackDirectionStyleClass)(this.direction, this.reverse);
            this.setStyle('direction', style);
        }
        get justifyContent() {
            return this._justifyContent;
        }
        set justifyContent(value) {
            this._justifyContent = value || 'start';
            switch (this._justifyContent) {
                case 'start':
                    this.setStyle('justifyContent', panel_css_1.justifyContentStartStyle);
                    break;
                case 'center':
                    this.setStyle('justifyContent', panel_css_1.justifyContentCenterStyle);
                    break;
                case 'end':
                    this.setStyle('justifyContent', panel_css_1.justifyContentEndStyle);
                    break;
                case 'space-between':
                    this.setStyle('justifyContent', panel_css_1.justifyContentSpaceBetweenStyle);
                    break;
                case 'space-around':
                    this.setStyle('justifyContent', panel_css_1.justifyContentSpaceAroundStyle);
                    break;
                case 'space-evenly':
                    this.setStyle('justifyContent', panel_css_1.justifyContentSpaceEvenlyStyle);
                    break;
            }
        }
        get alignItems() {
            return this._alignItems;
        }
        set alignItems(value) {
            this._alignItems = value || 'stretch';
            switch (this._alignItems) {
                case 'stretch':
                    this.setStyle('alignItems', panel_css_1.alignItemsStretchStyle);
                    break;
                case 'baseline':
                    this.setStyle('alignItems', panel_css_1.alignItemsBaselineStyle);
                    break;
                case 'start':
                    this.setStyle('alignItems', panel_css_1.alignItemsStartStyle);
                    break;
                case 'center':
                    this.setStyle('alignItems', panel_css_1.alignItemsCenterStyle);
                    break;
                case 'end':
                    this.setStyle('alignItems', panel_css_1.alignItemsEndStyle);
                    break;
            }
        }
        get alignSelf() {
            return this._alignSelf;
        }
        set alignSelf(value) {
            this._alignSelf = value || 'auto';
            switch (this._alignSelf) {
                case 'auto':
                    this.setStyle('alignSelf', panel_css_1.alignSelfAutoStyle);
                    break;
                case 'stretch':
                    this.setStyle('alignSelf', panel_css_1.alignSelfStretchStyle);
                    break;
                case 'start':
                    this.setStyle('alignSelf', panel_css_1.alignSelfStartStyle);
                    break;
                case 'center':
                    this.setStyle('alignSelf', panel_css_1.alignSelfCenterStyle);
                    break;
                case 'end':
                    this.setStyle('alignSelf', panel_css_1.alignSelfEndStyle);
                    break;
            }
        }
        get alignContent() {
            return this._alignContent;
        }
        set alignContent(value) {
            this._alignContent = value || 'auto';
            switch (this._alignContent) {
                case 'space-between':
                    this.setStyle('alignContent', panel_css_1.alignContentSpaceBetweenStyle);
                    break;
                case 'space-around':
                    this.setStyle('alignContent', panel_css_1.alignContentSpaceAroundStyle);
                    break;
                case 'stretch':
                    this.setStyle('alignContent', panel_css_1.alignContentStretchStyle);
                    break;
                case 'start':
                    this.setStyle('alignContent', panel_css_1.alignContentStartStyle);
                    break;
                case 'center':
                    this.setStyle('alignContent', panel_css_1.alignContentCenterStyle);
                    break;
                case 'end':
                    this.setStyle('alignContent', panel_css_1.alignContentEndStyle);
                    break;
            }
        }
        get gap() {
            return this._gap;
        }
        set gap(value) {
            this._gap = value || 'initial';
            const num = +this._gap;
            if (!isNaN(num)) {
                this.style.gap = this._gap + 'px';
            }
            else {
                this.style.gap = `${this._gap}`;
            }
        }
        get wrap() {
            return this._wrap;
        }
        set wrap(value) {
            if (!value)
                return;
            this._wrap = value;
            this.style.flexWrap = this._wrap;
        }
        get mediaQueries() {
            return this._mediaQueries;
        }
        set mediaQueries(value) {
            this._mediaQueries = value;
            let style = (0, panel_css_1.getStackMediaQueriesStyleClass)(this._mediaQueries, this.direction);
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        get hover() {
            return this._hover;
        }
        set hover(value) {
            this._hover = value;
            if (this._hover) {
                const hoverStyle = (0, panel_css_1.getHoverStyleClass)(this._hover);
                this.setStyle('hover', hoverStyle);
            }
            else {
                this.removeStyle('hover');
            }
        }
        removeStyle(propertyName) {
            let style = this.propertyClassMap[propertyName];
            if (style)
                this.classList.remove(style);
        }
        setStyle(propertyName, value) {
            this.removeStyle(propertyName);
            if (value) {
                this.propertyClassMap[propertyName] = value;
                this.classList.add(value);
            }
        }
        init() {
            super.init();
            (0, base_3.setAttributeToProperty)(this, 'reverse');
            (0, base_3.setAttributeToProperty)(this, 'direction', 'horizontal');
            (0, base_3.setAttributeToProperty)(this, 'justifyContent');
            (0, base_3.setAttributeToProperty)(this, 'alignItems');
            (0, base_3.setAttributeToProperty)(this, 'alignSelf');
            (0, base_3.setAttributeToProperty)(this, 'alignContent');
            (0, base_3.setAttributeToProperty)(this, 'gap');
            (0, base_3.setAttributeToProperty)(this, 'wrap');
            (0, base_3.setAttributeToProperty)(this, 'mediaQueries');
            (0, base_3.setAttributeToProperty)(this, 'hover');
        }
    };
    StackLayout = __decorate([
        (0, base_3.customElements)('i-stack', {
            icon: 'layer-group',
            group: types_1.GroupType.LAYOUT,
            className: 'StackLayout',
            props: {
                gap: { type: 'number' },
                wrap: { type: 'string', default: DEFAULT_VALUES.wrap },
                direction: { type: 'string', default: DEFAULT_VALUES.direction },
                justifyContent: { type: 'string', default: DEFAULT_VALUES.justifyContent },
                alignItems: { type: 'string', default: DEFAULT_VALUES.alignItems },
                alignSelf: { type: 'string', default: DEFAULT_VALUES.alignSelf },
                alignContent: { type: 'string', default: DEFAULT_VALUES.alignContent },
                reverse: { type: 'boolean', default: DEFAULT_VALUES.reverse }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    gap: {
                        type: 'number'
                    }
                }
            }
        })
    ], StackLayout);
    exports.StackLayout = StackLayout;
    let HStack = class HStack extends StackLayout {
        constructor(parent, options) {
            super(parent, options);
        }
        get horizontalAlignment() {
            return this._horizontalAlignment;
        }
        set horizontalAlignment(value) {
            this._horizontalAlignment = value || 'start';
            this.justifyContent = value;
        }
        get verticalAlignment() {
            return this._verticalAlignment;
        }
        set verticalAlignment(value) {
            this._verticalAlignment = value || 'stretch';
            this.alignItems = value;
        }
        init() {
            super.init();
            this.direction = 'horizontal';
            (0, base_3.setAttributeToProperty)(this, 'horizontalAlignment');
            (0, base_3.setAttributeToProperty)(this, 'verticalAlignment');
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    HStack = __decorate([
        (0, base_3.customElements)('i-hstack', {
            icon: 'square',
            group: types_1.GroupType.LAYOUT,
            className: 'HStack',
            props: {
                gap: { type: 'number' },
                wrap: { type: 'string', default: DEFAULT_VALUES.wrap },
                justifyContent: { type: 'string', default: DEFAULT_VALUES.justifyContent },
                alignItems: { type: 'string', default: DEFAULT_VALUES.alignItems },
                alignSelf: { type: 'string', default: DEFAULT_VALUES.alignSelf },
                alignContent: { type: 'string', default: DEFAULT_VALUES.alignContent },
                reverse: { type: 'boolean', default: DEFAULT_VALUES.reverse }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    gap: {
                        type: 'number'
                    }
                }
            }
        })
    ], HStack);
    exports.HStack = HStack;
    let VStack = class VStack extends StackLayout {
        constructor(parent, options) {
            super(parent, options);
        }
        get horizontalAlignment() {
            return this._horizontalAlignment;
        }
        set horizontalAlignment(value) {
            this._horizontalAlignment = value || 'stretch';
            this.alignItems = value;
        }
        get verticalAlignment() {
            return this._verticalAlignment;
        }
        set verticalAlignment(value) {
            this._verticalAlignment = value || 'start';
            this.justifyContent = value;
        }
        init() {
            super.init();
            this.direction = 'vertical';
            (0, base_3.setAttributeToProperty)(this, 'horizontalAlignment');
            (0, base_3.setAttributeToProperty)(this, 'verticalAlignment');
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    VStack = __decorate([
        (0, base_3.customElements)('i-vstack', {
            icon: 'square',
            group: types_1.GroupType.LAYOUT,
            className: 'VStack',
            props: {
                gap: { type: 'number' },
                wrap: { type: 'string', default: DEFAULT_VALUES.wrap },
                justifyContent: { type: 'string', default: DEFAULT_VALUES.justifyContent },
                alignItems: { type: 'string', default: DEFAULT_VALUES.alignItems },
                alignSelf: { type: 'string', default: DEFAULT_VALUES.alignSelf },
                alignContent: { type: 'string', default: DEFAULT_VALUES.alignContent },
                reverse: { type: 'boolean', default: DEFAULT_VALUES.reverse }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    gap: {
                        type: 'number'
                    }
                }
            }
        })
    ], VStack);
    exports.VStack = VStack;
});
define("@ijstech/layout/panel.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout/style/panel.css.ts", "@ijstech/types"], function (require, exports, base_4, panel_css_2, types_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Panel = void 0;
    let Panel = class Panel extends base_4.Container {
        constructor(parent, options) {
            super(parent, options);
        }
        get hover() {
            return this._hover;
        }
        set hover(value) {
            this._hover = value;
            if (this._hover) {
                const hoverStyle = (0, panel_css_2.getHoverStyleClass)(this._hover);
                this.setStyle('hover', hoverStyle);
            }
            else {
                this.removeStyle('hover');
            }
        }
        removeStyle(propertyName) {
            let style = this.propertyClassMap[propertyName];
            if (style)
                this.classList.remove(style);
        }
        setStyle(propertyName, value) {
            this.removeStyle(propertyName);
            if (value) {
                this.propertyClassMap[propertyName] = value;
                this.classList.add(value);
            }
        }
        init() {
            super.init();
            (0, base_4.setAttributeToProperty)(this, 'hover');
            this.classList.add(panel_css_2.panelStyle);
            if (this.dock) {
                // For absolute positioning
                this.classList.add(panel_css_2.overflowStyle);
            }
        }
        connectedCallback() {
            if (this.connected) {
                return;
            }
            super.connectedCallback();
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Panel = __decorate([
        (0, base_4.customElements)('i-panel', {
            icon: 'stop',
            group: types_2.GroupType.LAYOUT,
            className: 'Panel',
            props: {},
            events: {}
        })
    ], Panel);
    exports.Panel = Panel;
});
define("@ijstech/layout/grid.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout/style/panel.css.ts", "@ijstech/types"], function (require, exports, base_5, panel_css_3, types_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridLayout = exports.gridProps = exports.gridSchemaProps = void 0;
    ;
    const DEFAULT_VALUES = {
        autoFillInHoles: false,
        columnsPerRow: 1,
        horizontalAlignment: 'start',
        verticalAlignment: 'start',
        gap: {}
    };
    exports.gridSchemaProps = {
        templateColumns: {
            type: 'array',
            items: { type: 'string' }
        },
        templateRows: {
            type: 'array',
            items: { type: 'string' }
        },
        templateAreas: {
            type: 'array',
            items: { type: 'array', items: { type: 'string' } }
        },
        autoColumnSize: {
            type: 'string',
            default: ''
        },
        autoRowSize: {
            type: 'string',
            default: ''
        },
        columnsPerRow: {
            type: 'number',
            default: DEFAULT_VALUES.columnsPerRow
        },
        gap: {
            type: 'object',
            properties: {
                row: {
                    type: 'string',
                    default: ''
                },
                column: {
                    type: 'string',
                    default: ''
                }
            }
        },
        autoFillInHoles: {
            type: 'boolean',
            default: DEFAULT_VALUES.autoFillInHoles
        },
        horizontalAlignment: {
            type: 'string',
            enum: ['stretch', 'start', 'end', 'center'],
            default: DEFAULT_VALUES.horizontalAlignment
        },
        verticalAlignment: {
            type: 'string',
            enum: ['stretch', 'start', 'end', 'center', 'baseline'],
            default: DEFAULT_VALUES.verticalAlignment
        }
    };
    exports.gridProps = {
        templateColumns: { type: 'array' },
        templateRows: { type: 'array' },
        templateAreas: { type: 'array' },
        autoColumnSize: { type: 'string', default: '' },
        autoRowSize: { type: 'string', default: '' },
        columnsPerRow: { type: 'number', default: DEFAULT_VALUES.columnsPerRow },
        gap: { type: 'object' },
        autoFillInHoles: { type: 'boolean', default: DEFAULT_VALUES.autoFillInHoles },
        horizontalAlignment: { type: 'string', default: DEFAULT_VALUES.horizontalAlignment },
        verticalAlignment: { type: 'string', default: DEFAULT_VALUES.verticalAlignment },
    };
    let GridLayout = class GridLayout extends base_5.Container {
        constructor(parent, options) {
            super(parent, options);
            this._styleClassMap = {};
            this.removeStyleClass = this.removeStyleClass.bind(this);
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        get templateColumns() {
            return this._templateColumns;
        }
        set templateColumns(columns) {
            this._templateColumns = columns;
            this.removeStyleClass('columns');
            if (columns) {
                let style = (0, panel_css_3.getTemplateColumnsStyleClass)(columns);
                this._styleClassMap['columns'] = style;
                this.classList.add(style);
            }
        }
        get templateRows() {
            return this._templateRows;
        }
        set templateRows(rows) {
            this._templateRows = rows;
            this.removeStyleClass('rows');
            if (rows) {
                let style = (0, panel_css_3.getTemplateRowsStyleClass)(rows);
                this._styleClassMap['rows'] = style;
                this.classList.add(style);
            }
        }
        get templateAreas() {
            return this._templateAreas;
        }
        set templateAreas(value) {
            this._templateAreas = value;
            this.removeStyleClass('areas');
            if (value) {
                let style = (0, panel_css_3.getTemplateAreasStyleClass)(value);
                this._styleClassMap['areas'] = style;
                this.classList.add(style);
            }
        }
        get autoColumnSize() {
            return this._autoColumnSize;
        }
        set autoColumnSize(value) {
            this._autoColumnSize = value;
            if (value) {
                this.style.gridAutoColumns = value;
            }
        }
        get autoRowSize() {
            return this._autoRowSize;
        }
        set autoRowSize(value) {
            this._autoRowSize = value;
            if (value) {
                this.style.gridAutoRows = value;
            }
        }
        get columnsPerRow() {
            return this._columnsPerRow;
        }
        set columnsPerRow(value) {
            this._columnsPerRow = value;
            this.style.gridTemplateColumns = `repeat(${this._columnsPerRow}, 1fr)`;
        }
        get gap() {
            return this._gap;
        }
        set gap(value) {
            this._gap = value;
            if (value) {
                if (value.row) {
                    if (typeof value.row == 'number') {
                        this.style.rowGap = value.row + 'px';
                    }
                    else {
                        this.style.rowGap = value.row;
                    }
                }
                if (value.column) {
                    if (typeof value.column == 'number') {
                        this.style.columnGap = value.column + 'px';
                    }
                    else {
                        this.style.columnGap = value.column;
                    }
                }
            }
        }
        get horizontalAlignment() {
            return this._horizontalAlignment;
        }
        set horizontalAlignment(value) {
            this._horizontalAlignment = value;
            this.style.justifyItems = value;
        }
        removeStyle(propertyName) {
            let style = this.propertyClassMap[propertyName];
            if (style)
                this.classList.remove(style);
        }
        setStyle(propertyName, value) {
            this.removeStyle(propertyName);
            if (value) {
                this.propertyClassMap[propertyName] = value;
                this.classList.add(value);
            }
        }
        get justifyContent() {
            return this._justifyContent;
        }
        set justifyContent(value) {
            this._justifyContent = value || 'start';
            switch (this._justifyContent) {
                case 'start':
                    this.setStyle('justifyContent', panel_css_3.justifyContentStartStyle);
                    break;
                case 'center':
                    this.setStyle('justifyContent', panel_css_3.justifyContentCenterStyle);
                    break;
                case 'end':
                    this.setStyle('justifyContent', panel_css_3.justifyContentEndStyle);
                    break;
                case 'space-between':
                    this.setStyle('justifyContent', panel_css_3.justifyContentSpaceBetweenStyle);
                    break;
                case 'space-around':
                    this.setStyle('justifyContent', panel_css_3.justifyContentSpaceAroundStyle);
                    break;
                case 'space-evenly':
                    this.setStyle('justifyContent', panel_css_3.justifyContentSpaceEvenlyStyle);
                    break;
            }
        }
        get verticalAlignment() {
            return this._verticalAlignment;
        }
        set verticalAlignment(value) {
            this._verticalAlignment = value;
            this.style.alignItems = value;
        }
        get autoFillInHoles() {
            return this._autoFillInHoles;
        }
        set autoFillInHoles(value) {
            this._autoFillInHoles = value;
            this.style.gridAutoFlow = this._autoFillInHoles ? 'dense' : 'row';
        }
        get autoFlow() {
            return this._autoFlow;
        }
        set autoFlow(value) {
            this._autoFlow = value;
            this.style.gridAutoFlow = value;
        }
        get mediaQueries() {
            return this._mediaQueries;
        }
        set mediaQueries(value) {
            this._mediaQueries = value;
            let style = (0, panel_css_3.getGridLayoutMediaQueriesStyleClass)(this._mediaQueries);
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        setAttributeToProperty(propertyName) {
            const prop = this.getAttribute(propertyName, true);
            // if (this.id=='thisPnl') {console.log(propertyName, prop)}
            if (prop)
                this[propertyName] = prop;
        }
        removeStyleClass(name) {
            if (this._styleClassMap && this._styleClassMap[name]) {
                this.classList.remove(this._styleClassMap[name]);
                delete this._styleClassMap[name];
            }
        }
        init() {
            super.init();
            this._styleClassMap = {};
            this.classList.add(panel_css_3.gridStyle);
            this.setAttributeToProperty('templateColumns');
            this.setAttributeToProperty('templateRows');
            this.setAttributeToProperty('templateAreas');
            this.setAttributeToProperty('gap');
            this.setAttributeToProperty('horizontalAlignment');
            this.setAttributeToProperty('verticalAlignment');
            this.setAttributeToProperty('columnsPerRow');
            this.setAttributeToProperty('autoFillInHoles');
            this.setAttributeToProperty('autoFlow');
            this.setAttributeToProperty('autoColumnSize');
            this.setAttributeToProperty('autoRowSize');
            this.setAttributeToProperty('mediaQueries');
            this.setAttributeToProperty('justifyContent');
        }
    };
    GridLayout = __decorate([
        (0, base_5.customElements)('i-grid-layout', {
            icon: 'th',
            group: types_3.GroupType.LAYOUT,
            className: 'GridLayout',
            props: {
                ...exports.gridProps
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: { ...exports.gridSchemaProps }
            }
        })
    ], GridLayout);
    exports.GridLayout = GridLayout;
});
define("@ijstech/layout/card.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout/grid.ts", "@ijstech/types"], function (require, exports, base_6, grid_1, types_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CardLayout = void 0;
    let CardLayout = class CardLayout extends grid_1.GridLayout {
        constructor(parent, options) {
            super(parent, options);
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        get cardMinWidth() {
            return this._cardMinWidth;
        }
        set cardMinWidth(value) {
            this._cardMinWidth = typeof value == 'number' ? value + 'px' : value;
            this.updateGridTemplateColumns();
        }
        get columnsPerRow() {
            return this._columnsPerRow;
        }
        set columnsPerRow(value) {
            this._columnsPerRow = value;
            this.updateGridTemplateColumns();
        }
        get cardHeight() {
            return this._cardHeight;
        }
        set cardHeight(value) {
            this._cardHeight = typeof value == 'number' ? value + 'px' : value;
            this.style.gridAutoRows = this._cardHeight;
        }
        updateGridTemplateColumns() {
            if (this.cardMinWidth && this.columnsPerRow) {
                let minmaxFirstParam = (this.gap && this.gap.column) ? `max(${this.cardMinWidth}, calc(100%/${this.columnsPerRow} - ${this.gap.column}))` : `max(${this.cardMinWidth}, 100%/${this.columnsPerRow})`;
                this.style.gridTemplateColumns = `repeat(auto-fill, minmax(${minmaxFirstParam}, 1fr))`;
            }
            else if (this.cardMinWidth) {
                this.style.gridTemplateColumns = `repeat(auto-fill, minmax(min(${this.cardMinWidth}, 100%), 1fr))`;
            }
            else if (this.columnsPerRow) {
                this.style.gridTemplateColumns = `repeat(${this.columnsPerRow}, 1fr)`;
            }
        }
        setAttributeToProperty(propertyName) {
            const prop = this.getAttribute(propertyName, true);
            if (prop)
                this[propertyName] = prop;
        }
        init() {
            super.init();
            this.autoRowSize = '1fr';
            this.setAttributeToProperty('cardMinWidth');
            this.setAttributeToProperty('cardHeight');
        }
    };
    CardLayout = __decorate([
        (0, base_6.customElements)('i-card-layout', {
            icon: 'th',
            group: types_4.GroupType.LAYOUT,
            className: 'CardLayout',
            props: {
                ...grid_1.gridProps,
                cardMinWidth: { type: 'number' },
                cardHeight: { type: 'number' },
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    ...grid_1.gridSchemaProps,
                    cardMinWidth: {
                        type: 'number'
                    },
                    cardHeight: {
                        type: 'number'
                    }
                }
            }
        })
    ], CardLayout);
    exports.CardLayout = CardLayout;
});
define("@ijstech/layout", ["require", "exports", "@ijstech/layout/stack.ts", "@ijstech/layout/panel.ts", "@ijstech/layout/card.ts", "@ijstech/layout/grid.ts"], function (require, exports, stack_1, panel_1, card_1, grid_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridLayout = exports.CardLayout = exports.Panel = exports.HStack = exports.VStack = exports.StackLayout = void 0;
    Object.defineProperty(exports, "StackLayout", { enumerable: true, get: function () { return stack_1.StackLayout; } });
    Object.defineProperty(exports, "VStack", { enumerable: true, get: function () { return stack_1.VStack; } });
    Object.defineProperty(exports, "HStack", { enumerable: true, get: function () { return stack_1.HStack; } });
    Object.defineProperty(exports, "Panel", { enumerable: true, get: function () { return panel_1.Panel; } });
    Object.defineProperty(exports, "CardLayout", { enumerable: true, get: function () { return card_1.CardLayout; } });
    Object.defineProperty(exports, "GridLayout", { enumerable: true, get: function () { return grid_2.GridLayout; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/color/utils.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hslToHsv = exports.hsvToHsl = exports.customRound = exports.isPercentValid = exports.isHValid = exports.isRgbValid = exports.convertColor = exports.getUnitValues = exports.rgbaToHsla = exports.hslaToRgba = exports.rgbToHex = exports.hslaToHex = exports.stringToArr = void 0;
    ///<amd-module name='@ijstech/color/utils.ts'/> 
    function stringToArr(color, isRgb) {
        const formatted = isRgb ? color.replace(/^rgba?\(|\)$/g, '') : color.replace(/^hsla?\(|\)$/g, '');
        const separator = formatted.includes(",") ? "," : " ";
        let rgba = formatted.split(separator);
        if (rgba.includes("/"))
            rgba.splice(3, 1);
        if (!isRgb)
            return rgba;
        for (let R in rgba) {
            const r = rgba[R];
            if (r.includes("%")) {
                const p = (+r.substr(0, r.length - 1)) / 100;
                if (+R < 3) {
                    rgba[R] = Math.round(p * 255).toString();
                }
                else {
                    rgba[R] = p.toString();
                }
            }
        }
        return rgba;
    }
    exports.stringToArr = stringToArr;
    function hslaToHex(h, s, l, a) {
        const { r, g, b } = hslaToRgba(h, s, l);
        return rgbToHex([
            r.toString(),
            g.toString(),
            b.toString(),
            a.toString(),
        ]);
    }
    exports.hslaToHex = hslaToHex;
    function rgbToHex(rgba) {
        let r = (+rgba[0]).toString(16);
        let g = (+rgba[1]).toString(16);
        let b = (+rgba[2]).toString(16);
        if (r.length === 1)
            r = "0" + r;
        if (g.length === 1)
            g = "0" + g;
        if (b.length === 1)
            b = "0" + b;
        let a = '';
        if (rgba[3]) {
            a = Math.round((+rgba[3]) * 255).toString(16);
            if (a.length === 1)
                a = "0" + a;
        }
        return "#" + r + g + b + a;
    }
    exports.rgbToHex = rgbToHex;
    function hslaToRgba(h, s, l) {
        h = h % 360;
        s = s / 100;
        l = l / 100;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const hueSegment = h / 60;
        const x = chroma * (1 - Math.abs(hueSegment % 2 - 1));
        let r, g, b;
        if (hueSegment >= 0 && hueSegment < 1) {
            r = chroma;
            g = x;
            b = 0;
        }
        else if (hueSegment >= 1 && hueSegment < 2) {
            r = x;
            g = chroma;
            b = 0;
        }
        else if (hueSegment >= 2 && hueSegment < 3) {
            r = 0;
            g = chroma;
            b = x;
        }
        else if (hueSegment >= 3 && hueSegment < 4) {
            r = 0;
            g = x;
            b = chroma;
        }
        else if (hueSegment >= 4 && hueSegment < 5) {
            r = x;
            g = 0;
            b = chroma;
        }
        else {
            r = chroma;
            g = 0;
            b = x;
        }
        const lightnessAdjustment = l - chroma / 2;
        r += lightnessAdjustment;
        g += lightnessAdjustment;
        b += lightnessAdjustment;
        r = Math.round(r * 255);
        g = Math.round(g * 255);
        b = Math.round(b * 255);
        return { r, g, b };
    }
    exports.hslaToRgba = hslaToRgba;
    function rgbaToHsla(r, g, b) {
        r = r < 0 ? 0 : r > 255 ? 255 : r;
        g = g < 0 ? 0 : g > 255 ? 255 : g;
        b = b < 0 ? 0 : b > 255 ? 255 : b;
        r = r / 255;
        g = g / 255;
        b = b / 255;
        let min = Math.min(r, g, b);
        let max = Math.max(r, g, b);
        let delta = max - min;
        let h = 0;
        let s;
        let l;
        if (max == min) {
            h = 0;
        }
        else if (r == max) {
            h = (g - b) / delta;
        }
        else if (g == max) {
            h = 2 + (b - r) / delta;
        }
        else if (b == max) {
            h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0)
            h += 360;
        l = (min + max) / 2;
        if (max == min)
            s = 0;
        else if (l <= 0.5)
            s = delta / (max + min);
        else
            s = delta / (2 - max - min);
        return {
            h: Math.round(h),
            s: Math.round(s * 100),
            l: Math.round(l * 100)
        };
    }
    exports.rgbaToHsla = rgbaToHsla;
    function getUnitValues(h, s, l, a) {
        return {
            h,
            s,
            l,
            a,
            ...hslaToRgba(h, s, l),
            hex: hslaToHex(h, s, l, a),
            isValid: true
        };
    }
    exports.getUnitValues = getUnitValues;
    function getRgba(h) {
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 1;
        if (h.length === 4 || h.length === 5) {
            r = "0x" + h[1] + h[1];
            g = "0x" + h[2] + h[2];
            b = "0x" + h[3] + h[3];
            if (h.length === 5)
                a = "0x" + h[4] + h[4];
        }
        else if (h.length === 7 || h.length == 9) {
            r = "0x" + h[1] + h[2];
            g = "0x" + h[3] + h[4];
            b = "0x" + h[5] + h[6];
            if (h.length === 9)
                a = "0x" + h[7] + h[8];
        }
        if (a !== 1)
            a = +(a / 255).toFixed(3);
        return { r: +r, g: +g, b: +b, a };
    }
    function convertColor(color) {
        let result = {};
        if (/^rgb/.test(color)) {
            const rgb = stringToArr(color, true);
            const r = Number(rgb[0]);
            const g = Number(rgb[1]);
            const b = Number(rgb[2]);
            const a = Number(rgb[3] ?? 1);
            result = {
                r,
                g,
                b,
                a,
                hex: rgbToHex(rgb),
                ...rgbaToHsla(r, g, b)
            };
        }
        else if (/^#/i.test(color)) {
            if (!isHexColorValid(color))
                return { isValid: false, hex: color };
            const { r, g, b, a } = getRgba(color);
            result = {
                hex: color,
                r,
                g,
                b,
                a,
                ...rgbaToHsla(r, g, b)
            };
        }
        else if (/^hsl/i.test(color)) {
            const hsla = stringToArr(color, false);
            const h = Number(hsla[0] ?? 0);
            const s = Number((hsla[1] || '').replace('%', ''));
            const l = Number((hsla[2] || '').replace('%', ''));
            const a = Number(hsla[3] ?? 1);
            result = {
                h,
                s,
                l,
                a,
                hex: hslaToHex(h, s, l, a),
                ...hslaToRgba(h, s, l)
            };
        }
        return { ...result, isValid: true };
    }
    exports.convertColor = convertColor;
    function isHexColorValid(color) {
        const hexRegex = /^#([A-Fa-f0-9]{3,4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/i;
        return hexRegex.test(color);
    }
    function isRgbValid(value) {
        const regex = /^[0-9]{1,3}$/i;
        return regex.test(value) && +value >= 0 && +value <= 255;
    }
    exports.isRgbValid = isRgbValid;
    function isHValid(value) {
        const regex = /^[0-9]{1,3}$/i;
        return regex.test(value) && +value >= 0 && +value <= 360;
    }
    exports.isHValid = isHValid;
    function isPercentValid(value) {
        const regex = /^(\d\d?(\.\d+)?|\.\d+|100)%$/i;
        return regex.test(value);
    }
    exports.isPercentValid = isPercentValid;
    function customRound(value, threshold) {
        const roundedValue = Math.round(value);
        const decimalPart = value % 1;
        if (decimalPart > threshold) {
            return roundedValue + 1;
        }
        else {
            return roundedValue;
        }
    }
    exports.customRound = customRound;
    function hsvToHsl(h, s, v) {
        const _h = h;
        const _s = s / 100;
        const _v = v / 100;
        const r = Math.max(_v, 0.01);
        let o;
        let _l = ((2 - _s) * _v) / 2;
        const lmin = (2 - _s) * r;
        o = _s * r;
        o /= (lmin <= 1) ? lmin : 2 - lmin;
        o = o || 0;
        return {
            h: Math.round(_h),
            s: Math.round(o * 100),
            l: Math.round(_l * 100)
        };
    }
    exports.hsvToHsl = hsvToHsl;
    function hslToHsv(h, s, l) {
        const _h = h;
        let _s = s / 100;
        let _l = l / 100;
        const r = Math.max(_l, 0.01);
        let smin = _s;
        _l *= 2;
        _s *= _l <= 1 ? _l : 2 - _l;
        smin *= r <= 1 ? r : 2 - r;
        return {
            h: Math.round(_h),
            s: Math.round((_l === 0 ? (2 * smin) / (r + smin) : (2 * _s) / (_l + _s)) * 100),
            v: Math.round(((_l + _s) / 2) * 100)
        };
    }
    exports.hslToHsv = hslToHsv;
});
define("@ijstech/color/style/color.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    const gradient = 'linear-gradient(to right, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)';
    const opacity = `var(--opacity-color, linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgb(0, 0, 0) 100%))`;
    Styles.cssRule('i-color', {
        $nest: {
            '.i-color': {
                minHeight: 25,
                height: '100%',
                position: 'relative',
                display: 'inline-flex',
                alignItems: 'center'
            },
            '.input-span': {
                height: '100%',
                minWidth: 100,
                display: 'inline-flex',
                alignItems: 'center',
                border: `1px solid ${Theme.divider}`,
                padding: 4,
                $nest: {
                    'span': {
                        background: 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=) #fff',
                        height: '100%',
                        width: '100%',
                        minHeight: 12,
                        display: 'inline-block'
                    }
                }
            },
            '.color-picker-modal': {
                $nest: {
                    '.custom-range': {
                        $nest: {
                            'input[type="range"]::-webkit-slider-thumb': {
                                backgroundColor: 'rgb(248, 248, 248)',
                                width: 12,
                                height: 12,
                                marginTop: -3,
                                boxShadow: 'rgba(0, 0, 0, 0.37) 0px 1px 4px 0px'
                            },
                            'input[type="range"]': {
                                borderRadius: 2,
                                opacity: 1,
                                height: 7
                            },
                            'input[type="range"]::-webkit-slider-runnable-track': {
                                borderRadius: 2,
                                opacity: 1,
                                height: 7,
                                marginLeft: -7,
                                marginRight: -7
                            }
                        }
                    },
                    '.color-palette': {
                        $nest: {
                            'input[type="range"]': {
                                backgroundImage: gradient
                            },
                            'input[type="range"]::-webkit-slider-runnable-track': {
                                background: gradient
                            }
                        }
                    },
                    '.color-slider': {
                        $nest: {
                            'input[type="range"]': {
                                backgroundImage: opacity,
                                background: `url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=") left center, ${opacity}`
                            },
                            'input[type="range"]::-webkit-slider-runnable-track': {
                                background: `url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=") left center, var(--opacity-color)`
                            }
                        }
                    },
                    '.pnl-select': {
                        'boxShadow': 'rgba(0, 0, 0, 0.3) 0px 0px 2px, rgba(0, 0, 0, 0.3) 0px 4px 8px'
                    },
                    '.color-picker': {
                        justifyContent: 'center',
                        alignItems: 'center'
                    },
                    '.color-input-group': {
                        width: 165,
                        display: 'flex',
                        gap: '2px',
                        flex: '1'
                    },
                    '.color-input': {
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: 12,
                        $nest: {
                            'input': {
                                fontSize: 11,
                                width: '100%',
                                borderRadius: 2,
                                border: 'none',
                                boxShadow: 'rgb(218, 218, 218) 0px 0px 0px 1px inset',
                                height: 20,
                                textAlign: 'center',
                                letterSpacing: 1.5
                            },
                            'span': {
                                fontSize: 11
                            }
                        }
                    },
                    '.selected-color': {
                        position: 'relative',
                        width: 24,
                        height: 24,
                        borderRadius: '50%',
                        boxShadow: 'rgba(0, 0, 0, 0.1) 0px 0px 0px 1px inset',
                        background: `url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=") left center`,
                        overflow: 'hidden',
                        $nest: {
                            'i-panel': {
                                backgroundColor: 'var(--selected-color)'
                            }
                        }
                    },
                    '.color-preview': {
                        userSelect: 'none',
                        touchAction: 'none',
                        $nest: {
                            '> i-panel': {
                                width: '100%',
                                height: '100%',
                                position: 'absolute',
                                inset: '0px',
                                background: 'linear-gradient(to right, rgb(255, 255, 255), rgba(255, 255, 255, 0))',
                                $nest: {
                                    '> i-panel': {
                                        width: '100%',
                                        height: '100%',
                                        position: 'absolute',
                                        inset: '0px',
                                        background: 'linear-gradient(to top, rgb(0, 0, 0), rgba(0, 0, 0, 0))'
                                    }
                                }
                            },
                            '#iconPointer': {
                                width: 12,
                                height: 12,
                                borderRadius: '50%',
                                boxShadow: 'rgb(255, 255, 255) 0px 0px 0px 1.25px',
                                transform: 'translate(-6px, -6px)',
                                position: 'absolute',
                                cursor: 'default',
                                top: 0,
                                left: 0,
                                $nest: {
                                    '&::before': {
                                        width: 12,
                                        height: 12,
                                        content: '""',
                                        position: 'absolute',
                                        borderRadius: '50%',
                                        boxShadow: 'rgb(128, 128, 128) 0px 0px 0px 0.75px inset',
                                    }
                                }
                            }
                        }
                    },
                    'i-icon svg': {
                        fill: 'inherit'
                    },
                    '.modal': {
                        paddingBlock: 0,
                        backgroundColor: 'transparent'
                    }
                }
            }
        }
    });
});
define("@ijstech/color/color.ts", ["require", "exports", "@ijstech/base", "@ijstech/modal", "@ijstech/layout", "@ijstech/range", "@ijstech/icon", "@ijstech/color/utils.ts", "@ijstech/style", "@ijstech/types", "@ijstech/application", "@ijstech/color/style/color.css.ts"], function (require, exports, base_1, modal_1, layout_1, range_1, icon_1, utils_1, Styles, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPicker = void 0;
    let Theme = Styles.Theme.ThemeVars;
    const rgb = ['r', 'g', 'b', 'a'];
    const hsl = ['h', 's', 'l', 'a'];
    const hex = ['hex'];
    const formatList = ['hex', 'rgb', 'hsl'];
    const formatMap = { hex, rgb, hsl };
    // type FormatType = 'hex' | 'rgb' | 'hsl';
    const DEFAULT_COLOR = '#000';
    const DEFAULT_BG_COLOR = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=) #fff';
    let ColorPicker = class ColorPicker extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this._format = 0;
            this.inputMap = new Map();
            this.currentH = 0;
            this.currentColor = {
                h: 0, s: 0, l: 0,
                r: 0, g: 0, b: 0,
                a: 1,
                hex: DEFAULT_COLOR
            };
            this.currentPalette = 'rgb(255, 0, 0)';
        }
        get value() {
            return this.currentColor?.hex || '';
        }
        set value(color) {
            const data = (0, utils_1.convertColor)(color);
            if (data.isValid)
                this.currentColor = { ...data };
            this.updateUI(true);
            this.updateIconPointer();
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionSpanElm && this._caption?.startsWith('$'))
                this.captionSpanElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            const value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(this._caption) ||
                    application_1.application.i18n?.get(this._caption) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this.captionSpanElm.style.display = !value ? 'none' : '';
            if (!this.captionSpanElm)
                return;
            this.captionSpanElm.textContent = this.caption;
        }
        get captionWidth() {
            return this._captionWidth;
        }
        set captionWidth(value) {
            if (!value)
                return;
            this._captionWidth = value;
            this.setElementPosition(this.captionSpanElm, 'width', value);
        }
        get height() {
            return this.offsetHeight;
        }
        set height(value) {
            this.setPosition('height', value);
        }
        async init() {
            if (!this.wrapperElm) {
                super.init();
                this.onChanged = this.getAttribute('onChanged', true) || this.onChanged;
                this.onClosed = this.getAttribute('onClosed', true) || this.onClosed;
                this.handleMouseUp = this.handleMouseUp.bind(this);
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.wrapperElm = this.createElement('div', this);
                this.wrapperElm.classList.add('i-color');
                this.captionSpanElm = this.createElement('span', this.wrapperElm);
                this.captionWidth = this.getAttribute('captionWidth', true);
                this.caption = this.getAttribute('caption', true);
                this.mdColorPicker = await modal_1.Modal.create({
                    popupPlacement: 'bottomLeft',
                    closeOnBackdropClick: true,
                    width: 'auto',
                    minWidth: 230,
                    showBackdrop: false,
                    // isChildFixed: true,
                    onClose: this.onClosePicker.bind(this)
                });
                this.mdColorPicker.onOpen = this.onOpenPicker.bind(this);
                this.mdColorPicker.classList.add('color-picker-modal');
                this.wrapperElm.appendChild(this.mdColorPicker);
                const item = await layout_1.Panel.create();
                item.classList.add('pnl-select');
                await this.createPreview();
                item.appendChild(this.pnlShown);
                this.pnlWrap = await layout_1.Panel.create({
                    padding: { top: '1rem', left: '1rem', right: '1rem', bottom: '0.75rem' },
                    width: '100%',
                    background: { color: '#fff' }
                });
                item.appendChild(this.pnlWrap);
                this.mdColorPicker.item = item;
                await this.createPicker();
                const valueElm = this.createElement('span', this.wrapperElm);
                valueElm.classList.add('input-span');
                valueElm.addEventListener('click', () => {
                    if (!this.enabled || this._designMode)
                        return;
                    const isVisible = this.mdColorPicker.visible;
                    if (!isVisible) {
                        this.updateIconPointer();
                    }
                    this.mdColorPicker.visible = !this.mdColorPicker.visible;
                });
                this.inputSpanElm = this.createElement('span', valueElm);
                this.inputSpanElm.style.background = this.value || DEFAULT_BG_COLOR;
                const value = this.getAttribute('value', true);
                if (value !== undefined)
                    this.value = value;
            }
        }
        onOpenPicker() {
            this.isValueChanged = false;
            document.addEventListener('mouseup', this.handleMouseUp);
            document.addEventListener('mousemove', this.handleMouseMove);
        }
        onClosePicker() {
            if (typeof this.onClosed === 'function' && this.isValueChanged) {
                this.onClosed();
            }
            if (this.inputSpanElm)
                this.inputSpanElm.style.background = this.value || DEFAULT_BG_COLOR;
            this.isMousePressed = false;
            document.removeEventListener('mouseup', this.handleMouseUp);
            document.removeEventListener('mousemove', this.handleMouseMove);
        }
        createInputGroup() {
            let wrapElm = this.pnlInput.querySelector('.color-input-group');
            if (!wrapElm) {
                wrapElm = this.createElement('div', this.pnlInput);
                wrapElm.classList.add('color-input-group');
            }
            wrapElm.innerHTML = '';
            const formatType = formatList[this._format] || '';
            const list = formatMap[formatType];
            for (let item of list) {
                const inputWrap = this.createElement('div', wrapElm);
                inputWrap.classList.add('color-input');
                const input = this.createElement('input', inputWrap);
                let value = this.currentColor[item];
                if (item === 's' || item === 'l')
                    value = (value ?? '') + '%';
                input.value = value !== undefined ? value : (item === 'a' ? '1' : '');
                input.addEventListener('input', (event) => this.onInputChanged(event, item));
                this.inputMap.set(item, input);
                const span = this.createElement('span', inputWrap);
                span.style.textTransform = 'uppercase';
                span.style.color = '#222';
                span.innerHTML = item;
            }
        }
        async createPreview() {
            this.pnlShown = await layout_1.Panel.create({
                height: 136,
                width: '100%',
                minWidth: 232,
                overflow: 'hidden',
                background: { color: this.currentPalette || '' }
            });
            this.pnlShown.innerHTML = `
      <i-panel>
        <i-panel>
          <i-panel id="iconPointer"></i-panel>
        </i-panel>
      </i-panel>
    `;
            this.pnlShown.classList.add('color-preview');
            this.pnlShown.onClick = this.onColorSelected.bind(this);
        }
        _handleMouseDown(event) {
            const target = event.target;
            this.isMousePressed = this.pnlShown.contains(target);
            return false;
        }
        handleMouseMove(event) {
            if (this.isMousePressed) {
                this.onColorSelected(this.pnlShown, event);
            }
        }
        handleMouseUp(event) {
            this.isMousePressed = false;
        }
        async createPicker() {
            const picker = await layout_1.GridLayout.create({
                gap: { column: '0.5rem', row: '0.5rem' },
                templateAreas: [['picker', 'selected', 'palette'], ['picker', 'selected', 'slider']],
                templateColumns: ['14px', '30px', '120px'],
                margin: { bottom: '1rem' }
            });
            picker.classList.add('color-picker');
            const pickerIcon = await icon_1.Icon.create({
                name: 'eye-dropper',
                width: 13,
                height: 13,
                fill: '#222'
            });
            pickerIcon.style.gridArea = 'picker';
            pickerIcon.onClick = () => this.activeEyeDropper(pickerIcon);
            const colorSelectedWrapper = await layout_1.Panel.create();
            colorSelectedWrapper.classList.add('selected-color');
            colorSelectedWrapper.style.gridArea = 'selected';
            this.colorSelected = await layout_1.Panel.create({
                position: 'absolute',
                width: '100%',
                height: '100%'
            });
            const { h, s, l, a, r = 0, g = 0, b = 0 } = this.currentColor;
            let paletteValue = h || 0;
            paletteValue = paletteValue > 360 ? 360 : paletteValue;
            colorSelectedWrapper.appendChild(this.colorSelected);
            this.colorPalette = await range_1.Range.create({
                width: '100%',
                height: 10,
                min: 0,
                max: 360,
                step: 1,
                value: paletteValue
            });
            this.colorPalette.onChanged = this.onPaletteChanged.bind(this);
            this.colorPalette.classList.add('custom-range', 'color-palette');
            this.colorPalette.style.gridArea = 'palette';
            this.mdColorPicker.style.setProperty('--opacity-color', `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgb(${r}, ${g}, ${b}) 100%)`);
            if (h !== undefined) {
                this.mdColorPicker.style.setProperty('--selected-color', `hsla(${h}, ${s}%, ${l}%, ${a})`);
            }
            this.colorSlider = await range_1.Range.create({
                width: '100%',
                height: 10,
                min: 0,
                max: 1,
                value: a ?? 1,
                step: 0.01
            });
            this.colorSlider.onChanged = this.onSliderChanged.bind(this);
            this.colorSlider.classList.add('custom-range', 'color-slider');
            this.colorSlider.style.gridArea = 'slider';
            picker.append(pickerIcon, colorSelectedWrapper, this.colorPalette, this.colorSlider);
            this.pnlInput = await layout_1.HStack.create({
                alignItems: 'center',
                gap: '0.5rem'
            });
            this.createInputGroup();
            const icons = await layout_1.VStack.create({
                justifyContent: 'center',
                alignItems: 'center',
                maxHeight: 50
            });
            const topIcon = await icon_1.Icon.create({
                name: 'angle-up',
                fill: '#000',
                width: 16,
                height: 16
            });
            topIcon.classList.add('pointer');
            topIcon.onClick = () => this.onToggleFormat(-1);
            const bottomIcon = await icon_1.Icon.create({
                name: 'angle-down',
                fill: '#000',
                width: 16,
                height: 16
            });
            bottomIcon.classList.add('pointer');
            bottomIcon.onClick = () => this.onToggleFormat(1);
            icons.append(topIcon, bottomIcon);
            this.pnlInput.appendChild(icons);
            this.pnlWrap.append(picker, this.pnlInput);
        }
        activeEyeDropper(pickerIcon) {
            pickerIcon.fill = Theme.colors.primary.main;
            const hasSupport = () => Boolean('EyeDropper' in window);
            if (hasSupport()) {
                const eyeDropper = new window.EyeDropper();
                eyeDropper
                    .open()
                    .then((result) => {
                    this.value = result.sRGBHex;
                    pickerIcon.fill = '#222';
                })
                    .catch((e) => {
                    pickerIcon.fill = '#222';
                });
            }
            else {
                console.warn('No Support: This browser does not support the EyeDropper API yet!');
            }
        }
        onPaletteChanged() {
            const value = this.colorPalette.value;
            this.setPalette(value);
            if (this.currentPalette) {
                this.pnlShown.background = { color: this.currentPalette };
                const rgbArr = (0, utils_1.stringToArr)(this.currentPalette, true);
                if (this.mdColorPicker)
                    this.mdColorPicker.style.setProperty('--opacity-color', `linear-gradient(to right, rgba(${rgbArr[0]}, ${rgbArr[1]}, ${rgbArr[2]}, 0) 0%, ${this.currentPalette} 100%)`);
                const { s, l } = this.currentColor;
                this.updateColor(this.currentH, s, l);
                // this.onColorSelected(this.pnlShown);
            }
        }
        onSliderChanged() {
            this.currentColor.a = this.colorSlider.value;
            this.updateHex();
            this.updateUI();
        }
        onToggleFormat(value) {
            const maxLength = formatList.length;
            this._format = (((this._format + value) % maxLength) + maxLength) % maxLength;
            this.createInputGroup();
        }
        updateIconPointer() {
            if (this.pnlShown) {
                const iconPointer = this.pnlShown.querySelector('#iconPointer');
                if (iconPointer) {
                    const { h, s, l } = this.currentColor;
                    const hsv = (0, utils_1.hslToHsv)(h, s, l);
                    const paletteWidth = this.pnlShown.offsetWidth;
                    const paletteHeight = this.pnlShown.offsetHeight;
                    const x = (hsv.s * paletteWidth / 100) | 0;
                    const y = paletteHeight - (hsv.v * paletteHeight / 100) | 0;
                    // const x = Math.round((s / 100) * paletteWidth);
                    // const y = Math.round(paletteHeight * (1 - (2 * l - ((1 - x / paletteWidth) * 100)) / 100 ));
                    // const y = Math.round((1 - l / 100) * paletteHeight);
                    iconPointer.style.left = `${x}px`;
                    iconPointer.style.top = `${y}px`;
                }
            }
        }
        onColorSelected(target, event) {
            const rect = target.getBoundingClientRect();
            let x = 160;
            let y = 60;
            if (event) {
                x = event.clientX < rect.left ? 0 : event.clientX > rect.right ? rect.width : event.clientX - rect.left;
                y = event.clientY < rect.top ? 0 : event.clientY > rect.bottom ? rect.height : event.clientY - rect.top;
            }
            const iconPointer = target.querySelector('#iconPointer');
            if (iconPointer) {
                iconPointer.style.top = `${y}px`;
                iconPointer.style.left = `${x}px`;
            }
            const paletteWidth = target.offsetWidth;
            const paletteHeight = target.offsetHeight;
            // const hue = Math.round((this.currentH / 100) * 360);
            // const saturation = Math.round((x / paletteWidth) * 100);
            // const lightness = Math.round(((1 - y / paletteHeight) + (1 - x / paletteWidth)) * 50);
            const hue = this.currentH;
            const saturation = x * 100 / paletteWidth | 0;
            const value = 100 - (y * 100 / paletteHeight) | 0;
            const hsl = (0, utils_1.hsvToHsl)(hue, saturation, value);
            this.updateColor(hsl.h, hsl.s, hsl.l);
        }
        updateColor(h, s, l) {
            const a = this.colorSlider.value;
            const data = (0, utils_1.getUnitValues)(h, s, l, a);
            if (data.isValid)
                this.updateCurrentColor(data);
        }
        updateCurrentColor(data, init = false) {
            if (data)
                this.currentColor = { ...data };
            this.updateUI(init);
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, this.value);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, this.value);
        }
        updateHex() {
            const { h = 0, s = 0, l = 0, a } = this.currentColor;
            this.currentColor.hex = (0, utils_1.hslaToHex)(h, s, l, a);
        }
        updateUI(init) {
            if (init)
                this.initUI();
            for (let unit in this.currentColor) {
                const input = this.inputMap.get(unit);
                if (!input)
                    continue;
                const hasSuffix = (unit === 's' || unit === 'l');
                input.value = `${this.currentColor[unit]}${hasSuffix ? '%' : ''}`;
            }
            const { h = 0, s = 0, l = 0, a = 1, r = 0, g = 0, b = 0, hex = '' } = this.currentColor;
            if (this.mdColorPicker) {
                this.mdColorPicker.style.setProperty('--selected-color', `hsla(${h}, ${s}%, ${l}%, ${a})`);
                this.mdColorPicker.style.setProperty('--opacity-color', `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgb(${r}, ${g}, ${b}) 100%)`);
            }
            const hexInput = this.inputMap.get('hex');
            if (hexInput)
                hexInput.value = hex || '';
            if (this.inputSpanElm)
                this.inputSpanElm.style.background = this.value || DEFAULT_BG_COLOR;
            this.isValueChanged = true;
        }
        initUI() {
            const { h, a } = this.currentColor || {};
            let paletteValue = h || 0;
            paletteValue = paletteValue > 360 ? 360 : paletteValue;
            this.setPalette(paletteValue);
            if (this.colorPalette)
                this.colorPalette.value = paletteValue;
            if (this.colorSlider)
                this.colorSlider.value = a ?? 1;
            if (this.pnlShown) {
                this.pnlShown.background = { color: this.currentPalette || '' };
            }
        }
        setPalette(paletteValue) {
            this.currentH = paletteValue;
            const { r, g, b } = (0, utils_1.hslaToRgba)(paletteValue, 100, 50);
            this.currentPalette = `rgb(${r}, ${g}, ${b})`;
        }
        onInputChanged(event, item) {
            const value = event.target.value;
            let currentColor = { ...this.currentColor };
            let isRgbChanged = false;
            let isHslChanged = false;
            let isAChanged = false;
            switch (item) {
                case 'hex':
                    const data = (0, utils_1.convertColor)(value);
                    if (data.isValid) {
                        this.updateCurrentColor(data, true);
                        this.updateIconPointer();
                    }
                    break;
                case 'r':
                case 'g':
                case 'b':
                    const isValid = (0, utils_1.isRgbValid)(value);
                    currentColor[item] = isValid ? value : 255;
                    isRgbChanged = true;
                    break;
                case 'h':
                    const hValid = (0, utils_1.isHValid)(value);
                    currentColor[item] = hValid ? value : 0;
                    isHslChanged = true;
                    break;
                case 's':
                case 'l':
                    if (!value.includes('%'))
                        return;
                    const sValid = (0, utils_1.isPercentValid)(value);
                    if (sValid) {
                        currentColor[item] = value.replace('%', '');
                        isHslChanged = true;
                    }
                    break;
                case 'a':
                    if (value === '0.')
                        return;
                    let numValue = +value;
                    const aValid = !isNaN(numValue);
                    if (!aValid)
                        numValue = 0;
                    currentColor[item] = numValue < 0 ? 0 : (numValue > 1 ? 1 : numValue);
                    isAChanged = true;
                    break;
            }
            if (item === 'hex')
                return;
            const { r, g, b, h, s, l } = currentColor;
            if (isRgbChanged) {
                const { h, s, l } = (0, utils_1.rgbaToHsla)(r, g, b);
                currentColor = { ...currentColor, h, s, l };
            }
            else if (isHslChanged) {
                const { r, g, b } = (0, utils_1.hslaToRgba)(h, s, l);
                currentColor = { ...currentColor, r, g, b };
            }
            this.currentColor = { ...currentColor };
            this.updateHex();
            this.updateCurrentColor(undefined, true);
            this.updateIconPointer();
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    ColorPicker = __decorate([
        (0, base_1.customElements)('i-color', {
            icon: 'palette',
            group: types_1.GroupType.FIELDS,
            className: 'ColorPicker',
            props: {
                value: {
                    type: 'string',
                    default: ''
                },
                caption: {
                    type: 'string',
                    default: ''
                },
                captionWidth: {
                    type: 'number',
                    default: 0
                },
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ],
                onClosed: []
            },
            dataSchema: {
                type: 'object',
                properties: {
                    value: {
                        type: 'string'
                    },
                    caption: {
                        type: 'string'
                    }
                }
            }
        })
    ], ColorPicker);
    exports.ColorPicker = ColorPicker;
});
define("@ijstech/color", ["require", "exports", "@ijstech/color/color.ts"], function (require, exports, color_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPicker = void 0;
    Object.defineProperty(exports, "ColorPicker", { enumerable: true, get: function () { return color_1.ColorPicker; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/input/style/input.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-input', {
        display: 'inline-block',
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        background: Theme.input.background,
        '$nest': {
            '> span': {
                overflow: 'hidden',
                display: 'none'
            },
            '> span > label': {
                boxSizing: 'border-box',
                color: Theme.text.primary,
                display: 'inline-block',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                verticalAlign: 'middle',
                textAlign: 'right',
                paddingRight: 4,
                // height: '100%'
            },
            '> input': {
                border: `0.5px solid ${Theme.divider}`,
                boxSizing: 'border-box',
                outline: 'none',
                color: Theme.input.fontColor,
                background: Theme.input.background,
                borderRadius: 'inherit',
                fontSize: 'inherit',
                maxHeight: '100%',
                maxWidth: '100%'
            },
            '.clear-btn': {
                display: "none",
                verticalAlign: "middle",
                padding: "6px",
                height: "100%",
                backgroundColor: Theme.action.focus,
                $nest: {
                    '&.active': {
                        display: 'inline-flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: 'pointer'
                    }
                }
            },
            'textarea': {
                width: '100%',
                lineHeight: 1.5,
                color: Theme.input.fontColor,
                background: Theme.input.background,
                fontFamily: Theme.typography.fontFamily,
                outline: 'none',
                borderRadius: 'inherit',
                fontSize: 'inherit'
            }
        }
    });
});
define("@ijstech/input/input.ts", ["require", "exports", "@ijstech/base", "@ijstech/checkbox", "@ijstech/combo-box", "@ijstech/datepicker", "@ijstech/range", "@ijstech/radio", "@ijstech/color", "@ijstech/icon", "@ijstech/style", "@ijstech/types", "@ijstech/application", "@ijstech/input/style/input.css.ts"], function (require, exports, base_1, checkbox_1, combo_box_1, datepicker_1, range_1, radio_1, color_1, icon_1, style_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Input = void 0;
    const defaultRows = 4;
    const CLEAR_BTN_WIDTH = 16;
    const DEFAULT_VALUES = {
        captionWidth: 0,
        inputType: 'text',
        readOnly: false,
        showClearButton: false,
        multiline: false,
        resize: 'none'
    };
    let Input = class Input extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {});
            this._inputCallback = (value) => {
                this._value = value;
            };
        }
        set onObserverChanged(callback) {
            super.onObserverChanged = callback;
            if (this._inputControl) {
                this._inputControl.onObserverChanged = callback;
            }
        }
        get onObserverChanged() {
            return super.onObserverChanged;
        }
        ;
        set checked(value) {
            if (this._inputControl) {
                this._inputControl.checked = value;
            }
        }
        get checked() {
            if (this._inputControl) {
                return this._inputControl.checked;
            }
            return false;
        }
        set valueFormat(value) {
            if (this._inputControl) {
                this._inputControl.valueFormat = value;
            }
        }
        get valueFormat() {
            if (this._inputControl) {
                return this._inputControl.valueFormat;
            }
            return '';
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this._caption?.startsWith('$')) {
                if (this._inputControl)
                    this._inputControl.caption = i18n.get(this._caption) || '';
                else if (this.labelElm)
                    this.labelElm.textContent = i18n.get(this._caption) || '';
            }
            if (this.inputElm && this._placeholder?.startsWith('$'))
                this.inputElm.placeholder = i18n.get(this._placeholder) || '';
        }
        get caption() {
            if (this._inputControl) {
                return this._inputControl.caption;
            }
            return this.getTranslatedText(this._caption || '');
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (this._inputControl) {
                this._inputControl.caption = this.caption;
            }
            else {
                this.labelElm.textContent = this.caption;
                this.captionSpanElm.style.display = value ? 'inline-block' : 'none';
            }
        }
        get captionWidth() {
            if (this._inputControl) {
                return this._inputControl.captionWidth;
            }
            return this._captionWidth;
        }
        set captionWidth(value) {
            if (this._inputControl) {
                this._inputControl.captionWidth = value;
            }
            else {
                value = value ?? 'auto';
                this._captionWidth = value;
                this.labelElm.style.width = value + 'px';
            }
        }
        get height() {
            return this.offsetHeight;
        }
        set height(value) {
            this.setPosition('height', value);
            if (this._inputControl) {
                this._inputControl.height = value;
            }
            else {
                this.inputElm.style.height = typeof value === 'string' ? value : `${value}px`;
            }
        }
        get value() {
            if (this._inputControl) {
                return this._inputControl.value;
            }
            return this._value;
        }
        set value(value) {
            if (this._inputControl) {
                this._inputControl.value = value;
            }
            else {
                if (value == null)
                    value = '';
                this._value = value;
                if (this.inputElm)
                    this.inputElm.value = value;
                if (this.clearIconElm) {
                    if (this._showClearButton && value) {
                        this.clearIconElm.classList.add('active');
                    }
                    else {
                        this.clearIconElm.classList.remove('active');
                    }
                }
                if (this.inputType === 'textarea' && (this.resize === 'auto' || this.resize === 'auto-grow')) {
                    this.inputElm.style.height = 'auto';
                    this.inputElm.style.height = (this.inputElm.scrollHeight + 2) + 'px';
                }
            }
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this);
        }
        get width() {
            return this.offsetWidth;
        }
        set width(value) {
            this._width = value;
            const clearBtnWidth = this._showClearButton ? this._clearBtnWidth : 0;
            const captionWidth = typeof this._captionWidth === 'string' ? this._captionWidth : `${this._captionWidth}px`;
            this.setPosition('width', value);
            if (this.inputElm) {
                if (captionWidth === 'auto') {
                    this.inputElm.style.width = `calc(100% - ${clearBtnWidth}px)`;
                }
                else {
                    this.inputElm.style.width = `calc(100% - ${captionWidth} - ${clearBtnWidth}px)`;
                }
            }
        }
        get readOnly() {
            return this._readOnly;
        }
        set readOnly(value) {
            this._readOnly = value;
            if (this.inputElm)
                this.inputElm.readOnly = value || this._designMode;
        }
        get inputType() {
            return this._inputType;
        }
        set inputType(type) {
            const isChanged = this._inputType !== type;
            this._inputType = type;
            if (isChanged)
                this._createInputElement(type);
        }
        get inputControl() {
            return this._inputControl;
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            if (this._inputControl) {
                this._inputControl.enabled = value;
            }
            else if (this.inputElm) {
                this.inputElm.disabled = !value;
            }
        }
        get placeholder() {
            return this.getTranslatedText(this._placeholder || '');
        }
        set placeholder(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._placeholder = value;
            if (this.inputElm)
                this.inputElm.placeholder = this.placeholder;
        }
        getTranslatedText(value) {
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        get rows() {
            return this._rows;
        }
        set rows(value) {
            if (this.inputType !== 'textarea')
                return;
            this._rows = value;
            this.inputElm.rows = value;
        }
        get multiline() {
            return this._multiline;
        }
        set multiline(value) {
            this._multiline = value;
            if (value && this.inputType !== 'textarea') {
                this.inputType = 'textarea';
            }
        }
        get resize() {
            return this._resize;
        }
        set resize(value) {
            this._resize = value;
            if (this.inputType === 'textarea' && value && this.inputElm) {
                this.inputElm.style.resize = value === 'auto-grow' ? 'none' : value;
                if (value === 'auto' || value === 'auto-grow') {
                    this.inputElm.style.height = 'auto';
                    this.inputElm.style.height = (this.inputElm.scrollHeight + 2) + 'px';
                }
            }
        }
        set border(value) {
            super.border = value;
            const inputTypes = ['text', 'number', 'textarea', 'password'];
            if (!this.inputType || inputTypes.includes(this.inputType)) {
                if (this.border.width !== undefined)
                    this.inputElm.style.borderWidth = this.border.width;
                if (this.border.style)
                    this.inputElm.style.borderStyle = this.border.style;
                if (this.border.color)
                    this.inputElm.style.borderColor = this.border.color;
                if (this.border.bottom || this.border.top || this.border.left || this.border.right)
                    this.inputElm.style.borderStyle = 'none';
            }
        }
        get border() {
            return super.border;
        }
        set maxLength(value) {
            this._maxLength = value;
            if (this.inputElm) {
                if (value)
                    this.inputElm.maxLength = value;
                else
                    this.inputElm.removeAttribute('maxLength');
            }
        }
        get maxLength() {
            return this._maxLength;
        }
        set enterKeyHint(value) {
            this._enterKeyHint = value;
            if (this.inputElm) {
                this.inputElm.setAttribute('enterKeyHint', value);
            }
        }
        get enterKeyHint() {
            return this._enterKeyHint;
        }
        get background() {
            return this._background;
        }
        set background(value) {
            super.background = value;
            if (value && value.color !== undefined) {
                this.style.setProperty('--input-background', value.color);
            }
            else {
                this.style.removeProperty('--input-background');
            }
        }
        get font() {
            return this._font;
        }
        set font(value) {
            super.font = value;
            if (value && value.color !== undefined) {
                this.style.setProperty('--input-font_color', value.color);
            }
            else {
                this.style.removeProperty('--input-font_color');
            }
        }
        set onClosed(callback) {
            this._onClosed = callback;
            if (!this._inputControl || this.inputType !== 'color')
                return;
            this._inputControl.onClosed = callback;
        }
        get onClosed() {
            return this._onClosed;
        }
        _createInputElement(type) {
            this.clearInnerHTML();
            const value = this.getAttribute('value');
            const width = this.getAttribute('width', true);
            const height = this.getAttribute('height', true);
            const checked = this.getAttribute('checked', true);
            const enabled = this.getAttribute('enabled', true);
            const background = this.getAttribute('background', true);
            const designMode = this.getAttribute('designMode', true);
            const caption = this.caption;
            this._clearBtnWidth = height - 2 || CLEAR_BTN_WIDTH;
            let cursor = 'text';
            switch (type) {
                case "checkbox":
                    this._inputControl = new checkbox_1.Checkbox(this, {
                        value,
                        checked,
                        enabled,
                        caption,
                        designMode,
                        indeterminate: this.getAttribute('indeterminate', true)
                    });
                    if (typeof this.onChanged === 'function')
                        this._inputControl.onChanged = this.onChanged;
                    this.appendChild(this._inputControl);
                    this.inputElm = this._inputControl.querySelector('input[type="checkbox"]');
                    cursor = 'pointer';
                    break;
                case "combobox":
                    this._inputControl = new combo_box_1.ComboBox(this, {
                        selectedItem: this.getAttribute('selectedItem', true),
                        selectedItems: this.getAttribute('selectedItems', true),
                        value: this.getAttribute('value', true),
                        items: this.getAttribute('items', true),
                        width,
                        height,
                        enabled,
                        designMode,
                        icon: this.getAttribute('icon', true),
                        mode: this.getAttribute('mode', true),
                        placeholder: this._placeholder,
                        parentCallback: this._inputCallback,
                    });
                    if (typeof this.onChanged === 'function')
                        this._inputControl.onChanged = this.onChanged;
                    this.appendChild(this._inputControl);
                    this.inputElm = this._inputControl.querySelector('input');
                    break;
                case "date":
                case "dateTime":
                case "time":
                    this._inputControl = new datepicker_1.Datepicker(this, {
                        caption,
                        value,
                        placeholder: this._placeholder,
                        type: type,
                        valueFormat: this.getAttribute('valueFormat', true),
                        dateTimeFormat: this.getAttribute('dateTimeFormat', true),
                        width,
                        height,
                        designMode,
                        enabled,
                        parentCallback: this._inputCallback
                    });
                    if (typeof this.onChanged === 'function')
                        this._inputControl.onChanged = this.onChanged;
                    this.appendChild(this._inputControl);
                    this.inputElm = this._inputControl.querySelector('input[type="text"]');
                    break;
                case "range":
                    this._inputControl = new range_1.Range(this, {
                        value,
                        caption,
                        width,
                        height,
                        enabled,
                        designMode,
                        min: this.getAttribute("min", true),
                        max: this.getAttribute("max", true),
                        step: this.getAttribute("step", true),
                        // labels: this.getAttribute("labels", true),
                        stepDots: this.getAttribute("stepDots", true),
                        tooltipFormatter: this.getAttribute("tooltipFormatter", true),
                        tooltipVisible: this.getAttribute("tooltipVisible", true),
                        trackColor: this.getAttribute("trackColor", true),
                        parentCallback: this._inputCallback
                    });
                    this._inputControl.onChanged = this.onChanged;
                    this._inputControl.onMouseUp = this.onMouseUp;
                    this._inputControl.onKeyUp = this.onKeyUp;
                    this.appendChild(this._inputControl);
                    this.inputElm = this._inputControl.querySelector('input[type="range"]');
                    cursor = 'pointer';
                    break;
                case "radio":
                    const id = this.getAttribute("id") || '';
                    this._inputControl = new radio_1.Radio(this, {
                        value,
                        checked,
                        enabled,
                        caption,
                        designMode,
                        id: id + '_radio'
                    });
                    this.appendChild(this._inputControl);
                    this.inputElm = this._inputControl.querySelector('input[type="radio"]');
                    cursor = 'pointer';
                    break;
                case "textarea":
                    this.captionSpanElm = this.createElement('span', this);
                    this.labelElm = this.createElement('label', this.captionSpanElm);
                    this.inputElm = this.createElement('textarea', this);
                    this.inputElm.style.height = 'auto';
                    const rows = this.getAttribute('rows', true) || defaultRows;
                    this.rows = rows;
                    if (this._placeholder) {
                        this.inputElm.placeholder = this.placeholder;
                    }
                    this.inputElm.style.resize = value === 'auto-grow' ? 'none' : value;
                    this.inputElm.disabled = enabled === false;
                    this.inputElm.addEventListener('input', this._handleChange.bind(this));
                    this.inputElm.addEventListener('keydown', this._handleInputKeyDown.bind(this));
                    this.inputElm.addEventListener('keyup', this._handleInputKeyUp.bind(this));
                    this.inputElm.addEventListener('focus', this._handleOnFocus.bind(this));
                    if (caption && this.labelElm) {
                        this.labelElm.textContent = caption;
                    }
                    break;
                case "color":
                    this._inputControl = new color_1.ColorPicker(this, {
                        value,
                        enabled,
                        caption,
                        width,
                        height
                    });
                    if (typeof this.onChanged === 'function')
                        this._inputControl.onChanged = this.onChanged;
                    if (!this.onClosed) {
                        const onClosed = this.getAttribute('onClosed', true);
                        this._inputControl.onClosed = onClosed;
                    }
                    else {
                        this._inputControl.onClosed = this.onClosed;
                    }
                    this.appendChild(this._inputControl);
                    this.inputElm = this._inputControl.querySelector('.input-span');
                    cursor = 'default';
                    break;
                default:
                    const inputType = type == 'password' ? type : 'text';
                    this.captionSpanElm = this.createElement('span', this);
                    this.labelElm = this.createElement('label', this.captionSpanElm);
                    this.inputElm = this.createElement('input', this);
                    this.inputElm.setAttribute('autocomplete', 'disabled');
                    this.inputElm.style.height = this.height + 'px';
                    this.inputElm.type = inputType;
                    if (this._placeholder)
                        this.inputElm.placeholder = this.placeholder;
                    this.inputElm.disabled = enabled === false;
                    this.inputElm.addEventListener('input', this._handleChange.bind(this));
                    this.inputElm.addEventListener('keydown', this._handleInputKeyDown.bind(this));
                    this.inputElm.addEventListener('keyup', this._handleInputKeyUp.bind(this));
                    this.inputElm.addEventListener('focus', this._handleOnFocus.bind(this));
                    this._showClearButton = this.getAttribute('showClearButton', true);
                    if (this._showClearButton) {
                        this.clearIconElm = this.createElement("span", this);
                        this.clearIconElm.classList.add('clear-btn');
                        this.clearIconElm.style.width = this._clearBtnWidth + "px";
                        // this.clearIconElm.style.height = this._clearBtnWidth + "px";
                        this.clearIconElm.addEventListener("click", () => {
                            if (!this._enabled)
                                return false;
                            this._clearValue();
                        });
                        const clearIcon = new icon_1.Icon(this, { name: 'times', width: 12, height: 12, fill: style_1.Theme.ThemeVars.text.primary });
                        this.clearIconElm.appendChild(clearIcon);
                    }
                    if (caption && this.labelElm) {
                        this.labelElm.textContent = caption;
                    }
                    break;
            }
            if (this.inputElm) {
                this.inputElm.readOnly = designMode || this.readOnly;
                this.inputElm.style.cursor = designMode ? 'pointer' : cursor;
            }
            if (background && this._inputControl)
                this._inputControl.background = background;
        }
        _handleChange(event) {
            if (this.inputType === 'number' && !/^-?\d*[.]?\d*$/.test(this.inputElm.value)) {
                this.inputElm.value = this._value;
                return;
            }
            if (this.inputType === 'textarea' && (this.resize === 'auto' || this.resize === 'auto-grow')) {
                this.inputElm.style.height = 'auto';
                this.inputElm.style.height = (this.inputElm.scrollHeight + 2) + 'px';
            }
            this._value = this.inputElm.value;
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, event);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, event);
        }
        _handleInputKeyDown(event) {
            if (typeof this.onKeyDown === 'function')
                this.onKeyDown(this, event);
        }
        _handleInputKeyUp(event) {
            if (typeof this.onKeyUp === 'function')
                this.onKeyUp(this, event);
            if (this.clearIconElm) {
                if (this.value) {
                    this.clearIconElm.classList.add('active');
                }
                else {
                    this.clearIconElm.classList.remove('active');
                }
            }
        }
        _handleBlur(event, stopPropagation) {
            if (typeof this.onBlur === 'function') {
                event.preventDefault();
                this.onBlur(this);
            }
            return true;
        }
        ;
        _handleOnFocus(event) {
            if (typeof this.onFocus === 'function') {
                event.preventDefault();
                this.onFocus(this);
            }
        }
        _clearValue() {
            this.value = '';
            this.clearIconElm.classList.remove('active');
            if (typeof this.onClearClick === 'function')
                this.onClearClick(this);
        }
        focus() {
            this.inputElm.focus();
        }
        init() {
            if (!this.inputType) {
                this._placeholder = this.getAttribute('placeholder', true);
                this._caption = this.getAttribute('caption', true);
                this.inputType = this.getAttribute('inputType', true, DEFAULT_VALUES.inputType);
                this.multiline = this.getAttribute('multiline', true);
                this.captionWidth = this.getAttribute('captionWidth', true);
                this.value = this.getAttribute('value', true);
                this._designMode = this.getAttribute('designMode', true, false);
                this.readOnly = this.getAttribute('readOnly', true, DEFAULT_VALUES.readOnly);
                this.resize = this.getAttribute('resize', true, DEFAULT_VALUES.resize);
                this.maxLength = this.getAttribute('maxLength', true);
                this.enterKeyHint = this.getAttribute('enterKeyHint', true);
                if (this.value && this.clearIconElm)
                    this.clearIconElm.classList.add('active');
                super.init();
                if (this.inputType === 'textarea' && this.maxHeight != null) {
                    if (!isNaN(Number(this.maxHeight))) {
                        this.inputElm.style.maxHeight = this.maxHeight + 'px';
                    }
                    else {
                        this.inputElm.style.maxHeight = this.maxHeight + "";
                    }
                }
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('value')
    ], Input.prototype, "_value", void 0);
    Input = __decorate([
        (0, base_1.customElements)('i-input', {
            icon: 'edit',
            group: types_1.GroupType.FIELDS,
            className: 'Input',
            props: {
                caption: {
                    type: 'string',
                    default: ''
                },
                captionWidth: {
                    type: 'number',
                    default: DEFAULT_VALUES.captionWidth
                },
                inputType: {
                    type: 'string',
                    default: DEFAULT_VALUES.inputType
                },
                value: {
                    type: 'string',
                    default: ''
                },
                placeholder: {
                    type: 'string',
                    default: ''
                },
                readOnly: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.readOnly
                },
                showClearButton: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.showClearButton
                },
                rows: {
                    type: 'number'
                },
                multiline: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.multiline
                },
                resize: {
                    type: 'string',
                    default: DEFAULT_VALUES.resize
                },
                maxLength: {
                    type: 'number'
                },
                enterKeyHint: {
                    type: 'string'
                }
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Control', isControl: true },
                    { name: 'event', type: 'Event' }
                ],
                onClosed: [],
                onBlur: [
                    { name: 'target', type: 'Input', isControl: true }
                ],
                onFocus: [
                    { name: 'target', type: 'Input', isControl: true }
                ],
                onClearClick: [
                    { name: 'target', type: 'Input', isControl: true }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    caption: {
                        type: 'string'
                    },
                    inputType: {
                        type: 'string',
                        enum: ['password', 'number', 'textarea', 'text'],
                        default: DEFAULT_VALUES.inputType
                    },
                    value: {
                        type: 'string'
                    },
                    placeholder: {
                        type: 'string'
                    },
                    readOnly: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.readOnly
                    },
                    showClearButton: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.showClearButton
                    },
                    rows: {
                        type: 'number'
                    },
                    multiline: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.multiline
                    },
                    resize: {
                        type: 'string',
                        enum: ['none', 'auto', 'both', 'horizontal', 'vertical', 'initial', 'inherit', 'auto-grow'],
                        default: DEFAULT_VALUES.resize
                    }
                }
            }
        })
    ], Input);
    exports.Input = Input;
});
define("@ijstech/input", ["require", "exports", "@ijstech/input/input.ts"], function (require, exports, input_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Input = void 0;
    Object.defineProperty(exports, "Input", { enumerable: true, get: function () { return input_1.Input; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/switch/style/switch.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule("i-switch", {
        display: "block",
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        $nest: {
            ".wrapper": {
                width: "100%",
                height: "100%",
                position: "relative",
                display: "inline-flex",
                flexShrink: 0,
                overflow: "hidden",
                zIndex: 0,
                verticalAlign: "middle",
                borderRadius: 'inherit'
            },
            ".switch-base": {
                display: "inline-flex",
                alignItems: "center",
                justifyContent: "start",
                outline: 0,
                border: 0,
                margin: 0,
                cursor: "pointer",
                userSelect: "none",
                verticalAlign: "middle",
                textDecoration: "none",
                padding: "1px",
                borderRadius: "50%",
                position: "absolute",
                top: 0,
                bottom: 0,
                left: 0,
                zIndex: 1,
                width: '50%',
                height: '100%',
                color: "#fff",
                transition: "left 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, justify-content 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
                $nest: {
                    "&.checked": {
                        transform: "translateX(100%)",
                        // justifyContent: 'flex-end',
                        $nest: {
                            ".thumb:before": {
                                backgroundImage: "var(--checked-background)",
                            },
                            ".thumb-text:before": {
                                content: "var(--thumb-checked-text)",
                            },
                            "+.track": {
                                backgroundColor: "#1976d2",
                                $nest: {
                                    "&::before": {
                                        opacity: 1,
                                    },
                                    "&::after": {
                                        opacity: 0,
                                    },
                                },
                            },
                        },
                    },
                },
            },
            input: {
                position: "absolute",
                top: 0,
                left: "-100%",
                width: "100%",
                height: "100%",
                opacity: 0,
                margin: 0,
                padding: 0,
                cursor: "inherit",
                zIndex: 1,
            },
            ".thumb": {
                width: "16px",
                height: "16px",
                margin: "2px",
                backgroundColor: "currentColor",
                borderRadius: "50%",
                boxShadow: "none",
            },
            ".thumb:before": {
                content: '""',
                position: "absolute",
                width: "100%",
                height: "100%",
                left: 0,
                top: 0,
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                backgroundSize: "14px",
                backgroundImage: "var(--background)",
            },
            ".thumb.thumb-text:before": {
                content: "var(--thumb-text)",
                position: "absolute",
                width: "inherit",
                height: "inherit",
                top: 'auto',
                left: 'auto',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: '#fff',
            },
            ".track": {
                width: "100%",
                height: "100%",
                zIndex: -1,
                backgroundColor: "#000",
                transition: "opacity 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
                $nest: {
                    "&::before": {
                        content: "var(--checked-text)",
                        position: "absolute",
                        left: "4px",
                        top: "calc(50% - 0.6px)",
                        transform: "translateY(-50%)",
                        fontSize: "10px",
                        color: "white",
                        opacity: 0,
                    },
                    "&::after": {
                        content: "var(--text)",
                        position: "absolute",
                        right: "6px",
                        top: "calc(50% - 0.6px)",
                        transform: "translateY(-50%)",
                        fontSize: "10px",
                        color: "white",
                        opacity: 1,
                    },
                },
            },
        },
    });
});
define("@ijstech/switch/switch.ts", ["require", "exports", "@ijstech/base", "@ijstech/types", "@ijstech/switch/style/switch.css.ts"], function (require, exports, base_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Switch = void 0;
    let Switch = class Switch extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                width: "48px",
                height: "22px",
                border: { radius: '11px' }
            });
            this._checked = false;
        }
        get checked() {
            return this._checked;
        }
        set checked(value) {
            if (this._checked === value)
                return;
            this._checked = value;
            this._checked ? this.switchBaseElm.classList.add("checked") : this.switchBaseElm.classList.remove("checked");
            if (this._checked) {
                if (this.checkedThumbColor)
                    this.switchBaseElm.style.color = this.checkedThumbColor;
                if (this.checkedTrackColor)
                    this.trackElm.style.backgroundColor = this.checkedTrackColor;
            }
            else {
                if (this.uncheckedThumbColor)
                    this.switchBaseElm.style.color = this.uncheckedThumbColor;
                if (this.uncheckedTrackColor)
                    this.trackElm.style.backgroundColor = this.uncheckedTrackColor;
            }
        }
        get checkedThumbColor() {
            return this._checkedThumbColor;
        }
        set checkedThumbColor(value) {
            if (this._checkedThumbColor === value)
                return;
            this._checkedThumbColor = value;
            if (this._checked) {
                this.switchBaseElm.style.color = this.checkedThumbColor;
            }
        }
        get uncheckedThumbColor() {
            return this._uncheckedThumbColor;
        }
        set uncheckedThumbColor(value) {
            if (this._uncheckedThumbColor === value)
                return;
            this._uncheckedThumbColor = value;
            if (!this._checked) {
                this.switchBaseElm.style.color = value;
            }
        }
        get checkedTrackColor() {
            return this._checkedTrackColor;
        }
        set checkedTrackColor(value) {
            if (this._checkedTrackColor === value)
                return;
            this._checkedTrackColor = value;
            if (this._checked) {
                this.trackElm.style.backgroundColor = value;
            }
        }
        get uncheckedTrackColor() {
            return this._uncheckedTrackColor;
        }
        set uncheckedTrackColor(value) {
            if (this._uncheckedTrackColor === value)
                return;
            this._uncheckedTrackColor = value;
            if (!this._checked) {
                this.trackElm.style.backgroundColor = value;
            }
        }
        get checkedText() {
            return this._checkedText;
        }
        set checkedText(value) {
            this._checkedText = value;
            this.trackElm.style.setProperty("--checked-text", `"${value}"`);
        }
        get uncheckedText() {
            return this._uncheckedText;
        }
        set uncheckedText(value) {
            this._uncheckedText = value;
            this.trackElm.style.setProperty("--text", `"${value}"`);
        }
        get checkedThumbText() {
            return this._checkedThumbText;
        }
        set checkedThumbText(value) {
            this._checkedThumbText = value;
            this.thumbElm.classList.add("thumb-text");
            this.thumbElm.style.setProperty("--thumb-text", `'${value || ""}'`);
        }
        get uncheckedThumbText() {
            return this._uncheckedThumbText;
        }
        set uncheckedThumbText(value) {
            this._uncheckedThumbText = value;
            this.thumbElm.classList.add("thumb-text");
            this.thumbElm.style.setProperty("--thumb-checked-text", `'${value || ""}'`);
        }
        setAttributeToProperty(propertyName) {
            const prop = this.getAttribute(propertyName, true);
            if (prop)
                this[propertyName] = prop;
        }
        _handleClick(event) {
            if (this._designMode)
                return false;
            if (!this.onClick) {
                this.checked = !this.checked;
                if (typeof this.onObserverChanged === 'function')
                    this.onObserverChanged(this, event);
                if (typeof this.onChanged === 'function')
                    this.onChanged(this, event);
            }
            return super._handleClick(event, true);
        }
        init() {
            if (!this.wrapperElm) {
                this.wrapperElm = this.createElement("div", this);
                this.wrapperElm.classList.add("wrapper");
                this.switchBaseElm = this.createElement("div");
                this.switchBaseElm.classList.add("switch-base");
                this.wrapperElm.appendChild(this.switchBaseElm);
                this.trackElm = this.createElement("div");
                this.trackElm.classList.add("track");
                this.wrapperElm.appendChild(this.trackElm);
                // switch-base
                this.inputElm = this.createElement("input");
                this.inputElm.setAttribute("type", "checkbox");
                this.switchBaseElm.appendChild(this.inputElm);
                this.thumbElm = this.createElement("div");
                this.thumbElm.classList.add("thumb");
                this.switchBaseElm.appendChild(this.thumbElm);
                this.rippleElm = this.createElement("div");
                this.rippleElm.classList.add("ripple");
                this.switchBaseElm.appendChild(this.rippleElm);
                this.checked = this.getAttribute("checked", true) || false;
                this.setAttributeToProperty('checkedThumbColor');
                this.setAttributeToProperty('uncheckedThumbColor');
                this.setAttributeToProperty('checkedTrackColor');
                this.setAttributeToProperty('uncheckedTrackColor');
                this.setAttributeToProperty('checkedText');
                this.setAttributeToProperty('uncheckedText');
                this.setAttributeToProperty('checkedThumbText');
                this.setAttributeToProperty('uncheckedThumbText');
                super.init();
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('schecked')
    ], Switch.prototype, "_checked", void 0);
    Switch = __decorate([
        (0, base_1.customElements)("i-switch", {
            icon: 'toggle-on',
            group: types_1.GroupType.FIELDS,
            className: 'Switch',
            props: {
                checkedThumbColor: { type: 'string', default: '' },
                uncheckedThumbColor: { type: 'string', default: '' },
                checkedThumbText: { type: 'string', default: '' },
                uncheckedThumbText: { type: 'string', default: '' },
                checkedTrackColor: { type: 'string', default: '' },
                uncheckedTrackColor: { type: 'string', default: '' },
                checkedText: { type: 'string', default: '' },
                uncheckedText: { type: 'string', default: '' },
                checked: { type: 'boolean', default: false },
            },
            events: {},
            dataSchema: {
                type: "object",
                properties: {
                    checkedThumbColor: { type: "string", format: 'color' },
                    uncheckedThumbColor: { type: "string", format: 'color' },
                    checkedThumbText: { type: "string" },
                    uncheckedThumbText: { type: "string" },
                    checkedTrackColor: { type: "string", format: 'color' },
                    uncheckedTrackColor: { type: "string", format: 'color' },
                    checkedText: { type: "string" },
                    uncheckedText: { type: "string" },
                    checked: { type: "boolean", default: false },
                },
            }
        })
    ], Switch);
    exports.Switch = Switch;
});
define("@ijstech/switch", ["require", "exports", "@ijstech/switch/switch.ts"], function (require, exports, switch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Switch = void 0;
    Object.defineProperty(exports, "Switch", { enumerable: true, get: function () { return switch_1.Switch; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/link/style/link.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-link', {
        display: 'block',
        cursor: 'pointer',
        textTransform: 'inherit',
        $nest: {
            // "&.i-link *": {
            //     color: Theme.colors.primary.main,
            //     fontSize: '1rem'
            // },
            '&:hover *': {
                color: Theme.colors.primary.dark
            },
            // 'a:visited, a:visited *': {
            //     color: Theme.colors.info.dark
            // },
            '> a': {
                display: 'inline',
                transition: 'all .3s',
                textDecoration: 'underline',
                color: 'inherit',
                fontSize: 'inherit',
                fontWeight: 'inherit',
                fontFamily: 'inherit',
                textTransform: 'inherit'
            }
        }
    });
});
define("@ijstech/link/link.ts", ["require", "exports", "@ijstech/base", "@ijstech/link/style/link.css.ts"], function (require, exports, base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Link = void 0;
    let Link = class Link extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                target: '_blank'
            });
        }
        get href() {
            return this._href;
        }
        set href(value) {
            this._href = typeof value === 'string' ? value : '';
            if (this._linkElm)
                this._linkElm.href = this._href;
        }
        get target() {
            return this._target;
        }
        set target(value) {
            this._target = value;
            if (this._linkElm)
                this._linkElm.target = value;
        }
        append(children) {
            if (!this._linkElm) {
                this._linkElm = this.createElement('a', this);
            }
            this._linkElm.appendChild(children);
        }
        _handleClick(event, stopPropagation) {
            event.preventDefault();
            if (this._designMode)
                return false;
            if (this.onOpenLink) {
                this.onOpenLink(this, event);
            }
            else {
                window.open(this._linkElm.href, this._linkElm.target);
            }
            return super._handleClick(event);
        }
        addChildControl(control) {
            if (this._linkElm)
                this._linkElm.appendChild(control);
        }
        removeChildControl(control) {
            if (this._linkElm && this._linkElm.contains(control))
                this._linkElm.removeChild(control);
        }
        init() {
            if (!this.initialized) {
                super.init();
                if (!this._linkElm)
                    this._linkElm = this.createElement('a', this);
                this.classList.add('i-link');
                const hrefAttr = this.getAttribute('href', true);
                hrefAttr && (this.href = hrefAttr);
                const targetAttr = this.getAttribute('target', true);
                targetAttr && (this.target = targetAttr);
                this.onOpenLink = this.getAttribute('onOpenLink', true) || this.onOpenLink;
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Link = __decorate([
        (0, base_1.customElements)('i-link')
    ], Link);
    exports.Link = Link;
});
define("@ijstech/link", ["require", "exports", "@ijstech/link/link.ts"], function (require, exports, link_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Link = void 0;
    Object.defineProperty(exports, "Link", { enumerable: true, get: function () { return link_1.Link; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/text/style/text.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-text', {
        display: 'inline-block',
        color: Theme.text.primary,
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize
    });
});
define("@ijstech/text/text.ts", ["require", "exports", "@ijstech/base", "@ijstech/text/style/text.css.ts"], function (require, exports, base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Text = exports.textPropsConfig = exports.textDataSchema = void 0;
    exports.textDataSchema = {
        wordBreak: {
            type: 'string',
            enum: ['normal', 'break-all', 'keep-all', 'break-word'],
            default: 'normal'
        },
        overflowWrap: {
            type: 'string',
            enum: ['normal', 'break-word', 'anywhere'],
            default: 'normal'
        },
        textOverflow: {
            type: 'string',
            enum: ['clip', 'ellipsis']
        },
        lineClamp: {
            type: 'number'
        }
    };
    exports.textPropsConfig = {
        wordBreak: {
            type: 'string',
            default: 'normal'
        },
        overflowWrap: {
            type: 'string',
            default: 'normal'
        },
        textOverflow: {
            type: 'string'
        },
        lineClamp: {
            type: 'number'
        }
    };
    let Text = class Text extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
        }
        get wordBreak() {
            return this.style.wordBreak;
        }
        set wordBreak(value) {
            this.style.wordBreak = value;
        }
        get overflowWrap() {
            return this.style.overflowWrap;
        }
        set overflowWrap(value) {
            this.style.overflowWrap = value;
        }
        get textOverflow() {
            return this.style.textOverflow;
        }
        set textOverflow(value) {
            if (!value)
                return;
            this.style.textOverflow = value;
            this.style.whiteSpace = 'nowrap';
            this.overflow = 'hidden';
        }
        get lineClamp() {
            return Number(this.style.webkitLineClamp);
        }
        set lineClamp(value) {
            this.style.webkitLineClamp = `${value}`;
            this.style.overflow = 'hidden';
            this.style.webkitBoxOrient = 'vertical';
            this.display = '-webkit-box';
            this.overflow = 'hidden';
            this.style.whiteSpace = '';
        }
        get display() {
            return this._display;
        }
        set display(value) {
            const isNotNone = value !== 'none';
            this._display = this.lineClamp && isNotNone ? '-webkit-box' : value;
            this.style.display = this._display;
        }
        init() {
            super.init();
            const wordBreak = this.getAttribute('wordBreak', true);
            if (wordBreak)
                this.wordBreak = wordBreak;
            const overflowWrap = this.getAttribute('overflowWrap', true);
            if (overflowWrap)
                this.overflowWrap = overflowWrap;
            const textOverflow = this.getAttribute('textOverflow', true);
            if (textOverflow)
                this.textOverflow = textOverflow;
            const lineClamp = this.getAttribute('lineClamp', true);
            if (lineClamp)
                this.lineClamp = lineClamp;
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Text = __decorate([
        (0, base_1.customElements)('i-text')
    ], Text);
    exports.Text = Text;
});
define("@ijstech/text", ["require", "exports", "@ijstech/text/text.ts"], function (require, exports, text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.textPropsConfig = exports.textDataSchema = exports.Text = void 0;
    Object.defineProperty(exports, "Text", { enumerable: true, get: function () { return text_1.Text; } });
    Object.defineProperty(exports, "textDataSchema", { enumerable: true, get: function () { return text_1.textDataSchema; } });
    Object.defineProperty(exports, "textPropsConfig", { enumerable: true, get: function () { return text_1.textPropsConfig; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/label/style/label.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-label', {
        display: 'inline-block',
        color: Theme.text.primary,
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize
    });
});
define("@ijstech/label/label.ts", ["require", "exports", "@ijstech/base", "@ijstech/link", "@ijstech/text", "@ijstech/types", "@ijstech/text", "@ijstech/application", "@ijstech/label/style/label.css.ts"], function (require, exports, base_1, link_1, text_1, types_1, text_2, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Label = void 0;
    const DEFAULT_VALUES = {
        target: '_blank',
        textDecoration: 'none'
    };
    let Label = class Label extends text_1.Text {
        constructor(parent, options) {
            super(parent, options);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionSpan && this._caption?.startsWith('$'))
                this.captionSpan.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            const value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(this._caption) ||
                    application_1.application.i18n?.get(this._caption) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (!this.captionSpan)
                return;
            this.captionSpan.textContent = this.caption;
        }
        get link() {
            if (!this._link) {
                this._link = new link_1.Link(this, {
                    href: '#',
                    target: '_blank',
                    font: this.font,
                    designMode: this._designMode
                });
                this._link.append(this.captionSpan);
                this.appendChild(this._link);
            }
            return this._link;
        }
        set link(value) {
            if (this._link) {
                this._link.prepend(this.captionSpan);
                this._link.remove();
            }
            this._link = value;
            if (this._link) {
                this._link.append(this.captionSpan);
                this.appendChild(this._link);
            }
            else {
                this.appendChild(this.captionSpan);
            }
        }
        set height(value) {
            this.setPosition('height', value);
            if (this.captionSpan)
                this.captionSpan.style.height = value + 'px';
        }
        set width(value) {
            this.setPosition('width', value);
            if (this.captionSpan)
                this.captionSpan.style.width = value + 'px';
        }
        get textDecoration() {
            return this.style.textDecoration;
        }
        set textDecoration(value) {
            this.style.textDecoration = value;
        }
        init() {
            if (!this.captionSpan) {
                let childNodes = [];
                for (let i = 0; i < this.childNodes.length; i++) {
                    childNodes.push(this.childNodes[i]);
                }
                this.captionSpan = this.createElement('span', this);
                this.caption = this.getAttribute('caption', true) || '';
                if (childNodes && childNodes.length) {
                    for (let i = 0; i < childNodes.length; i++) {
                        this.captionSpan.appendChild(childNodes[i]);
                    }
                }
                const linkAttr = this.getAttribute('link', true);
                const designMode = this.getAttribute('designMode', true);
                if (linkAttr?.href) {
                    const link = new link_1.Link(this, {
                        ...linkAttr,
                        font: this.font,
                        designMode
                    });
                    this.link = link;
                }
                const textDecoration = this.getAttribute('textDecoration', true);
                if (textDecoration)
                    this.textDecoration = textDecoration;
                super.init();
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Label = __decorate([
        (0, base_1.customElements)('i-label', {
            icon: 'heading',
            group: types_1.GroupType.BASIC,
            className: 'Label',
            props: {
                caption: {
                    type: 'string',
                    default: ''
                },
                textDecoration: {
                    type: 'string',
                    default: DEFAULT_VALUES.textDecoration
                },
                ...text_2.textPropsConfig,
                link: {
                    type: 'object',
                    default: {
                        target: DEFAULT_VALUES.target
                    }
                }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    caption: {
                        type: 'string',
                        required: true
                    },
                    textDecoration: {
                        type: 'string',
                        enum: ['none', 'underline', 'overline', 'line-through'],
                        default: DEFAULT_VALUES.textDecoration
                    },
                    ...text_2.textDataSchema,
                    link: {
                        type: 'object',
                        properties: {
                            href: {
                                type: 'string'
                            },
                            target: {
                                type: 'string',
                                enum: ['_blank', '_self', '_parent', '_top'],
                                default: DEFAULT_VALUES.target
                            }
                        }
                    }
                }
            }
        })
    ], Label);
    exports.Label = Label;
});
define("@ijstech/label", ["require", "exports", "@ijstech/label/label.ts"], function (require, exports, label_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Label = void 0;
    Object.defineProperty(exports, "Label", { enumerable: true, get: function () { return label_1.Label; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/upload/style/upload.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-upload', {
        margin: '1rem 0',
        listStyle: 'none',
        minHeight: 200,
        minWidth: 200,
        height: '100%',
        width: '100%',
        display: 'flex',
        flexWrap: 'wrap',
        $nest: {
            '.i-upload-wrapper': {
                position: 'relative',
                border: `2px dashed ${Theme.divider}`,
                width: '100%',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
                marginBottom: '1rem',
            },
            'i-upload-drag': {
                position: 'absolute',
                width: '100%',
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
            },
            '.i-upload-drag_area': {
                marginTop: '4rem',
            },
            '.i-upload-dragger_active': {
                border: `2px dashed ${Theme.colors.primary.main}`,
                backgroundColor: Theme.colors.info.light,
                opacity: '0.8',
            },
            'input[type="file"]': {
                display: 'none',
            },
            '.i-upload_preview': {
                display: 'none',
                minHeight: 200,
                position: 'relative',
                overflow: 'hidden',
                width: '100%',
                height: '100%',
            },
            '.i-upload_preview img': {
                maxHeight: 'inherit',
                maxWidth: '100%',
            },
            '.i-upload_preview-img': {
                maxHeight: 'inherit',
                maxWidth: '100%',
                // display: 'table',
                // margin: 'auto'
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%'
            },
            '.i-upload_preview-crop': {
                position: 'absolute',
                border: `1px dashed ${Theme.background.paper}`,
                width: 150,
                height: 150,
                left: '50%',
                top: '50%',
                transform: 'translate(-50%, -50%)',
                boxSizing: 'border-box',
                boxShadow: '0 0 0 9999em',
                color: 'rgba(0, 0, 0, 0.5)',
                overflow: 'hidden',
                cursor: 'crosshair',
            },
            '.i-upload_preview-remove': {
                position: 'absolute',
                top: 0,
                left: 0,
                visibility: 'hidden',
                opacity: 0,
                width: '100%',
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: 'rgba(0, 0, 0, 0.58)',
                cursor: 'pointer',
                $nest: {
                    '> span': {
                        padding: '1rem',
                        border: '2px solid #fff',
                        borderRadius: '5px',
                        color: '#fff',
                        fontWeight: 'bold',
                    },
                },
            },
            '.i-upload_preview:hover .i-upload_preview-remove.active': {
                visibility: 'visible',
                opacity: 1,
            },
            '.i-upload_list': {
                margin: '1rem 0 2rem',
                display: 'flex',
                gap: 7,
                width: '100%',
            },
            '.i-upload_list.i-upload_list-picture': {
                flexDirection: 'row',
            },
            '.i-upload_list.i-upload_list-text': {
                flexDirection: 'column',
                alignContent: 'center',
            },
            '.i-upload_list.i-upload_list-text i-icon': {
                position: 'unset',
            },
            '.i-upload_list-item': {
                display: 'inline-flex',
                position: 'relative',
                justifyContent: 'space-between',
            },
            '.i-upload_list-item:hover i-icon': {
                display: 'block',
            },
            '.i-upload_list.i-upload_list-text .i-upload_list-item:hover': {
                backgroundColor: Theme.background.default,
            },
            '.i-upload_list.i-upload_list-text .i-upload_list-item': {
                width: '100%',
                padding: '.25rem',
            },
            '.i-upload_list-item .i-upload_list-img': {
                width: 100,
                height: 50,
                objectFit: 'cover',
            },
            '.i-upload_list-item i-icon': {
                cursor: 'pointer',
                position: 'absolute',
                right: -5,
                top: -5,
                display: 'none',
            },
        },
    });
});
define("@ijstech/upload/upload.ts", ["require", "exports", "@ijstech/base", "@ijstech/application", "@ijstech/icon", "@ijstech/label", "@ijstech/layout", "@ijstech/ipfs", "@ijstech/image", "@ijstech/style", "@ijstech/types", "@ijstech/upload/style/upload.css.ts"], function (require, exports, base_1, application_1, icon_1, label_1, layout_1, ipfs_1, image_1, Styles, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Upload = exports.genFileId = void 0;
    const Theme = Styles.Theme.ThemeVars;
    let fileId = 1;
    const genFileId = () => Date.now() + fileId++;
    exports.genFileId = genFileId;
    let UploadDrag = class UploadDrag extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this.counter = 0;
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this._labelElm && this._caption?.startsWith('$'))
                this._labelElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            let value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parent?.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this._labelElm.style.display = !value ? 'none' : '';
            if (!this._labelElm)
                return;
            this._labelElm.textContent = this.caption;
        }
        get disabled() {
            return this._disabled;
        }
        set disabled(value) {
            this._disabled = value;
        }
        handleOnDragEnter(source, event) {
            source.preventDefault();
            if (this.disabled)
                return;
            this.counter++;
            this.parentElement?.classList.add('i-upload-dragger_active');
        }
        handleOnDragOver(source, event) {
            source.preventDefault();
        }
        handleOnDragLeave(source, event) {
            if (this.disabled)
                return;
            this.counter--;
            if (this.counter === 0) {
                this.parentElement?.classList.remove('i-upload-dragger_active');
            }
        }
        async getAllFileEntries(dataTransferItemList) {
            let fileEntries = [];
            // Use BFS to traverse entire directory/file structure
            let queue = [];
            // Unfortunately dataTransferItemList is not iterable i.e. no forEach
            for (let i = 0; i < dataTransferItemList.length; i++) {
                // Note webkitGetAsEntry a non-standard feature and may change
                // Usage is necessary for handling directories
                queue.push(dataTransferItemList[i].webkitGetAsEntry());
            }
            while (queue.length > 0) {
                let entry = queue.shift();
                if (entry?.isFile) {
                    fileEntries.push(entry);
                }
                else if (entry?.isDirectory) {
                    let reader = entry.createReader();
                    queue.push(...(await this.readAllDirectoryEntries(reader)));
                }
            }
            return Promise.all(fileEntries.map((entry) => this.readEntryContentAsync(entry)));
        }
        // Get all the entries (files or sub-directories) in a directory by calling readEntries until it returns empty array
        async readAllDirectoryEntries(directoryReader) {
            let entries = [];
            let readEntries = await this.readEntriesPromise(directoryReader);
            while (readEntries.length > 0) {
                entries.push(...readEntries);
                readEntries = await this.readEntriesPromise(directoryReader);
            }
            return entries;
        }
        // Wrap readEntries in a promise to make working with readEntries easier
        async readEntriesPromise(directoryReader) {
            try {
                return await new Promise((resolve, reject) => {
                    directoryReader.readEntries(resolve, reject);
                });
            }
            catch (err) {
                console.log(err);
            }
        }
        async readEntryContentAsync(entry) {
            return new Promise((resolve, reject) => {
                let reading = 0;
                const contents = [];
                reading++;
                entry.file(async (file) => {
                    reading--;
                    const rawFile = file;
                    rawFile.path = entry.fullPath;
                    rawFile.cid = await (0, ipfs_1.hashFile)(file);
                    contents.push(rawFile);
                    if (reading === 0) {
                        resolve(contents);
                    }
                });
            });
        }
        async handleOnDrop(source, event) {
            source.preventDefault();
            if (this.disabled)
                return;
            if (typeof this.onBeforeDrop === 'function')
                this.onBeforeDrop(this);
            this.counter = 0;
            this.parentElement?.classList.remove('i-upload-dragger_active');
            const accept = this.parentElement?.getAttribute('accept');
            if (!accept) {
                if (this.onDrop) {
                    const files = await this.getAllFileEntries(source.dataTransfer.items);
                    const flattenFiles = files.reduce((acc, val) => acc.concat(val), []);
                    console.log('beforeOnDrop: ', flattenFiles);
                    this.onDrop(this, flattenFiles); //this.onDrop(this, source.dataTransfer.files);
                }
                return;
            }
            const valids = [].slice.call(source.dataTransfer.files).filter((file) => {
                const { type, name } = file;
                const extension = name.indexOf('.') > -1 ? `.${name.split('.').pop()}` : '';
                const baseType = type.replace(/\/.*$/, '');
                return accept
                    .split(',')
                    .map((type) => type.trim())
                    .filter((type) => type)
                    .some((acceptedType) => {
                    if (/\..+$/.test(acceptedType)) {
                        return extension === acceptedType;
                    }
                    if (/\/\*$/.test(acceptedType)) {
                        return baseType === acceptedType.replace(/\/\*$/, '');
                    }
                    if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
                        return type === acceptedType;
                    }
                    return false;
                });
            });
            if (this.onDrop)
                this.onDrop(this, valids);
        }
        init() {
            if (!this._wrapperElm) {
                super.init();
                this.onBeforeDrop =
                    this.getAttribute('onBeforeDrop', true) || this.onBeforeDrop;
                this.onDrop = this.getAttribute('onDrop', true) || this.onDrop;
                this._wrapperElm = this.createElement('div', this);
                this._wrapperElm.classList.add('i-upload-drag_area');
                this._labelElm = this.createElement('span', this._wrapperElm);
                this._labelElm.style.color = Theme.text.primary;
                this.caption = this.getAttribute('caption', true);
                this.disabled = this.getAttribute('disabled', true);
                this.addEventListener('dragenter', this.handleOnDragEnter.bind(this));
                this.addEventListener('dragover', this.handleOnDragOver.bind(this));
                this.addEventListener('dragleave', this.handleOnDragLeave.bind(this));
                this.addEventListener('drop', this.handleOnDrop.bind(this));
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    UploadDrag = __decorate([
        (0, base_1.customElements)('i-upload-drag')
    ], UploadDrag);
    const DEFAULT_VALUES = {
        draggable: false,
        multiple: false,
        showFileList: false,
        fileList: []
    };
    let Upload = class Upload extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                multiple: DEFAULT_VALUES.multiple
            });
            this._dt = new DataTransfer();
            // @observable('fileList')
            this._fileList = [];
        }
        get caption() {
            return this._caption;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (this.lblCaption)
                this.lblCaption.caption = this.caption || (this.draggable ? 'Drag a file or click to upload' : 'Click to upload');
        }
        get accept() {
            return this._accept;
        }
        set accept(value) {
            this._accept = value;
            this._fileElm && value && this._fileElm.setAttribute('accept', `${value}`);
        }
        get draggable() {
            return this._draggable;
        }
        set draggable(value) {
            this._draggable = value;
            if (value)
                this.classList.add('el-upload-dragger');
            else
                this.classList.remove('el-upload-dragger');
        }
        get multiple() {
            return this._multiple;
        }
        set multiple(value) {
            this._multiple = value;
            if (this._fileElm && value != null)
                this._fileElm.multiple = value;
        }
        get fileList() {
            return this._fileList;
        }
        set fileList(value) {
            this._fileList = value;
            if (value && value.length) {
                value.forEach((f) => {
                    this._dt.items.add(f);
                });
                if (this._fileElm) {
                    this._fileElm.files = this._dt.files;
                    this.updateFileListUI(this._fileElm.files);
                }
            }
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            if (this._uploadDragElm)
                this._uploadDragElm.disabled = !value || !this.draggable || this._designMode;
            if (!this._previewRemoveElm)
                return;
            if (value)
                this._previewRemoveElm.classList.add('active');
            else
                this._previewRemoveElm.classList.remove('active');
        }
        addFile(file) {
            this._dt.items.add(file);
            this._fileList.push(file);
            if (typeof this.onAdded === 'function')
                this.onAdded(this, file);
        }
        previewFile(files) {
            if (!files || !files.length)
                return;
            const imgUrl = URL.createObjectURL(files[files.length - 1]);
            this.preview(imgUrl);
        }
        async handleUpload(source, event) {
            const files = source.target.files;
            if (files) {
                const processedFiles = [];
                for (let i = 0; i < files.length; i++) {
                    const rawFile = files[i];
                    rawFile.path = `/${rawFile.name}`;
                    rawFile.cid = await (0, ipfs_1.hashFile)(rawFile);
                    processedFiles.push(rawFile);
                }
                this.proccessFiles(processedFiles);
            }
        }
        async proccessFiles(files) {
            if (!files || !files.length)
                return;
            if (!this.fileList)
                this._dt = new DataTransfer();
            for (let i = 0; i < files.length; i++) {
                let file = files[i];
                file.uid = (0, exports.genFileId)();
                if (!!this.onUploading)
                    await this.checkBeforeUpload(file);
                else
                    this.addFile(file);
            }
            this.updateFileListUI(this._dt.files);
            this.previewFile(this._dt.files);
            if (typeof this.onChanged === 'function')
                this.onChanged(this, this.fileList);
            if (typeof this.onObserverChanged === 'function')
                this.onObserverChanged(this, this.fileList);
        }
        async checkBeforeUpload(file) {
            const before = typeof this.onUploading === 'function' && this.onUploading(this, file);
            if (before && before.then) {
                before.then((value) => {
                    if (value)
                        this.addFile(file);
                }, () => {
                    if (typeof this.onRemoved === 'function')
                        this.onRemoved(this, file);
                });
            }
            else {
                if (typeof this.onRemoved === 'function')
                    this.onRemoved(this, file);
            }
        }
        updateFileListUI(files) {
            if (this._fileListElm) {
                this._fileListElm.innerHTML = '';
                for (let file of files) {
                    const itemElm = this.createElement('div', this._fileListElm);
                    itemElm.classList.add('i-upload_list-item');
                    if (file.type.includes('image/')) {
                        this._fileListElm.classList.add('i-upload_list-picture');
                        const imgElm = new Image();
                        imgElm.src = URL.createObjectURL(file);
                        imgElm.classList.add('i-upload_list-img');
                        imgElm.onload = function () {
                            URL.revokeObjectURL(imgElm.src);
                        };
                        itemElm.appendChild(imgElm);
                    }
                    else {
                        this._fileListElm.classList.add('i-upload_list-text');
                        const spanElm = this.createElement('span', itemElm);
                        spanElm.textContent = file.name;
                    }
                    const removeIcon = new icon_1.Icon(undefined, {
                        width: 12,
                        height: 12,
                        fill: Theme.action.active,
                        name: 'trash',
                    });
                    itemElm.appendChild(removeIcon);
                    removeIcon.addEventListener('click', () => this.handleRemove(file));
                }
                this._fileListElm.style.display = files.length ? 'flex' : 'none';
            }
        }
        renderPreview() {
            this._previewElm = this.createElement('div', this._wrapperElm);
            this._previewElm.classList.add('i-upload_preview');
            this._wrapImgElm = this.createElement('div', this._previewElm);
            this._wrapImgElm.classList.add('i-upload_preview-img');
            this._previewRemoveElm = this.createElement('div', this._previewElm);
            if (this.enabled) {
                this._previewRemoveElm.classList.add('active');
            }
            else {
                this._previewRemoveElm.classList.remove('active');
            }
            this._previewRemoveElm.classList.add('i-upload_preview-remove');
            this._previewRemoveElm.onclick = this.handleRemoveImagePreview.bind(this);
            const span = this.createElement('span', this._previewRemoveElm);
            span.style.fontFamily = Theme.typography.fontFamily;
            span.innerHTML = application_1.application.i18n.get('click_to_remove');
        }
        handleRemoveImagePreview(event) {
            if (!this.isPreviewing || !this.enabled)
                return;
            event.stopPropagation();
            const file = this._dt.files.length ? this._dt.files[0] : undefined;
            this.clear();
            if (typeof this.onRemoved === 'function')
                this.onRemoved(this, file);
        }
        ;
        handleRemove(file) {
            const rawFile = file;
            for (let i = 0; i < this._dt.items.length; i++) {
                if (rawFile.uid === this._dt.files[i].uid) {
                    this._dt.items.remove(i);
                    this.fileList = this._fileList.filter((f) => f.uid !== rawFile.uid);
                    if (typeof this.onRemoved === 'function')
                        this.onRemoved(this, file);
                    break;
                }
            }
            this._fileElm.files = this._dt.files;
            this.updateFileListUI(this._dt.files);
            if (!this._dt.items.length)
                this.clear();
        }
        toBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
            });
        }
        preview(uri) {
            if (!uri)
                return;
            this.isPreviewing = true;
            this._wrapImgElm.innerHTML = '';
            this._previewImgElm = new image_1.Image(undefined, {
                width: 'auto',
                height: '100%'
            });
            this._wrapImgElm.appendChild(this._previewImgElm);
            this._previewImgElm.url = uri;
            this._previewElm.style.display = 'block';
            this._wrapperFileElm.style.display = 'none';
            if (this._uploadDragElm)
                this._uploadDragElm.style.display = 'none';
        }
        clear() {
            this._fileElm.value = '';
            this._wrapperFileElm.style.display = 'block';
            if (this._uploadDragElm)
                this._uploadDragElm.style.display = this.draggable ? 'flex' : 'none';
            if (this._previewElm)
                this._previewElm.style.display = 'none';
            this._wrapImgElm && (this._wrapImgElm.innerHTML = '');
            if (this._fileListElm)
                this._fileListElm.style.display = 'none';
            this._dt = new DataTransfer();
            this.isPreviewing = false;
            this._fileList = [];
        }
        async upload() {
            const cidItems = await (0, ipfs_1.hashFiles)(this._fileList);
            let uploadUrl = await application_1.application.getUploadUrl(cidItems);
            for (let i = 0; i < this._fileList.length; i++) {
                const file = this._fileList[i];
                if (file.cid?.cid && uploadUrl[file.cid.cid]) {
                    let result = await application_1.application.upload(uploadUrl[file.cid.cid], file);
                    console.log("upload result: ", result);
                }
            }
            // let cid = await hashFiles(this._fileList);
            // let result = await application.postData(endpoint, cid);
            // console.dir(result);
        }
        addFiles() { }
        addFolder() { }
        init() {
            if (!this.initialized) {
                super.init();
                this._wrapperElm = this.createElement('div', this);
                this._wrapperElm.classList.add('i-upload-wrapper');
                this._wrapperFileElm = this.createElement('div', this._wrapperElm);
                this._caption = this.getAttribute('caption', true, '');
                this.draggable = this.getAttribute('draggable', true, DEFAULT_VALUES.draggable);
                this._uploadDragElm = new UploadDrag(this, {
                    // caption: this.caption || 'Drag a file or click to upload',
                    disabled: !this.enabled || !this.draggable || this._designMode,
                    onBeforeDrop: (source) => {
                        if (this.onBeforeDrop)
                            this.onBeforeDrop(source);
                    },
                    onDrop: (source, value) => {
                        value && this.proccessFiles(value);
                    },
                });
                this._wrapperElm.appendChild(this._uploadDragElm);
                this._fileElm = (this.createElement('input', this._wrapperFileElm));
                this._fileElm.type = 'file';
                this.multiple = this.getAttribute('multiple', true, DEFAULT_VALUES.multiple);
                this.accept = this.getAttribute('accept');
                this._fileElm.disabled = !this.enabled;
                this._fileElm.readOnly = this._designMode;
                // const btn = new Button(this, {
                //   caption: 'Choose an image',
                // });
                // btn.className = `i-upload_btn ${!this.enabled && 'disabled'}`;
                // this._wrapperFileElm.appendChild(btn);
                //
                const panel = new layout_1.VStack(undefined, {
                    alignItems: 'center',
                });
                new icon_1.Icon(panel, {
                    name: "arrow-down",
                    height: 32,
                    width: 32,
                    margin: {
                        bottom: 20
                    },
                    fill: Theme.divider
                });
                this.lblCaption = new label_1.Label(panel, {
                    caption: this.caption || (this.draggable ? 'Drag a file or click to upload' : 'Click to upload'),
                    font: {
                        size: '18px'
                    }
                });
                this._wrapperFileElm.appendChild(panel);
                const fileListAttr = this.getAttribute('showFileList', true, DEFAULT_VALUES.showFileList);
                if (fileListAttr && !this._fileListElm) {
                    this._fileListElm = this.createElement('div', this);
                    this._fileListElm.classList.add('i-upload_list');
                    this._fileListElm.style.display = 'none';
                }
                this.renderPreview();
                const fileList = this.getAttribute('fileList', true);
                fileList && (this.fileList = fileList);
                this._wrapperElm.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (!this.enabled || this._designMode)
                        return;
                    if (!this.isPreviewing)
                        this._fileElm.click();
                });
                this._fileElm.addEventListener('change', this.handleUpload.bind(this));
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Upload = __decorate([
        (0, base_1.customElements)('i-upload', {
            icon: 'file',
            group: types_1.GroupType.FIELDS,
            className: 'Upload',
            props: {
                caption: { type: 'string', default: '' },
                accept: { type: 'string', default: '' },
                draggable: { type: 'boolean', default: DEFAULT_VALUES.draggable },
                multiple: { type: 'boolean', default: DEFAULT_VALUES.multiple },
                fileList: { type: 'array', default: DEFAULT_VALUES.fileList },
                showFileList: { type: 'boolean', default: DEFAULT_VALUES.showFileList },
            },
            events: {
                onBeforeDrop: [
                    { name: 'target', type: 'Upload', isControl: true }
                ],
                onChanged: [
                    { name: 'target', type: 'Upload', isControl: true },
                    { name: 'files', type: 'UploadRawFile[]' }
                ],
                onRemoved: [
                    { name: 'target', type: 'Upload', isControl: true },
                    { name: 'file', type: 'File' }
                ],
                onAdded: [
                    { name: 'target', type: 'Upload', isControl: true },
                    { name: 'file', type: 'File' }
                ],
                onUploading: [
                    { name: 'target', type: 'Upload', isControl: true },
                    { name: 'file', type: 'File' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    caption: {
                        type: 'string'
                    },
                    accept: {
                        type: 'string'
                    },
                    draggable: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.draggable
                    },
                    multiple: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.multiple
                    },
                    showFileList: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.showFileList
                    }
                }
            }
        })
    ], Upload);
    exports.Upload = Upload;
});
define("@ijstech/upload", ["require", "exports", "@ijstech/upload/upload.ts"], function (require, exports, upload_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Upload = void 0;
    Object.defineProperty(exports, "Upload", { enumerable: true, get: function () { return upload_1.Upload; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/module/module.ts", ["require", "exports", "@ijstech/base", "@ijstech/checkbox", "@ijstech/combo-box", "@ijstech/input", "@ijstech/modal", "@ijstech/radio", "@ijstech/switch", "@ijstech/upload", "@ijstech/application", "@ijstech/datepicker"], function (require, exports, base_1, checkbox_1, combo_box_1, input_1, modal_1, radio_1, switch_1, upload_1, application_1, datepicker_1) {
    "use strict";
    var Module_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Module = void 0;
    function ProxySetter(obj, prop, value) {
        obj['__target'][prop] = value;
        return true;
    }
    function ProxyGetter(target, prop) {
        if (typeof (target.__target[prop]) == 'function') {
            return target.__target[prop].bind(target.__target);
        }
        if (prop == '__target')
            return target['__target'];
        else if (prop == '__path')
            return target['__path'];
        else if (prop == '$renderElms' && target.__target)
            return target.__target['$renderElms'];
        // else if ((!target.__target['$observableProps'] || !target.__target['$observableProps'][prop]) && (!target['__path'] || target['__path'].length == 0)){
        //     return target.__target[prop];
        // }
        let path;
        if (target.__root)
            path = [];
        else
            path = target.__path || [];
        path.push(prop);
        return ProxyObject({
            __target: target.__target,
            __path: path
        });
    }
    function ProxyObject(target, root) {
        if (target.__root)
            root = true;
        let path;
        if (root)
            path = [];
        else
            path = target.__path || [];
        if (target.__target)
            target = target.__target;
        return new Proxy({ __root: root, __target: target, __path: path }, {
            get: ProxyGetter,
            set: ProxySetter
        });
    }
    function getObservable(target, paths) {
        if ((0, base_1.isObservable)(target))
            return target;
        if (target === undefined || target === null)
            return;
        let path = paths.shift();
        if (paths.length == 0) {
            if (typeof (target['observables']) == 'function')
                return target['observables'](path);
            else if (path && typeof (target) == 'object')
                return target[path];
        }
        else
            return getObservable(target[path], paths);
    }
    function bindObservable(elm, prop) {
        const fn = function (changes) {
            const changeData = changes[0];
            const type = changeData.type;
            if (Array.isArray(changeData.object)) {
                if (type === 'shuffle' || type === 'reverse' || changeData.path?.length > 1) {
                    elm[prop] = changeData.object;
                }
                else if (changeData.path?.length) {
                    let newArray = elm[prop];
                    if (type === 'delete') {
                        newArray[changeData.path[0]] = undefined;
                        newArray = newArray.filter((item) => item !== undefined);
                    }
                    else if (type === 'insert' || type === 'update') {
                        newArray[changeData.path[0]] = changeData.value;
                    }
                    elm[prop] = newArray;
                }
            }
            else {
                if ('value' in changeData) {
                    elm[prop] = changeData.value;
                }
                else {
                    console.warn('Unhandled change type or missing value:', changeData);
                }
            }
        };
        return fn;
    }
    let Module = Module_1 = class Module extends base_1.Container {
        // static updateLocale(): void {
        //     for (let key in Module._modules){
        //         Module._modules[key].updateLocale();
        //     };
        // };
        static async create(options, parent, defaults) {
            let self = new this(parent, options, defaults);
            await self.ready();
            return self;
        }
        ;
        constructor(parent, options, defaults) {
            super(parent, options, defaults);
            this.$renderElms = [];
            this.isModule = true;
            let proxy = ProxyObject(this, true);
            this.$render = this._render.bind(proxy);
        }
        get i18n() {
            if (!this._i18n)
                this._i18n = new base_1.I18n();
            return this._i18n;
        }
        ;
        updateLocale() {
            if (this._i18n)
                super.updateLocale(this._i18n);
        }
        ;
        init() {
            super.init();
            this.$renderElms = [];
            let proxy = ProxyObject(this, true);
            let render = this.render.bind(proxy);
            let r = window['Render'];
            window['Render'] = this._render.bind(proxy);
            render();
            for (let i = 0; i < this.$renderElms.length; i++) {
                let elm = this.$renderElms[i].elm;
                let options = this.$renderElms[i].options;
                for (let prop in options) {
                    let value = options[prop];
                    if (value?.__target) {
                        let target = value.__target;
                        let paths = value.__path;
                        let targetValue = this.getAttributeValue(target, paths);
                        let observable = getObservable(target, paths);
                        if ((0, base_1.isObservable)(observable)) {
                            if (paths.length > 0) {
                                (0, base_1.Observe)(observable, bindObservable(elm, prop), { path: paths.join('.') });
                                const onObserverChanged = elm['onObserverChanged'];
                                elm.onObserverChanged = (target, event) => {
                                    const observables = proxy?.__target?.['$observables'];
                                    for (const prop in observables) {
                                        const observable = observables[prop];
                                        let target = observable;
                                        for (let i = 0; i < paths.length - 1; i++) {
                                            target = target?.[paths[i]];
                                        }
                                        if (target) {
                                            const lastProp = paths[paths.length - 1];
                                            target[lastProp] = this._getValueByControl(elm);
                                        }
                                    }
                                    if (typeof onObserverChanged === 'function') {
                                        onObserverChanged(target, event);
                                    }
                                };
                            }
                            else {
                                (0, base_1.Observe)(observable, bindObservable(elm, prop));
                                const observables = proxy?.__target?.['$observables'];
                                let updatedProp = '';
                                for (const p in observables) {
                                    if (observables[p] === observable) {
                                        updatedProp = p;
                                        break;
                                    }
                                }
                                const onObserverChanged = elm['onObserverChanged'];
                                elm.onObserverChanged = (target, event) => {
                                    if (updatedProp && updatedProp !== prop) {
                                        const newValue = this._getValueByControl(elm);
                                        ProxySetter(proxy, updatedProp, newValue);
                                    }
                                    if (typeof onObserverChanged === 'function') {
                                        onObserverChanged(target, event);
                                    }
                                };
                            }
                        }
                        elm[prop] = targetValue;
                    }
                }
            }
            this.$renderElms = [];
            window['Render'] = r;
        }
        _getValueByControl(elm) {
            if (elm instanceof radio_1.RadioGroup) {
                return elm.selectedValue;
            }
            else if (elm instanceof switch_1.Switch || elm instanceof checkbox_1.Checkbox || (elm instanceof input_1.Input && elm.inputType === 'checkbox')) {
                return elm.checked;
            }
            else if (elm instanceof upload_1.Upload) {
                return elm.fileList;
            }
            else if (elm instanceof combo_box_1.ComboBox || (elm instanceof input_1.Input && elm.inputType === 'combobox')) {
                return elm.value;
            }
            else if (elm instanceof datepicker_1.Datepicker) {
                return elm.valueFormat;
            }
            else {
                return elm.value;
            }
        }
        flattenArray(arr) {
            return arr.reduce((result, item) => {
                if (Array.isArray(item)) {
                    const temp = this.flattenArray(item);
                    result = result.concat(temp);
                }
                else {
                    result.push(item);
                }
                return result;
            }, []);
        }
        ;
        _render(...params) {
            let tag = params[0];
            let options = params[1];
            let elm = this.createElement(tag);
            if (options) {
                this.$renderElms.push({
                    elm: elm,
                    options: options
                });
                elm.attrs = options;
                for (let v in options) {
                    if (v == 'id') {
                        this[options[v]] = elm;
                        elm.id = options[v];
                    }
                    else if (typeof (options[v]) == 'function')
                        elm[v] = options[v].bind(this);
                    else if (typeof (options[v]) != 'object')
                        elm.setAttribute(v, options[v]);
                }
            }
            const newParams = this.flattenArray(params);
            for (let i = 2; i < newParams.length; i++) {
                if (typeof newParams[i] == 'string') {
                    elm.textContent = newParams[i];
                }
                else
                    elm.appendChild(newParams[i]);
            }
            this.appendChild(elm);
            return elm;
        }
        render() {
        }
        ;
        onLoad() {
        }
        ;
        onShow(options) {
        }
        ;
        onHide() {
        }
        ;
        connectedCallback() {
            application_1.Application.registerModule(this.uuid, this); // _modules[this.uuid] = this;
            super.connectedCallback();
        }
        ;
        disconnectedCallback() {
            delete Module_1._modalMap[this.uuid];
            // delete Module._modules[this.uuid];
            application_1.Application.unregisterModule(this.uuid);
            super.disconnectedCallback();
        }
        ;
        openModal(options) {
            let modal = Module_1._modalMap[this.uuid];
            if (modal) {
                modal.title = options?.title || '';
                modal.zIndex = options?.zIndex || 10;
                if (options?.linkTo)
                    modal.linkTo = options.linkTo;
                modal.showBackdrop = options?.showBackdrop ?? true;
                modal.visible = true;
                document.body.appendChild(modal);
                Module_1._modalMap[this.uuid] = modal;
                return modal;
            }
            const showBackdrop = options?.showBackdrop ?? true;
            const modalOptions = {
                border: { radius: 10 },
                closeIcon: showBackdrop ? { name: 'times' } : null,
                ...options
            };
            modal = new modal_1.Modal(undefined, {
                ...modalOptions,
            });
            document.body.appendChild(modal);
            Module_1._modalMap[this.uuid] = modal;
            modal.body = this;
            modal.zIndex = options?.zIndex || 10;
            if (options?.linkTo)
                modal.linkTo = options.linkTo;
            modal.showBackdrop = options?.showBackdrop ?? true;
            modal.visible = true;
            return modal;
        }
        closeModal() {
            let modal = Module_1._modalMap[this.uuid];
            if (modal) {
                modal.visible = false;
            }
            if (document.body.contains(modal)) {
                document.body.removeChild(modal);
            }
        }
    };
    Module._modalMap = {};
    Module = Module_1 = __decorate([
        (0, base_1.customElements)('i-module')
    ], Module);
    exports.Module = Module;
});
define("@ijstech/module", ["require", "exports", "@ijstech/module/module.ts"], function (require, exports, module_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Module = void 0;
    Object.defineProperty(exports, "Module", { enumerable: true, get: function () { return module_1.Module; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/tooltip/style/tooltip.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    const arrowBackgroundColor = "var(--tooltips-arrow-background, var(--background-modal))";
    const borderColor = "var(--divider)";
    Styles.cssRule("body", {
        $nest: {
            ".ii-tooltip": {
                position: "absolute",
                display: "inline-block",
                fontFamily: Theme.typography.fontFamily,
                backgroundColor: Theme.background.modal,
                borderRadius: "4px",
                color: Theme.text.primary,
                padding: "4px 8px",
                fontSize: "0.6875rem",
                maxWidth: "300px",
                overflowWrap: "break-word",
                fontWeight: 500,
                zIndex: 9999,
                border: `1px solid ${Theme.divider}`,
                filter: `drop-shadow(0px 6px 6px rgba(0, 0, 0, 0.5))`
            },
            '.ii-tooltip-arrow': {
                position: "absolute",
                borderWidth: "7px",
                borderStyle: "solid",
                borderColor: `transparent transparent ${borderColor} transparent`,
            },
            '.ii-tooltip-arrow::after': {
                content: "''",
                position: "absolute",
                top: 2,
                left: 0,
                transform: 'translate(-50%, -50%)',
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
            },
            '.ii-tooltip-top .ii-tooltip-arrow': {
                top: "100%",
                left: "50%",
                transform: 'translateX(-50%)',
                borderColor: `${borderColor} transparent transparent transparent`,
                $nest: {
                    '&::after': {
                        top: -2,
                        borderColor: `${arrowBackgroundColor} transparent transparent transparent`,
                    }
                }
            },
            '.ii-tooltip-topLeft .ii-tooltip-arrow': {
                top: "100%",
                left: "10px",
                borderColor: `${borderColor} transparent transparent transparent`,
                $nest: {
                    '&::after': {
                        top: -2,
                        borderColor: `${arrowBackgroundColor} transparent transparent transparent`,
                    }
                }
            },
            '.ii-tooltip-topRight .ii-tooltip-arrow': {
                top: "100%",
                right: "10px",
                borderColor: `${borderColor} transparent transparent transparent`,
                $nest: {
                    '&::after': {
                        top: -2,
                        borderColor: `${arrowBackgroundColor} transparent transparent transparent`,
                    }
                }
            },
            '.ii-tooltip-left .ii-tooltip-arrow': {
                top: "50%",
                left: "100%",
                marginTop: "-5px",
                borderColor: `transparent transparent transparent ${borderColor}`,
                $nest: {
                    '&::after': {
                        left: -2,
                        top: 0,
                        borderColor: `transparent transparent transparent ${arrowBackgroundColor}`,
                    }
                }
            },
            '.ii-tooltip-leftTop .ii-tooltip-arrow': {
                top: "0%",
                left: "100%",
                marginTop: "5px",
                borderColor: `transparent transparent transparent ${borderColor}`,
                $nest: {
                    '&::after': {
                        borderColor: `transparent transparent transparent ${arrowBackgroundColor}`,
                    }
                }
            },
            '.ii-tooltip-leftBottom .ii-tooltip-arrow': {
                bottom: "0%",
                left: "100%",
                marginBottom: "5px",
                borderColor: `transparent transparent transparent ${borderColor}`,
                $nest: {
                    '&::after': {
                        borderColor: `transparent transparent transparent ${arrowBackgroundColor}`,
                    }
                }
            },
            '.ii-tooltip-right .ii-tooltip-arrow': {
                top: "50%",
                right: "100%",
                marginTop: "-5px",
                borderColor: `transparent ${borderColor} transparent transparent`,
                $nest: {
                    '&::after': {
                        left: 2,
                        top: 0,
                        borderColor: `transparent ${arrowBackgroundColor} transparent transparent`,
                    }
                }
            },
            '.ii-tooltip-rightTop .ii-tooltip-arrow': {
                top: "0%",
                right: "100%",
                marginTop: "5px",
                borderColor: `transparent ${borderColor} transparent transparent`,
                $nest: {
                    '&::after': {
                        left: 2,
                        top: 0,
                        borderColor: `transparent ${arrowBackgroundColor} transparent transparent`,
                    }
                }
            },
            '.ii-tooltip-rightBottom .ii-tooltip-arrow': {
                bottom: "0%",
                right: "100%",
                marginBottom: "5px",
                borderColor: `transparent ${borderColor} transparent transparent`,
                $nest: {
                    '&::after': {
                        left: 2,
                        top: 0,
                        borderColor: `transparent ${arrowBackgroundColor} transparent transparent`,
                    }
                }
            },
            '.ii-tooltip-bottom .ii-tooltip-arrow': {
                bottom: "100%",
                left: "50%",
                transform: 'translateX(-50%)',
                borderColor: `transparent transparent ${borderColor} transparent`,
                $nest: {
                    '&::after': {
                        borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
                    }
                }
            },
            '.ii-tooltip-bottomLeft .ii-tooltip-arrow': {
                bottom: "100%",
                left: "10px",
                borderColor: `transparent transparent ${borderColor} transparent`,
                $nest: {
                    '&::after': {
                        borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
                    }
                }
            },
            '.ii-tooltip-bottomRight .ii-tooltip-arrow': {
                bottom: "100%",
                right: "10px",
                borderColor: `transparent transparent ${borderColor} transparent`,
                $nest: {
                    '&::after': {
                        borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
                    }
                }
            }
        },
    });
});
define("@ijstech/tooltip/tooltip.ts", ["require", "exports", "@ijstech/base", "@ijstech/application", "@ijstech/label", "@ijstech/tooltip/style/tooltip.css.ts"], function (require, exports, base_1, application_1, label_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tooltip = void 0;
    const DEFAULT_DURATION = 2000;
    let Tooltip = class Tooltip extends base_1.Control {
        constructor(parent, parentI18n) {
            super(parent);
            if (parentI18n)
                this._parentI18n = parentI18n;
            this.initData(parent);
            this.initEvents(parent);
        }
        initData(source) {
            const data = source.getAttribute('tooltip', true);
            let options = data;
            if (typeof data === 'string') {
                try {
                    options = JSON.parse(data);
                }
                catch {
                    options = null;
                }
            }
            this.content = options?.content || '';
            this.popperClass = options?.popperClass || 'tooltip-content';
            this.placement = options?.placement || 'top';
            this.trigger = options?.trigger || 'hover';
            // this.color = options?.color || 'rgba(0,0,0,.75)'
            if (options?.color)
                this.color = options.color;
            if (options?.maxWidth)
                this.maxWidth = options.maxWidth;
        }
        positionAt(parent, tooltip, placement) {
            const parentCoords = parent.getBoundingClientRect();
            let left = 0;
            let top = 0;
            const dist = 10;
            switch (placement) {
                case "top":
                    top = parentCoords.top - tooltip.offsetHeight - dist;
                    left = parentCoords.left + (parent.offsetWidth - tooltip.offsetWidth) / 2;
                    break;
                case "topLeft":
                    top = parentCoords.top - tooltip.offsetHeight - dist;
                    left = parentCoords.left;
                    break;
                case "topRight":
                    top = parentCoords.top - tooltip.offsetHeight - dist;
                    left = parentCoords.left + parent.offsetWidth - tooltip.offsetWidth;
                    break;
                case "left":
                    top = (parentCoords.top + parentCoords.bottom) / 2 - tooltip.offsetHeight / 2;
                    left = parentCoords.left - dist - tooltip.offsetWidth;
                    if (parentCoords.left - tooltip.offsetWidth < 0) {
                        left = dist;
                    }
                    break;
                case "leftTop":
                    top = parentCoords.top;
                    left = parentCoords.left - dist - tooltip.offsetWidth;
                    if (parentCoords.left - tooltip.offsetWidth < 0) {
                        left = dist;
                    }
                    break;
                case "leftBottom":
                    top = parentCoords.top + parent.offsetHeight - tooltip.offsetHeight;
                    left = parentCoords.left - dist - tooltip.offsetWidth;
                    if (parentCoords.left - tooltip.offsetWidth < 0) {
                        left = dist;
                    }
                    break;
                case "right":
                    top = (parentCoords.top + parentCoords.bottom) / 2 - tooltip.offsetHeight / 2;
                    left = parentCoords.right + dist;
                    if (parentCoords.right + tooltip.offsetWidth > document.documentElement.clientWidth) {
                        left = document.documentElement.clientWidth - tooltip.offsetWidth - dist;
                    }
                    break;
                case "rightTop":
                    top = parentCoords.top;
                    left = parentCoords.right + dist;
                    if (parentCoords.right + tooltip.offsetWidth > document.documentElement.clientWidth) {
                        left = document.documentElement.clientWidth - tooltip.offsetWidth - dist;
                    }
                    break;
                case "rightBottom":
                    top = parentCoords.top + parent.offsetHeight - tooltip.offsetHeight;
                    left = parentCoords.right + dist;
                    if (parentCoords.right + tooltip.offsetWidth > document.documentElement.clientWidth) {
                        left = document.documentElement.clientWidth - tooltip.offsetWidth - dist;
                    }
                    break;
                case "bottom":
                    top = parentCoords.bottom + dist;
                    left = parentCoords.left + (parent.offsetWidth - tooltip.offsetWidth) / 2;
                    break;
                case "bottomLeft":
                    top = parentCoords.bottom + dist;
                    left = parentCoords.left;
                    break;
                case "bottomRight":
                    top = parentCoords.bottom + dist;
                    left = parentCoords.left + parent.offsetWidth - tooltip.offsetWidth;
                    break;
            }
            left = left < 0 ? parentCoords.left : left;
            top = top < 0 ? parentCoords.bottom + dist : top;
            tooltip.style.left = left + "px";
            tooltip.style.top = top + pageYOffset + "px";
        }
        get trigger() {
            return this._trigger;
        }
        set trigger(value) {
            this._trigger = value;
        }
        get popperClass() {
            return this._popperClass;
        }
        set popperClass(value) {
            this._popperClass = value;
            if (this.tooltipElm && value)
                this.tooltipElm.classList.add(this.popperClass);
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            if (this.tooltipElm && value) {
                this.tooltipElm.style.setProperty("--tooltips-arrow-background", this.color);
            }
        }
        updateLocale(i18n) {
            if (this.tooltipElm && this._content?.startsWith('$')) {
                const text = i18n.get(this._content) || '';
                this.createLabels(text, this.tooltipElm);
            }
        }
        get content() {
            let value = this._content || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    this._parentI18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        set content(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._content = value;
            if (this.tooltipElm) {
                this.createLabels(this.content, this.tooltipElm);
            }
        }
        get placement() {
            return this._placement;
        }
        set placement(value) {
            this._placement = value;
            if (this.tooltipElm)
                this.tooltipElm.classList.add(`ii-tooltip-${this.placement}`);
        }
        get duration() {
            return this._duration;
        }
        set duration(value) {
            this._duration = value;
        }
        get isSmallScreen() {
            return screen.width <= 1024;
        }
        get maxWidth() {
            return this._maxWidth;
        }
        set maxWidth(value) {
            this._maxWidth = value;
            if (this.tooltipElm && value)
                this.tooltipElm.style.maxWidth = this.maxWidth;
        }
        get designMode() {
            return this._designMode;
        }
        set designMode(value) {
            this._designMode = value;
        }
        show(elm) {
            if (!this.tooltipElm)
                this.renderTooltip();
            document.body.appendChild(this.tooltipElm);
            this.positionAt(elm, this.tooltipElm, this.placement);
        }
        close() {
            if (this.tooltipElm && document.body.contains(this.tooltipElm))
                document.body.removeChild(this.tooltipElm);
        }
        onHandleClick(elm) {
            if (this._designMode)
                return;
            this.show(elm);
            this.timeout = setTimeout(() => {
                clearTimeout(this.timeout);
                if (this.tooltipElm && document.body.contains(this.tooltipElm))
                    document.body.removeChild(this.tooltipElm);
            }, this.duration || DEFAULT_DURATION);
        }
        renderTooltip() {
            this.tooltipElm = document.createElement("div");
            this.tooltipElm.classList.add("ii-tooltip");
            this.tooltipArrowElm = document.createElement("div");
            this.tooltipArrowElm.classList.add("ii-tooltip-arrow");
            this.createLabels(this.content, this.tooltipElm);
            this.tooltipElm.classList.add(this.popperClass);
            this.tooltipElm.classList.add(`ii-tooltip-${this.placement}`);
            if (this.color) {
                this.tooltipElm.style.backgroundColor = this.color;
                this.tooltipElm.style.setProperty("--tooltips-arrow-background", this.color);
            }
            if (this.maxWidth)
                this.tooltipElm.style.maxWidth = this.maxWidth;
        }
        createLabels(text, parent) {
            parent.innerHTML = '';
            if (!text)
                return;
            const elements = [];
            const newText = text.replace(/\r\n|\r|<br>/g, '\n');
            const lines = newText.split('\n');
            lines.forEach(line => {
                const label = new label_1.Label(undefined, {
                    caption: line,
                    display: 'block',
                    overflowWrap: "anywhere",
                    font: { size: '0.6875rem' }
                });
                parent.appendChild(label);
                elements.push(label);
            });
            parent.appendChild(this.tooltipArrowElm);
            return elements;
        }
        initEvents(source) {
            source.addEventListener('mouseover', e => {
                if (!this._content || this._designMode)
                    return;
                if (this.trigger === 'hover') {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    this.show(source);
                    source.addEventListener("mouseleave", (e) => {
                        this.close();
                    });
                }
            });
            source.addEventListener("mousedown", (e) => {
                if (!this._content || this._designMode)
                    return;
                if (this.trigger === 'click' || this.isSmallScreen) {
                    this.onHandleClick(source);
                }
                else {
                    this.close();
                }
            });
        }
    };
    Tooltip = __decorate([
        (0, base_1.customElements)('i-tooltip')
    ], Tooltip);
    exports.Tooltip = Tooltip;
});
define("@ijstech/tooltip", ["require", "exports", "@ijstech/tooltip/tooltip.ts"], function (require, exports, tooltip_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tooltip = void 0;
    Object.defineProperty(exports, "Tooltip", { enumerable: true, get: function () { return tooltip_1.Tooltip; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/button/style/button.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-button', {
        background: Theme.colors.primary.main,
        boxShadow: Theme.shadows[2],
        color: Theme.text.primary,
        // display: 'inline-block',
        // verticalAlign: 'middle',
        // textAlign: 'center',
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        borderRadius: 4,
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        cursor: 'pointer',
        userSelect: 'none',
        $nest: {
            "&:not(.disabled):hover": {
            // cursor: 'pointer',            
            // backgroundColor: Theme.colors.primary.dark,
            // boxShadow: Theme.shadows[4],
            // background: Theme.colors.primary.main
            },
            "&.disabled": {
                color: Theme.text.disabled,
                boxShadow: Theme.shadows[0],
                background: Theme.action.disabledBackground,
                cursor: 'not-allowed'
            },
            "i-icon": {
                display: 'inline-block',
                fill: Theme.text.primary,
                verticalAlign: 'middle',
            },
            '.caption': {
                paddingRight: '.5rem'
            },
            "&.is-spinning, &.is-spinning:not(.disabled):hover, &.is-spinning:not(.disabled):focus": {
                color: Theme.text.disabled,
                boxShadow: Theme.shadows[0],
                background: Theme.action.disabledBackground,
                cursor: 'default'
            },
            "&.has-caption": {
                gap: 5
            }
        }
    });
});
define("@ijstech/button/button.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/style", "@ijstech/types", "@ijstech/application", "@ijstech/button/style/button.css.ts"], function (require, exports, base_1, icon_1, style_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Button = void 0;
    const defaultIcon = {
        width: 16,
        height: 16,
        fill: style_1.Theme.ThemeVars.text.primary
    };
    let Button = class Button extends base_1.Control {
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        constructor(parent, options) {
            super(parent, options);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionElm && this._caption?.startsWith('$'))
                this.captionElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            const value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(this._caption) ||
                    application_1.application.i18n?.get(this._caption) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (!this.captionElm)
                return;
            this.captionElm.textContent = this.caption;
            this.captionElm.style.display = value ? "" : "none";
        }
        get icon() {
            if (!this._icon) {
                let iconAttr = this.getAttribute('icon', true);
                iconAttr = { ...defaultIcon, ...iconAttr };
                this._icon = new icon_1.Icon(this, iconAttr);
                this.prependIcon(this._icon);
            }
            return this._icon;
        }
        set icon(value) {
            if (this._icon && this.contains(this._icon))
                this.removeChild(this._icon);
            this._icon = value;
            this.prependIcon(this._icon);
        }
        get rightIcon() {
            if (!this._rightIcon) {
                let rightIconAttr = this.getAttribute('rightIcon', true);
                this._rightIcon = new icon_1.Icon(this, {
                    ...defaultIcon,
                    name: 'spinner',
                    ...rightIconAttr
                });
                this.appendIcon(this._rightIcon);
            }
            return this._rightIcon;
        }
        set rightIcon(value) {
            if (this._rightIcon && this.contains(this._rightIcon))
                this.removeChild(this._rightIcon);
            this._rightIcon = value;
            this.appendIcon(this._rightIcon);
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            if (!value && this._background) {
                let bg = '';
                this._background?.image && (bg += `url(${this._background?.image})`);
                this._background?.color && (bg += `${this._background?.color}`);
                this.style.background = bg;
            }
        }
        get isSpinning() {
            return (this._icon && this._icon.spin && this._icon.visible) ||
                (this._rightIcon && this._rightIcon.spin && this._rightIcon.visible);
        }
        prependIcon(icon) {
            if (!icon)
                return;
            this.appendChild(icon);
            this.captionElm &&
                this.insertBefore(icon, this.captionElm);
        }
        appendIcon(icon) {
            if (!icon)
                return;
            this.appendChild(icon);
            this.captionElm &&
                this.insertBefore(this.captionElm, icon);
        }
        updateButton() {
            if (this.isSpinning)
                this.classList.add('is-spinning');
            else
                this.classList.remove('is-spinning');
            if (!this.enabled && this._background) {
                let bg = '';
                this._background?.image && (bg += `url(${this._background?.image})`);
                this._background?.color && (bg += `${this._background?.color}`);
                this.style.background = bg;
            }
            if (this._caption)
                this.classList.add('has-caption');
            else
                this.classList.remove('has-caption');
        }
        _handleClick(event) {
            if (this.isSpinning || !this.enabled || this._designMode)
                return false;
            return super._handleClick(event);
        }
        refresh() {
            super.refresh();
            this.updateButton();
        }
        init() {
            if (!this.captionElm) {
                super.init();
                this.onClick = this.getAttribute('onClick', true) || this.onClick;
                this.captionElm = this.createElement('span', this);
                let caption = this.getAttribute('caption', true, '');
                this.caption = caption;
                // if (this.height)
                //     defaultIcon.width = defaultIcon.height = Math.floor(+this.height / 2)
                let iconAttr = this.getAttribute('icon', true);
                if (iconAttr?.name || iconAttr?.image?.url) {
                    iconAttr = { ...defaultIcon, ...iconAttr };
                    const icon = new icon_1.Icon(this, iconAttr);
                    this.icon = icon;
                }
                let rightIconAttr = this.getAttribute('rightIcon', true);
                if (rightIconAttr?.name || rightIconAttr?.image?.url) {
                    rightIconAttr = { ...defaultIcon, name: 'spinner', ...rightIconAttr };
                    const icon = new icon_1.Icon(this, rightIconAttr);
                    this.rightIcon = icon;
                }
            }
        }
    };
    Button = __decorate([
        (0, base_1.customElements)('i-button', {
            icon: 'closed-captioning',
            className: 'Button',
            props: {
                caption: {
                    type: 'string',
                    default: ''
                },
                icon: {
                    type: 'object',
                    default: {}
                },
                rightIcon: {
                    type: 'object',
                    default: {}
                },
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    caption: {
                        type: 'string'
                    },
                    icon: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string'
                            },
                            fill: {
                                type: 'string',
                                format: 'color'
                            },
                            width: {
                                type: 'number'
                            },
                            height: {
                                type: 'number'
                            },
                            image: {
                                type: 'object',
                                properties: {
                                    url: {
                                        type: 'string'
                                    }
                                }
                            }
                        }
                    },
                    rightIcon: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string'
                            },
                            fill: {
                                type: 'string',
                                format: 'color'
                            },
                            width: {
                                type: 'number'
                            },
                            height: {
                                type: 'number'
                            },
                            image: {
                                type: 'object',
                                properties: {
                                    url: {
                                        type: 'string'
                                    }
                                }
                            }
                        }
                    }
                }
            },
            group: types_1.GroupType.BASIC
        })
    ], Button);
    exports.Button = Button;
});
define("@ijstech/button", ["require", "exports", "@ijstech/button/button.ts"], function (require, exports, button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Button = void 0;
    Object.defineProperty(exports, "Button", { enumerable: true, get: function () { return button_1.Button; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/tab/style/tab.css.ts", ["require", "exports", "@ijstech/base", "@ijstech/style", "@ijstech/base"], function (require, exports, base_1, Styles, base_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTabMediaQueriesStyleClass = void 0;
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-tabs', {
        display: 'block',
        $nest: {
            '> .tabs-nav-wrap': {
                display: 'flex',
                flex: 'none',
                overflow: 'hidden',
                // background: "#252525",
                $nest: {
                    '.tabs-nav': {
                        position: 'relative',
                        display: 'flex',
                        flex: 'none',
                        overflow: 'hidden',
                        whiteSpace: 'nowrap',
                        borderBottom: `1px solid #252525`,
                        margin: 0,
                    },
                    '.tabs-nav:not(.is-closable) span.close': {
                        display: 'none'
                    },
                    '.tabs-nav .has-icon span.close': {
                        display: 'none'
                    },
                    '.tabs-nav.is-closable i-tab:not(.disabled):hover span.close': {
                        visibility: 'visible',
                        opacity: 1,
                        display: 'inline-block'
                    },
                    '.tabs-nav.is-closable i-tab:not(.disabled):hover .pnl-right i-icon': {
                        display: 'none'
                    },
                    '.tabs-nav.is-closable i-tab:not(.disabled).active span.close': {
                        visibility: 'visible',
                        opacity: 1,
                    },
                    'i-tab': {
                        position: 'relative',
                        display: 'inline-flex',
                        overflow: 'hidden',
                        color: 'rgba(255, 255, 255, 0.55)',
                        // background: "#2e2e2e",
                        marginBottom: '-1px',
                        border: `1px solid #252525`,
                        alignItems: 'center',
                        font: 'inherit',
                        textAlign: 'center',
                        minHeight: '36px',
                        $nest: {
                            '&:not(.disabled):hover': {
                                cursor: 'pointer',
                                color: '#fff'
                            },
                            '&:not(.disabled).active.border': {
                                borderColor: `${Theme.divider} ${Theme.divider} #fff`,
                                borderBottomWidth: '1.5px',
                            },
                            '.tab-item': {
                                position: 'relative',
                                display: 'flex',
                                alignItems: 'center',
                                cursor: 'pointer',
                                padding: '0.5rem 1rem',
                                gap: '5px',
                                $nest: {
                                    'i-image': {
                                        display: 'flex'
                                    }
                                }
                            }
                        }
                    },
                    'i-tab:not(.disabled).active': {
                        backgroundColor: '#1d1d1d',
                        borderBottomColor: 'transparent',
                        color: '#fff'
                    },
                }
            },
            '&:not(.vertical) > .tabs-nav-wrap': {
                $nest: {
                    '&:hover': {
                        overflowX: 'auto',
                        overflowY: 'hidden',
                    },
                    '&::-webkit-scrollbar-thumb': {
                        background: '#4b4b4b',
                        borderRadius: '5px',
                    },
                    '&::-webkit-scrollbar': {
                        height: '3px',
                    }
                }
            },
            '&.vertical': {
                display: 'flex',
                $nest: {
                    '> .tabs-nav-wrap .tabs-nav': {
                        display: 'flex',
                        flexDirection: 'column',
                    },
                    '> .tabs-nav-wrap .tabs-nav:hover': {
                        overflowY: 'auto',
                    },
                    '> .tabs-nav-wrap .tabs-nav::-webkit-scrollbar-thumb': {
                        background: '#4b4b4b',
                        borderRadius: '5px',
                    },
                    '> .tabs-nav-wrap .tabs-nav::-webkit-scrollbar': {
                        width: '3px',
                    },
                }
            },
            '> .tabs-content': {
                position: 'relative',
                overflow: 'hidden',
                display: 'flex',
                width: '100%',
                height: '100%',
                minHeight: '200px',
                $nest: {
                    '&::after': {
                        clear: 'both'
                    },
                    'i-label .f1yauex0': {
                        whiteSpace: 'normal'
                    },
                    '.content-pane': {
                        position: 'relative',
                        width: '100%',
                        height: '100%',
                        flex: 'none'
                    }
                }
            },
            'span.close': {
                width: '18px',
                height: '18px',
                borderRadius: '5px',
                lineHeight: '18px',
                fontSize: '18px',
                visibility: 'hidden',
                opacity: 0,
                $nest: {
                    '&:hover': {
                        background: 'rgba(78, 78, 78, 0.48)'
                    }
                }
            },
            '.pnl-right': {
                display: 'inline-flex',
                justifyContent: 'end',
                width: 20,
                overflow: 'hidden',
                marginLeft: 5,
                marginRight: -5
            }
        }
    });
    const getTabMediaQueriesStyleClass = (mediaQueries) => {
        let styleObj = (0, base_1.getControlMediaQueriesStyle)(mediaQueries, { display: 'block' });
        for (let mediaQuery of mediaQueries) {
            let mediaQueryRule = (0, base_2.getMediaQueryRule)(mediaQuery);
            if (mediaQueryRule) {
                const nestObj = styleObj['$nest'][mediaQueryRule]['$nest'] || {};
                const ruleObj = styleObj['$nest'][mediaQueryRule];
                styleObj['$nest'][mediaQueryRule] = {
                    ...ruleObj,
                    $nest: {
                        ...nestObj,
                        '> .tabs-nav-wrap .tabs-nav': {}
                    }
                };
                const { mode, visible } = mediaQuery.properties || {};
                if (mode) {
                    styleObj['$nest'][mediaQueryRule]['display'] = mode === 'vertical' ? 'flex !important' : 'block !important';
                    if (mode === 'horizontal') {
                        styleObj['$nest'][mediaQueryRule]['$nest']['> .tabs-nav-wrap .tabs-nav']['flexDirection'] = 'row !important';
                        styleObj['$nest'][mediaQueryRule]['$nest']['> .tabs-nav-wrap .tabs-nav']['width'] = '100%';
                        styleObj['$nest'][mediaQueryRule]['$nest']['> .tabs-nav-wrap .tabs-nav']['justifyContent'] = 'center';
                    }
                    else {
                        styleObj['$nest'][mediaQueryRule]['$nest']['> .tabs-nav-wrap .tabs-nav']['flexDirection'] = 'column !important';
                        styleObj['$nest'][mediaQueryRule]['$nest']['> .tabs-nav-wrap .tabs-nav']['width'] = 'auto';
                        styleObj['$nest'][mediaQueryRule]['$nest']['> .tabs-nav-wrap .tabs-nav']['justifyContent'] = 'start';
                    }
                }
            }
        }
        return Styles.style(styleObj);
    };
    exports.getTabMediaQueriesStyleClass = getTabMediaQueriesStyleClass;
});
define("@ijstech/tab/tab.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/tab/style/tab.css.ts", "@ijstech/types", "@ijstech/application", "@ijstech/tab/style/tab.css.ts"], function (require, exports, base_3, icon_1, tab_css_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tab = exports.Tabs = void 0;
    const DEFAULT_VALUES = {
        activeTabIndex: 0,
        closable: false,
        draggable: false,
        mode: 'horizontal'
    };
    let Tabs = class Tabs extends base_3.Container {
        constructor(parent, options) {
            super(parent, options);
            this.accumTabIndex = 0;
            this.dragStartHandler = this.dragStartHandler.bind(this);
            this.dragOverHandler = this.dragOverHandler.bind(this);
            this.dropHandler = this.dropHandler.bind(this);
        }
        updateLocale(i18n) {
            for (const tab of this._tabs) {
                tab.updateLocale(i18n);
            }
        }
        get activeTab() {
            return this._tabs[this.activeTabIndex];
        }
        // set activeTab(item: Tab) {
        //   const index = item.index;
        //   if (index < 0 || this.activeTabIndex === index) return;
        //   this.activeTabIndex = item.index;
        // }
        get activeTabIndex() {
            return this._activeTabIndex;
        }
        set activeTabIndex(index) {
            if (index < 0 || this._activeTabIndex === index)
                return;
            const prevTab = this._tabs[this._activeTabIndex];
            if (prevTab) {
                prevTab.classList.remove("active");
                this.contentPanes[this._activeTabIndex].style.display = "none";
            }
            this._activeTabIndex = index;
            this.activeTab?.classList.add("active");
            if (this.contentPanes[index]) {
                this.contentPanes[index].style.display = "";
                this.refreshControls();
            }
        }
        get items() {
            return this._tabs;
        }
        get closable() {
            return this._closable;
        }
        set closable(value) {
            this._closable = value;
            if (value) {
                this.tabsNavElm.classList.add('is-closable');
            }
            else {
                this.tabsNavElm.classList.remove('is-closable');
            }
        }
        get draggable() {
            return this._draggable;
        }
        set draggable(value) {
            if (this._draggable === value)
                return;
            this._draggable = value;
            if (this.draggable) {
                this.tabsNavElm.ondragover = this.dragOverHandler;
                this.tabsNavElm.ondrop = this.dropHandler;
            }
            else {
                this.tabsNavElm.ondragover = null;
                this.tabsNavElm.ondrop = null;
            }
            this.handleTagDrag(this._tabs);
        }
        get mode() {
            const isVertical = this.classList.contains("vertical");
            return isVertical ? "vertical" : "horizontal";
        }
        set mode(type) {
            if (type === 'vertical') {
                this.classList.add("vertical");
            }
            else {
                this.classList.remove("vertical");
            }
        }
        get mediaQueries() {
            return this._mediaQueries;
        }
        set mediaQueries(value) {
            this._mediaQueries = value;
            let style = (0, tab_css_1.getTabMediaQueriesStyleClass)(this._mediaQueries);
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        add(options) {
            const tab = new Tab(this, options);
            if (options?.children) {
                tab.append(options?.children);
            }
            if (this.draggable) {
                this.handleTagDrag([tab]);
            }
            this.appendTab(tab);
            this.activeTabIndex = tab.index;
            return tab;
        }
        delete(tab) {
            const index = this._tabs.findIndex(t => t.id === tab.id);
            const activeIndex = this.activeTabIndex;
            if (index >= 0) {
                this._tabs.splice(index, 1);
                const pane = this.contentPanes[index];
                this.contentPanes.splice(index, 1);
                pane.remove();
                if (activeIndex >= index) {
                    let newActiveIndex = activeIndex > index ? activeIndex - 1 : this._tabs[activeIndex] ? activeIndex : this._tabs.length - 1;
                    this._activeTabIndex = newActiveIndex;
                    if (this.activeTab) {
                        this.activeTab.classList.add("active");
                        this.contentPanes[newActiveIndex].style.display = "";
                    }
                }
            }
            tab.ondragstart = null;
            tab.controls.forEach(c => {
                c.parent = undefined;
                c.remove();
            });
            tab.remove();
        }
        appendTab(tab) {
            this.initTabsNav();
            tab._container = this.tabsContentElm;
            tab.parent = this;
            this._tabs.push(tab);
            if (!tab.id)
                tab.id = `tab-${this.accumTabIndex++}`;
            this.tabsNavElm.appendChild(tab);
            const contentPane = this.createElement('div', this.tabsContentElm);
            tab._contentElm = contentPane;
            contentPane.classList.add("content-pane");
            contentPane.style.display = 'none';
            this.contentPanes.push(contentPane);
            const children = tab.children;
            for (let i = 0; i < children.length; i++) {
                if (children[i].classList.contains('tab-item'))
                    continue;
                if (children[i] instanceof base_3.Control) {
                    children[i].parent = tab;
                }
                // contentPane.appendChild(children[i]);
            }
            ;
        }
        handleTagDrag(tabs) {
            tabs.forEach((tab) => {
                if (this.draggable) {
                    tab.setAttribute('draggable', "true");
                    tab.ondragstart = this.dragStartHandler;
                }
                else {
                    tab.removeAttribute('draggable');
                    tab.ondragstart = null;
                }
            });
        }
        _handleClick(event) {
            if (this._designMode)
                return false;
            return super._handleClick(event, true);
        }
        dragStartHandler(event) {
            if (!(event.target instanceof Tab) || this._designMode)
                return;
            this.curDragTab = event.target;
        }
        dragOverHandler(event) {
            event.preventDefault();
        }
        dropHandler(event) {
            event.preventDefault();
            if (!this.curDragTab || this._designMode)
                return;
            const target = event.target;
            const dropTab = target instanceof Tab ? target : target.closest('i-tab');
            if (dropTab && !this.curDragTab.isSameNode(dropTab)) {
                const curActiveTab = this.activeTab;
                const dragIndex = this.curDragTab.index;
                const dropIndex = dropTab.index;
                const [dragTab] = this._tabs.splice(dragIndex, 1);
                this._tabs.splice(dropIndex, 0, dragTab);
                const [dragContent] = this.contentPanes.splice(dragIndex, 1);
                this.contentPanes.splice(dropIndex, 0, dragContent);
                if (dragIndex > dropIndex) {
                    this.tabsNavElm.insertBefore(this.curDragTab, dropTab);
                }
                else {
                    dropTab.after(this.curDragTab);
                }
                this.activeTabIndex = curActiveTab.index;
                if (typeof this.onChanged === 'function')
                    this.onChanged(this, this.activeTab);
            }
            this.curDragTab = null;
        }
        ;
        refresh() {
            if (this.dock) {
                super.refresh(true);
                const height = this.mode === 'horizontal' ? (this.clientHeight - this.tabsNavElm.clientHeight) : this.clientHeight;
                this.tabsContentElm.style.height = height + 'px';
                this.refreshControls();
            }
        }
        ;
        init() {
            super.init();
            this.initTabsNav();
        }
        initTabsNav() {
            if (!this.tabsNavElm) {
                this.contentPanes = [];
                this._tabs = [];
                const _tabs = [];
                this.childNodes.forEach(node => {
                    if (node instanceof Tab) {
                        _tabs.push(node);
                    }
                    else {
                        node.remove();
                    }
                });
                const tabsNavWrapElm = this.createElement('div', this);
                tabsNavWrapElm.classList.add('tabs-nav-wrap');
                tabsNavWrapElm.addEventListener("wheel", (event) => {
                    if (tabsNavWrapElm.scrollWidth > tabsNavWrapElm.clientWidth) {
                        event.preventDefault();
                        tabsNavWrapElm.scrollLeft += event.deltaY;
                    }
                });
                this.tabsNavElm = this.createElement('div', tabsNavWrapElm);
                this.tabsNavElm.classList.add("tabs-nav");
                this.tabsContentElm = this.createElement('div', this);
                this.tabsContentElm.classList.add("tabs-content");
                this.closable = this.getAttribute("closable", true) || false;
                this.mode = this.getAttribute('mode', true) || "horizontal";
                for (const tab of _tabs) {
                    this.appendTab(tab);
                }
                // const activeTab = this.getAttribute("activeTab", true);
                // if (activeTab) this.activeTab = activeTab;
                this.draggable = this.getAttribute("draggable", true) || false;
                const activeTabIndex = this.getAttribute("activeTabIndex", true);
                if (this._tabs.length)
                    this.activeTabIndex = activeTabIndex || 0;
                this.mediaQueries = this.getAttribute('mediaQueries', true, []);
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Tabs = __decorate([
        (0, base_3.customElements)("i-tabs", {
            icon: 'window-minimize',
            className: 'Tabs',
            group: types_1.GroupType.BASIC,
            props: {
                activeTabIndex: { type: 'number' },
                closable: { type: 'boolean', default: DEFAULT_VALUES.closable },
                draggable: { type: 'boolean', default: DEFAULT_VALUES.draggable },
                mode: { type: 'string', default: DEFAULT_VALUES.mode },
            },
            events: {
                onChanged: [
                    { name: 'target', type: 'Tabs', isControl: true },
                    { name: 'tab', type: 'Tab', isControl: true }
                ],
                onCloseTab: [
                    { name: 'target', type: 'Tabs', isControl: true },
                    { name: 'activeTab', type: 'Tab', isControl: true }
                ],
                onBeforeClose: [
                    { name: 'target', type: 'Tabs', isControl: true },
                    { name: 'activeTab', type: 'Tab', isControl: true }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    activeTabIndex: {
                        type: 'number'
                    },
                    closable: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.closable
                    },
                    draggable: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.draggable
                    },
                    mode: {
                        type: 'string',
                        enum: ['horizontal', 'vertical'],
                        default: DEFAULT_VALUES.mode
                    }
                }
            }
        })
    ], Tabs);
    exports.Tabs = Tabs;
    let Tab = class Tab extends base_3.Container {
        active() {
            this._parent.activeTabIndex = this.index;
        }
        addChildControl(control) {
            if (this._contentElm)
                this._contentElm.appendChild(control);
        }
        removeChildControl(control) {
            if (this._contentElm && this._contentElm.contains(control))
                this._contentElm.removeChild(control);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionElm && this._caption?.startsWith('$'))
                this.captionElm.textContent = i18n.get(this._caption) || '';
        }
        get caption() {
            let value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parent?.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (!this.captionElm)
                return;
            this.captionElm.textContent = this.caption;
        }
        close() {
            this.handleDefaultClose();
        }
        get index() {
            return this._parent.items.findIndex(t => t.id === this.id);
        }
        get icon() {
            if (!this._icon) {
                this._icon = icon_1.Icon.create({
                    width: 16,
                    height: 16
                }, this);
            }
            ;
            return this._icon;
        }
        set icon(elm) {
            if (this._icon)
                this.tabContainer.removeChild(this._icon);
            this._icon = elm;
            if (this._icon)
                this.tabContainer.prepend(this._icon);
        }
        get rightIcon() {
            if (!this._rightIcon) {
                this._rightIcon = icon_1.Icon.create({
                    width: 16,
                    height: 16
                }, this);
                this.rightElm.classList.add("has-icon");
            }
            ;
            return this._rightIcon;
        }
        set rightIcon(elm) {
            if (this._rightIcon && this.rightElm.contains(this._rightIcon))
                this.rightElm.removeChild(this._rightIcon);
            this._rightIcon = elm;
            if (this._rightIcon) {
                this.rightElm.prepend(this._rightIcon);
                this.rightElm.classList.add("has-icon");
            }
            else {
                this.rightElm.classList.remove("has-icon");
            }
        }
        // get innerHTML(): string{
        //   return this._contentElm.innerHTML;
        // }
        // set innerHTML(value: string){
        //   this._contentElm.innerHTML = value;
        // }
        get font() {
            return {
                color: this.captionElm.style.color,
                name: this.captionElm.style.fontFamily,
                size: this.captionElm.style.fontSize,
                bold: this.captionElm.style.fontStyle.indexOf('bold') >= 0,
                style: this.captionElm.style.fontStyle,
                transform: this.captionElm.style.textTransform,
                weight: this.captionElm.style.fontWeight,
                shadow: this.captionElm.style.textShadow
            };
        }
        set font(value) {
            if (this.captionElm) {
                this.captionElm.style.color = value.color || '';
                this.captionElm.style.fontSize = value.size || '';
                this.captionElm.style.fontFamily = value.name || '';
                this.captionElm.style.fontStyle = value.style || '';
                this.captionElm.style.textTransform = value.transform || 'none';
                this.captionElm.style.fontWeight = value.bold ? 'bold' : (`${value.weight}` || '');
                this.captionElm.style.textShadow = value.shadow || 'none';
            }
        }
        _handleClick(event) {
            if (!this._parent || !this.enabled || this._parent.activeTab.isSameNode(this) || this._designMode)
                return false;
            if (this._parent) {
                const oldActiveTab = this._parent.activeTab;
                if (this._parent.activeTab != this)
                    this._parent.activeTabIndex = this.index;
                if (typeof this._parent.onChanged === 'function')
                    this._parent.onChanged(this._parent, this._parent.activeTab, oldActiveTab);
            }
            return super._handleClick(event);
        }
        handleCloseTab(event) {
            if (this._designMode)
                return;
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            if (!this._parent ||
                !this.enabled ||
                (event && !this._parent.closable))
                return;
            if (typeof this._parent.onBeforeClose === 'function') {
                this._parent.onBeforeClose(this._parent, this);
            }
            else {
                this.handleDefaultClose();
            }
        }
        handleDefaultClose() {
            const isActiveChange = this._parent.activeTab.isSameNode(this);
            if (typeof this._parent.onCloseTab === 'function')
                this._parent.onCloseTab(this._parent, this);
            this._parent.delete(this);
            if (isActiveChange && typeof this._parent.onChanged === 'function')
                this._parent.onChanged(this._parent, this._parent.activeTab);
        }
        init() {
            if (!this.captionElm) {
                super.init();
                this.tabContainer = this.createElement('div', this);
                this.tabContainer.classList.add('tab-item');
                this.captionElm = this.createElement('div', this.tabContainer);
                this.caption = this.getAttribute('caption', true) || '';
                const font = this.getAttribute('font', true);
                if (font)
                    this.font = font;
                const icon = this.getAttribute('icon', true);
                if (icon?.name || icon?.image?.url) {
                    icon.height = icon.height || '1rem';
                    icon.width = icon.width || '1rem';
                    this.icon = new icon_1.Icon(undefined, icon);
                }
                ;
                this.rightElm = this.createElement('span', this.tabContainer);
                this.rightElm.classList.add("pnl-right");
                const rightIcon = this.getAttribute('rightIcon', true);
                if (rightIcon?.name || rightIcon?.image?.url) {
                    rightIcon.height = rightIcon.height || '1rem';
                    rightIcon.width = rightIcon.width || '1rem';
                    this.rightIcon = new icon_1.Icon(undefined, rightIcon);
                    this.rightElm.classList.add("has-icon");
                }
                ;
                this._closeBtn = this.createElement('span', this.rightElm);
                this._closeBtn.classList.add("close");
                this._closeBtn.innerHTML = "&times;";
                this._closeBtn.onclick = this.handleCloseTab.bind(this);
            }
        }
        ;
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Tab = __decorate([
        (0, base_3.customElements)('i-tab', {
            icon: 'window-minimize',
            group: types_1.GroupType.BASIC,
            className: 'Tab',
            props: {
                caption: {
                    type: 'string'
                },
                icon: {
                    type: 'object',
                    default: {}
                },
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    caption: { type: 'string' },
                    icon: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string'
                            },
                            fill: {
                                type: 'string',
                                format: 'color'
                            },
                            image: {
                                type: 'object',
                                properties: {
                                    url: {
                                        type: 'string'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        })
    ], Tab);
    exports.Tab = Tab;
});
define("@ijstech/tab", ["require", "exports", "@ijstech/tab/tab.ts"], function (require, exports, tab_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tab = exports.Tabs = void 0;
    Object.defineProperty(exports, "Tabs", { enumerable: true, get: function () { return tab_1.Tabs; } });
    Object.defineProperty(exports, "Tab", { enumerable: true, get: function () { return tab_1.Tab; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/progress/style/progress.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    const loading = Styles.keyframes({
        '0%': {
            left: '-100%'
        },
        '100%': {
            left: '100%'
        }
    });
    Styles.cssRule('i-progress', {
        display: 'block',
        maxWidth: '100%',
        verticalAlign: 'baseline',
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        color: Theme.text.primary,
        position: 'relative',
        $nest: {
            '&.is-loading .i-progress_overlay': {
                transform: 'translateZ(0)',
                animation: `${loading} 3s infinite`
            },
            '.i-progress': {
                boxSizing: 'border-box',
                margin: 0,
                minWidth: 0,
                width: '100%',
                display: 'block'
            },
            '.i-progress--grid': {
                display: 'grid',
                gap: 20,
                gridTemplateColumns: 'auto 1fr 80px',
                alignItems: 'center'
            },
            '.i-progress--exception': {
                $nest: {
                    '> .i-progress_wrapbar > .i-progress_overlay': {
                        backgroundColor: Theme.colors.error.light
                    },
                    '> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item': {
                        backgroundColor: Theme.colors.error.light
                    },
                    '.i-progress_item.i-progress_item-start': {
                        borderColor: Theme.colors.error.light
                    },
                    '.i-progress_item.i-progress_item-end': {}
                }
            },
            '.i-progress--success': {
                $nest: {
                    '> .i-progress_wrapbar > .i-progress_overlay': {
                        backgroundColor: Theme.colors.success.light
                    },
                    '> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item': {
                        backgroundColor: Theme.colors.success.light
                    },
                    '.i-progress_item.i-progress_item-start': {
                        borderColor: Theme.colors.success.light
                    },
                    '.i-progress_item.i-progress_item-end': {}
                }
            },
            '.i-progress--warning': {
                $nest: {
                    '> .i-progress_wrapbar > .i-progress_overlay': {
                        backgroundColor: Theme.colors.warning.light
                    },
                    '> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item': {
                        backgroundColor: Theme.colors.warning.light
                    },
                    '.i-progress_item.i-progress_item-start': {
                        borderColor: Theme.colors.warning.light
                    },
                    '.i-progress_item.i-progress_item-end': {}
                }
            },
            '.i-progress--active': {
                $nest: {
                    '> .i-progress_wrapbar > .i-progress_overlay': {
                        backgroundColor: Theme.colors.primary.light
                    },
                    '> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item': {
                        backgroundColor: Theme.colors.primary.light
                    },
                    '.i-progress_item.i-progress_item-start': {
                        backgroundColor: 'transparent',
                        borderColor: Theme.colors.primary.light
                    }
                }
            },
            '.i-progress_wrapbar': {
                position: 'relative',
                overflow: 'hidden',
                boxSizing: 'border-box',
                minWidth: 0,
                order: 2,
                minHeight: 2,
                borderRadius: 'inherit',
                backgroundColor: Theme.divider,
                $nest: {
                    '&.has-steps': {
                        backgroundColor: 'transparent',
                    },
                    '.i-progress_bar': {
                        boxSizing: 'border-box',
                        width: '100%',
                        height: '100%',
                        position: 'absolute',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '1px',
                        $nest: {
                            '&.has-bg': {
                                backgroundColor: Theme.divider
                            },
                            '.i-progress_bar-item': {
                                flex: 'auto',
                                backgroundColor: Theme.divider
                            }
                        }
                    },
                    '.i-progress_overlay': {
                        position: 'absolute',
                        minWidth: 0,
                        height: '100%'
                    }
                }
            },
            '.i-progress_item': {
                boxSizing: 'border-box',
                margin: '0px -1.2px 0px 0px',
                minWidth: 0,
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                position: 'relative',
                $nest: {
                    '&.i-progress_item-start': {
                        borderWidth: 1,
                        borderStyle: 'solid',
                        borderImage: 'initial',
                        borderRadius: 14,
                        borderColor: Theme.divider,
                        padding: '4px 12px',
                        order: 1
                    },
                    '&.i-progress_item-end': {
                        boxSizing: 'border-box',
                        margin: 0,
                        minWidth: 0,
                        display: 'flex',
                        flexDirection: 'column',
                        cursor: 'default',
                        position: 'relative',
                        order: 3,
                        alignItems: 'flex-start',
                    }
                }
            },
            '&.i-progress--stretch': {
                $nest: {
                    '@media only screen and (max-width: 768px)': {
                        $nest: {
                            '.i-progress_wrapbar': {
                                display: 'none !important'
                            },
                            '.i-progress_item-end': {
                                display: 'none !important'
                            },
                            '.is-mobile': {
                                display: 'inline-block'
                            },
                            '.i-progress--grid': {
                                gridTemplateColumns: 'auto',
                                justifyContent: 'center'
                            }
                        }
                    }
                }
            },
            '.i-progress--circle ~ .i-progress_text': {
                position: 'absolute',
                top: '50%',
                left: 0,
                width: '100%',
                textAlign: 'center',
                transform: 'translateY(-50%)'
            },
            '.i-progress--line ~ .i-progress_text': {
                display: 'inline-block',
                position: 'absolute',
                left: '50%',
                transform: 'translateX(-50%)'
            },
            '.i-progress--line': {
                borderRadius: 'inherit'
            }
        }
    });
});
define("@ijstech/progress/progress.ts", ["require", "exports", "@ijstech/base", "@ijstech/style", "@ijstech/types", "@ijstech/progress/style/progress.css.ts"], function (require, exports, base_1, Styles, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Progress = void 0;
    const Theme = Styles.Theme.ThemeVars;
    const defaultVals = {
        percent: 0,
        height: 20,
        loading: false,
        steps: 1,
        type: 'line',
        strokeWidth: 2
    };
    let Progress = class Progress extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                ...defaultVals
            });
            if (options?.onRenderStart)
                this.onRenderStart = options.onRenderStart;
            if (options?.onRenderEnd)
                this.onRenderEnd = options.onRenderEnd;
        }
        get percent() {
            return this._percent;
        }
        set percent(value) {
            this._percent = +value < 0 ? 0 : +value > 100 ? 100 : +value;
            const overlayElm = this.querySelector('.i-progress_overlay');
            if (overlayElm) {
                overlayElm.style.width = `${this._percent}%`;
                overlayElm.style.backgroundColor = this.stroke;
            }
            if (this._percent > 0 && this._percent < 100)
                this._wrapperElm.classList.add('i-progress--active');
            else if (this._percent === 100)
                this._wrapperElm.classList.add('i-progress--success');
            if (typeof this.format === 'function') {
                if (!this._textElm) {
                    this._textElm = this.createElement('span', this);
                    this._textElm.classList.add('i-progress_text');
                    this._textElm.style.fontSize = this.progressTextSize + 'px';
                    this._textElm.style.color = this.strokeColor;
                }
                this._textElm.innerHTML = this.format(this._percent);
            }
            if (this.type === 'circle') {
                this.updateCircleInner();
            }
        }
        get strokeColor() {
            return this._strokeColor || Theme.colors.primary.main;
        }
        set strokeColor(value) {
            this._strokeColor = value;
            if (this.type === 'circle') {
                this.renderCircleInner();
            }
            else if (this.type === 'line') {
                const overlayElm = this.querySelector('.i-progress_overlay');
                if (overlayElm)
                    overlayElm.style.backgroundColor = this.stroke;
            }
        }
        get loading() {
            return this._loading;
        }
        set loading(value) {
            this._loading = value;
            if (value)
                this.classList.add('is-loading');
            else
                this.classList.remove('is-loading');
        }
        get steps() {
            return this._steps;
        }
        set steps(value) {
            this._steps = +value;
            if (this.type === 'circle')
                return;
            const wrapbarElm = this.querySelector('.i-progress_bar');
            const overlayElm = this.querySelector('.i-progress_overlay');
            const wrapperElm = this.querySelector('.i-progress_wrapbar');
            if (wrapperElm)
                wrapperElm.classList.toggle('has-steps', this._steps > 1);
            wrapbarElm.innerHTML = '';
            if (this._steps > 1) {
                const unitStep = 100 / this._steps;
                const percentStep = Math.ceil(this.percent / unitStep);
                const remainder = this.percent % unitStep;
                const initialH = Math.max(1, Math.floor(this.strokeWidth / 2));
                for (let i = 0; i < this._steps; i++) {
                    const barItem = this.createElement('div');
                    barItem.style.width = unitStep + '%';
                    barItem.style.height = `${i + initialH}px`;
                    if (i === percentStep - 1 && remainder !== 0) {
                        const childElm = this.createElement('div');
                        childElm.classList.add('i-progress_bar-item');
                        childElm.style.width = ((remainder * 100) / unitStep) + '%';
                        childElm.style.height = `${i + initialH}px`;
                        childElm.style.backgroundColor = this.stroke;
                        barItem.appendChild(childElm);
                    }
                    else if (i < percentStep) {
                        barItem.classList.add('i-progress_bar-item');
                        barItem.style.backgroundColor = this.stroke;
                    }
                    wrapbarElm.appendChild(barItem);
                }
                wrapbarElm.classList.remove('has-bg');
                overlayElm && (overlayElm.style.display = 'none');
            }
            else {
                wrapbarElm.classList.add('has-bg');
                overlayElm && (overlayElm.style.display = 'block');
            }
        }
        get type() {
            return this._type;
        }
        set type(value) {
            this._type = value;
            if (value === 'circle') {
                this.renderCircle();
            }
            else {
                this.renderLine();
            }
        }
        get strokeWidth() {
            return this._strokeWidth || defaultVals.strokeWidth;
        }
        set strokeWidth(value) {
            this._strokeWidth = value || defaultVals.strokeWidth;
            const overlayElm = this.querySelector('.i-progress_wrapbar');
            if (overlayElm)
                overlayElm.style.height = `${this._strokeWidth}px`;
        }
        get font() {
            return {
                color: this._textElm.style.color,
                name: this._textElm.style.fontFamily,
                size: this._textElm.style.fontSize,
                bold: this._textElm.style.fontStyle.indexOf('bold') >= 0,
                style: this._textElm.style.fontStyle,
                transform: this._textElm.style.textTransform,
                weight: this._textElm.style.fontWeight,
                shadow: this._textElm.style.textShadow
            };
        }
        set font(value) {
            if (this._textElm) {
                this._textElm.style.color = value.color || '';
                this._textElm.style.fontSize = value.size || '';
                this._textElm.style.fontWeight = value.bold ? 'bold' : '';
                this._textElm.style.fontFamily = value.name || '';
                this._textElm.style.fontStyle = value.style || '';
                this._textElm.style.textTransform = value.transform || 'none';
                this._textElm.style.fontWeight = value.bold ? 'bold' : (`${value.weight}` || '');
                this._textElm.style.textShadow = value.shadow || 'none';
            }
        }
        get relativeStrokeWidth() {
            return (this.strokeWidth / +this.width * 100).toFixed(1);
        }
        get radius() {
            if (this.type === 'circle') {
                const value = 50 - (parseFloat(this.relativeStrokeWidth) / 2);
                return parseInt(value.toFixed(1), 10);
            }
            else {
                return 0;
            }
        }
        get trackPath() {
            const radius = this.radius;
            return `
          M 50 50
          m 0 -${radius}
          a ${radius} ${radius} 0 1 1 0 ${radius * 2}
          a ${radius} ${radius} 0 1 1 0 -${radius * 2}
          `;
        }
        get perimeter() {
            return 2 * Math.PI * this.radius;
        }
        get rate() {
            return 1;
        }
        get strokeDashoffset() {
            const offset = -1 * this.perimeter * (1 - this.rate) / 2;
            return `${offset}px`;
        }
        get trailPathStyle() {
            const strokeDasharray = `${this.perimeter * this.rate}px, ${this.perimeter}px`;
            const strokeDashoffset = this.strokeDashoffset;
            return `stroke-dasharray: ${strokeDasharray}; stroke-dashoffset: ${strokeDashoffset};`;
        }
        get circlePathStyle() {
            const strokeDasharray = `${this.perimeter * this.rate * (this.percent / 100)}px, ${this.perimeter}px`;
            const strokeDashoffset = this.strokeDashoffset;
            const transition = 'stroke-dasharray 0.6s ease 0s, stroke 0.6s ease';
            return `stroke-dasharray: ${strokeDasharray}; stroke-dashoffset: ${strokeDashoffset}; transition: ${transition};`;
        }
        get stroke() {
            let ret = this.strokeColor;
            if (this.percent === 100)
                ret = Theme.colors.success.main;
            return ret;
        }
        get trackColor() {
            return Theme.divider;
        }
        get progressTextSize() {
            return this.type === 'line'
                ? 12 + this.strokeWidth * 0.4
                : +this.width * 0.111111 + 2;
        }
        renderLine() {
            this.height = 'auto';
            this._wrapperElm.innerHTML = '';
            this._wrapperElm.classList.add('i-progress--line');
            this._barElm = this.createElement('div', this._wrapperElm);
            this._barElm.classList.add('i-progress_wrapbar');
            this._barElm.style.gridArea = 'bar';
            this._barElm.innerHTML = `<div class="i-progress_bar"></div><div class="i-progress_overlay" style="background-color:${this.stroke}"></div>`;
        }
        renderCircle() {
            this._wrapperElm.classList.add('i-progress--circle');
            if (this.width)
                this.height = this.width;
            this.renderCircleInner();
        }
        renderCircleInner() {
            const templateHtml = `<svg viewBox="0 0 100 100">
            <path class="i-progress-circle__track"
            d="${this.trackPath}"
            stroke="${this.trackColor}"
            stroke-width="${this.relativeStrokeWidth}"
            fill="none"
            style="${this.trailPathStyle}"></path>
            <path
            class="i-progress-circle__path"
            d="${this.trackPath}"
            stroke="${this.stroke}"
            fill="none"
            stroke-linecap="round"
            stroke-width="${this.percent ? this.relativeStrokeWidth : 0}"
            style="${this.circlePathStyle}"></path>
        </svg>`;
            this._wrapperElm.innerHTML = '';
            this._wrapperElm.innerHTML = templateHtml;
        }
        updateCircleInner() {
            const svgPath = this._wrapperElm.querySelector('.i-progress-circle__path');
            if (svgPath) {
                svgPath.style.strokeDasharray = `${this.perimeter * this.rate * (this.percent / 100)}px, ${this.perimeter}px`;
                svgPath.setAttribute("stroke-width", `${this.percent ? this.relativeStrokeWidth : 0}`);
            }
        }
        init() {
            if (!this.initialized) {
                super.init();
                if (this.options?.onRenderStart)
                    this.onRenderStart = this.options.onRenderStart;
                if (this.options?.onRenderEnd)
                    this.onRenderEnd = this.options.onRenderEnd;
                this.loading = this.getAttribute('loading', true);
                this._strokeColor = this.getAttribute('strokeColor', true);
                this._wrapperElm = this.createElement('div', this);
                this._wrapperElm.classList.add('i-progress');
                this.type = this.getAttribute('type', true);
                this.percent = this.getAttribute('percent', true);
                this.strokeWidth = this.getAttribute('strokeWidth', true);
                if (this.type === 'line') {
                    this.steps = this.getAttribute('steps', true);
                    if (typeof this.onRenderStart === 'function') {
                        this._wrapperElm.classList.add('i-progress--grid');
                        this._startElm = this.createElement('div', this._wrapperElm);
                        this._startElm.classList.add('i-progress_item', 'i-progress_item-start');
                        this._endElm.style.gridArea = 'start';
                        this.onRenderStart(this._startElm);
                    }
                    if (typeof this.onRenderEnd === 'function') {
                        this._wrapperElm.classList.add('i-progress--grid');
                        this._endElm = this.createElement('div', this._wrapperElm);
                        this._endElm.classList.add('i-progress_item', 'i-progress_item-end');
                        this._endElm.style.gridArea = 'end';
                        this.onRenderEnd(this._endElm);
                    }
                }
                if (this.type === 'circle')
                    this.renderCircleInner();
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Progress = __decorate([
        (0, base_1.customElements)('i-progress', {
            icon: 'spinner',
            group: types_1.GroupType.BASIC,
            className: 'Progress',
            props: {
                percent: {
                    type: 'number',
                    default: defaultVals.percent
                },
                strokeWidth: {
                    type: 'number',
                    default: defaultVals.strokeWidth
                },
                strokeColor: {
                    type: 'string',
                    default: ''
                },
                loading: {
                    type: 'boolean',
                    default: defaultVals.loading
                },
                steps: {
                    type: 'number',
                    default: defaultVals.steps
                },
                type: {
                    type: 'string',
                    default: defaultVals.type
                }
            },
            events: {
                format: [
                    { name: 'percent', type: 'number' }
                ],
                onRenderStart: [
                    { name: 'target', type: 'Progress', isControl: true }
                ],
                onRenderEnd: [
                    { name: 'target', type: 'Progress', isControl: true }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['line', 'circle'],
                        default: defaultVals.type
                    },
                    percent: {
                        type: 'number',
                        default: defaultVals.percent
                    },
                    strokeWidth: {
                        type: 'number',
                        default: defaultVals.strokeWidth
                    },
                    strokeColor: {
                        type: 'string',
                        format: 'color'
                    },
                    loading: {
                        type: 'boolean',
                        default: defaultVals.loading
                    },
                    steps: {
                        type: 'number',
                        default: defaultVals.steps
                    }
                }
            }
        })
    ], Progress);
    exports.Progress = Progress;
});
define("@ijstech/progress", ["require", "exports", "@ijstech/progress/progress.ts"], function (require, exports, progress_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Progress = void 0;
    Object.defineProperty(exports, "Progress", { enumerable: true, get: function () { return progress_1.Progress; } });
});
define("@ijstech/jsonUI/styles/jsonUI.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonUITabStyle = exports.jsonUIComboboxStyle = exports.jsonUICheckboxStyle = void 0;
    const Theme = Styles.Theme.ThemeVars;
    exports.jsonUICheckboxStyle = Styles.style({
        display: 'flex',
        alignItems: 'center',
        gap: 8,
        $nest: {
            'i-checkbox': {
                display: 'flex',
                height: 'auto !important'
            }
        }
    });
    exports.jsonUIComboboxStyle = Styles.style({
        $nest: {
            '.selection': {
                border: `1px solid ${Theme.divider}`
            },
            '.selection input': {
                paddingInline: 0
            }
        }
    });
    exports.jsonUITabStyle = Styles.style({
        display: 'block',
        $nest: {
            '.tabs-nav': {
                borderBottom: `none`,
                borderRight: `1px solid #606770`
            },
            'i-tab': {
                color: '#606770',
                background: "none",
                margin: '4px',
                border: `none`,
                borderRadius: `5px`,
                $nest: {
                    '&:not(.disabled):hover': {
                        color: '#606770'
                    }
                }
            },
            'i-tab:not(.disabled).active': {
                backgroundColor: '#c2c2c2',
                color: '#000000'
            }
        }
    });
});
define("@ijstech/jsonUI", ["require", "exports", "@ijstech/checkbox", "@ijstech/button", "@ijstech/layout", "@ijstech/tab", "@ijstech/input", "@ijstech/label", "@ijstech/datepicker", "@ijstech/combo-box", "@ijstech/icon", "@ijstech/upload", "@ijstech/style", "@ijstech/jsonUI/styles/jsonUI.css.ts", "@ijstech/moment"], function (require, exports, checkbox_1, button_1, layout_1, tab_1, input_1, label_1, datepicker_1, combo_box_1, icon_1, upload_1, style_1, jsonUI_css_1, moment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderUI = exports.DataSchemaValidator = void 0;
    const primitiveConstructors = {
        String: String,
        Boolean: Boolean,
        Number: Number,
        Object: Object,
        Array: Array,
        Date: Date
    };
    const checkPropertyChange = (value, schema, property) => {
        return validate(value, schema, { changing: property || "property" });
    };
    const validate = (instance, schema, options) => {
        if (!options)
            options = {};
        var _changing = options.changing;
        function getType(schema) {
            return schema.type;
        }
        var errors = [];
        // validate a value against a property definition
        function checkProp(value, schema, path, scope, i, isNonObjArrayItem) {
            if (isNonObjArrayItem && typeof i === 'number') {
                // array's item is not object
                if (typeof (value) === "object") {
                    value = value[Object.keys(value)[0]];
                    // if the value is null, it will be NaN. NaN can't be checked
                    if (isNaN(value) && (schema.type === "number" || schema.type === "integer"))
                        value = "";
                }
                scope = scope + '_' + (i + 1).toString();
            }
            else {
                // array's item is object
                const parsedPath = path.split('.');
                let parsedScope = scope.split('/');
                let parentProp = "";
                if (parsedScope.length > 1) {
                    parsedScope = parsedScope.splice(0, parsedScope.length - 2);
                    parentProp = parsedScope[parsedScope.length - 1].split('_')[0];
                }
                let idxOfArray = -1;
                parsedPath.forEach((value) => {
                    if (value.includes(parentProp)) {
                        let matches = value.match(/\[(.*?)\]/);
                        if (matches)
                            idxOfArray = parseInt(matches[1]) + 1;
                    }
                });
                if (idxOfArray > 0 && getType(schema) != 'object') {
                    scope = scope + '_' + idxOfArray;
                }
            }
            var l;
            path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
            function addError(message, scope, overwritePath) {
                errors.push({ property: overwritePath || path, scope: scope, message: message });
            }
            if ((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))) {
                if (typeof schema == 'function') {
                    if (!(value instanceof schema)) {
                        addError("is not an instance of the class/constructor " + schema.name, scope);
                    }
                }
                else if (schema) {
                    addError("Invalid schema/property definition " + schema, scope);
                }
                return null;
            }
            if (_changing && schema.readOnly) {
                addError("is a readonly field, it can not be changed", scope);
            }
            if (schema['extends']) { // if it extends another schema, it must pass that schema as well
                checkProp(value, schema['extends'], path, scope, i);
            }
            // validate a value against a type definition
            function checkType(type, value, scope) {
                if (type) {
                    if (type != 'any' &&
                        (type == 'null' ? value !== null : typeof value != type) &&
                        !(value instanceof Array && type == 'array') &&
                        // !(value instanceof Date && type == 'date') &&
                        typeof type == 'string' &&
                        !(type == 'integer' && value % 1 === 0)) {
                        return [{
                                property: path,
                                scope: scope,
                                message: value + " - " + (typeof value) + " value found, but a " + type + " is required"
                            }];
                    }
                    if (type instanceof Array) {
                        let unionErrors = [];
                        for (var j = 0; j < type.length; j++) { // a union type
                            if (!(unionErrors = checkType(type[j], value, scope)).length) {
                                break;
                            }
                        }
                        if (unionErrors.length) {
                            return unionErrors;
                        }
                    }
                    else if (typeof type == 'object') {
                        var priorErrors = errors;
                        errors = [];
                        checkProp(value, type, path, scope);
                        var theseErrors = errors;
                        errors = priorErrors;
                        return theseErrors;
                    }
                }
                return [];
            }
            if (value === undefined || value === '' || (value instanceof Array && !value.length)) {
                if (schema.required && typeof schema.required === 'boolean') {
                    // addError("is missing and it is required", scope + '_' + idxOfArray);
                    addError("is missing and it is required", scope);
                }
            }
            else {
                // Check if required is an array and type is object
                if (getType(schema) === 'object' && schema.required instanceof Array) {
                    for (let requiredField of schema.required) {
                        if (value[requiredField] === undefined || value[requiredField] === '' || (value[requiredField] instanceof Array && !value[requiredField].length)) {
                            addError(`is missing and it is required`, scope + "/properties/" + requiredField, requiredField);
                        }
                    }
                }
                errors = errors.concat(checkType(getType(schema), value, scope));
                if (schema.disallow && !checkType(schema.disallow, value, scope).length) {
                    addError(" disallowed value was matched", scope);
                }
                if (value !== null) {
                    if (value instanceof Array) {
                        if (schema.items) {
                            var itemsIsArray = schema.items instanceof Array;
                            var propDef = schema.items;
                            for (i = 0, l = value.length; i < l; i += 1) {
                                if (itemsIsArray)
                                    propDef = schema.items[i];
                                if (options.coerce)
                                    value[i] = options.coerce(value[i], propDef);
                                if (schema.items.type == 'object') {
                                    var errors2 = checkProp(value[i], propDef, path, scope, i);
                                    if (errors2)
                                        errors.concat(errors2);
                                }
                            }
                        }
                        if (schema.minItems && value.length < schema.minItems) {
                            addError("There must be a minimum of " + schema.minItems + " in the array", scope);
                        }
                        if (schema.maxItems && value.length > schema.maxItems) {
                            addError("There must be a maximum of " + schema.maxItems + " in the array", scope);
                        }
                    }
                    else if (schema.properties || schema.additionalProperties) {
                        errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties, scope));
                    }
                    if (schema.items && schema.items.type != "object") {
                        // schema has items and Non-obj array
                        for (let i = 0; i < value.length; i++) {
                            checkProp(value[i], schema.items, path, scope, i, true);
                        }
                    }
                    if (schema.pattern && typeof value == 'string' && !value.match(schema.pattern)) {
                        addError("does not match the regex pattern " + schema.pattern, scope);
                    }
                    if (schema.maxLength && typeof value == 'string' && value.length > schema.maxLength) {
                        addError("may only be " + schema.maxLength + " characters long", scope);
                    }
                    if (schema.minLength && typeof value == 'string' && value.length < schema.minLength) {
                        addError("must be at least " + schema.minLength + " characters long", scope);
                    }
                    if (typeof schema.minimum !== 'undefined' && typeof value == typeof schema.minimum &&
                        schema.minimum > value) {
                        addError("must have a minimum value of " + schema.minimum, scope);
                    }
                    if (typeof schema.maximum !== 'undefined' && typeof value == typeof schema.maximum &&
                        schema.maximum < value) {
                        addError("must have a maximum value of " + schema.maximum, scope);
                    }
                    if (schema['enum']) {
                        var enumer = schema['enum'];
                        l = enumer.length;
                        var found;
                        for (var j = 0; j < l; j++) {
                            if (enumer[j] === value) {
                                found = 1;
                                break;
                            }
                        }
                        if (!found) {
                            addError("does not have a value in the enumeration " + enumer.join(", "), scope);
                        }
                    }
                    if (typeof schema.maxDecimal == 'number' &&
                        (value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))) {
                        addError("may only have " + schema.maxDecimal + " digits of decimal places", scope);
                    }
                    // Todo: Additional validations
                    if (value !== '') {
                        if (schema.format === 'wallet-address') {
                            const regex = new RegExp('^((0x[a-fA-F0-9]{40})|([13][a-km-zA-HJ-NP-Z1-9]{25,34})|(X[1-9A-HJ-NP-Za-km-z]{33})|(4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}))$');
                            if (!regex.test(value))
                                addError("is not a valid wallet address", scope);
                        }
                        else if (schema.format === 'cid') {
                            const regex = new RegExp('^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$');
                            if (!regex.test(value))
                                addError("is not a valid cid", scope);
                        }
                        else if (schema.format === 'cid-v0') {
                            const regex = new RegExp('^(Qm[1-9A-HJ-NP-Za-km-z]{44,})$');
                            if (!regex.test(value))
                                addError("is not a valid version 0 cid", scope);
                        }
                        else if (schema.format === 'cid-v1') {
                            const regex = new RegExp('^(b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$');
                            if (!regex.test(value))
                                addError("is not a valid version 1 cid", scope);
                        }
                        else if (schema.format === 'uuid') {
                            const regex = new RegExp('^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$');
                            if (!regex.test(value))
                                addError('is not a valid uuid', scope);
                        }
                        else if (schema.format === 'url') {
                            const regex = new RegExp('^(https?|ftp)://[^\s/$.?#].[^\s]*$');
                            if (!regex.test(value))
                                addError('is not a valid URL', scope);
                        }
                    }
                }
            }
            return null;
        }
        // validate an object against a schema
        function checkObj(instance, objTypeDef, path, additionalProp, scope) {
            if (typeof objTypeDef == 'object') {
                if (typeof instance != 'object' || instance instanceof Array) {
                    errors.push({ property: path, scope: scope, message: "an object is required" });
                }
                for (var i in objTypeDef) {
                    if (objTypeDef.hasOwnProperty(i) && i != '__proto__' && i != 'constructor') {
                        var value = instance.hasOwnProperty(i) ? instance[i] : undefined;
                        // skip _not_ specified properties
                        if (value === undefined && options.existingOnly)
                            continue;
                        var propDef = objTypeDef[i];
                        // set default
                        if (value === undefined && propDef["default"]) {
                            value = instance[i] = propDef["default"];
                        }
                        if (options.coerce && i in instance) {
                            value = instance[i] = options.coerce(value, propDef);
                        }
                        checkProp(value, propDef, path, scope + "/properties/" + i, i);
                    }
                }
            }
            for (i in instance) {
                if (instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp === false) {
                    if (options.filter) {
                        delete instance[i];
                        continue;
                    }
                    else {
                        errors.push({
                            property: path, message: "The property " + i +
                                " is not defined in the schema and the schema does not allow additional properties",
                            scope: scope
                        });
                    }
                }
                var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
                if (requires && !(requires in instance)) {
                    errors.push({
                        property: path,
                        scope: scope,
                        message: "the presence of the property " + i + " requires that " + requires + " also be present"
                    });
                }
                value = instance[i];
                if (additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))) {
                    if (options.coerce) {
                        value = instance[i] = options.coerce(value, additionalProp);
                    }
                    checkProp(value, additionalProp, path, scope + "/properties/" + i, i);
                }
                if (!_changing && value && value.$schema) {
                    const errors2 = checkProp(value, value.$schema, path, scope + "/properties/" + i, i);
                    if (errors2)
                        errors = errors.concat(errors2);
                }
            }
            return errors;
        }
        const root = "#";
        if (schema) {
            checkProp(instance, schema, '', root, _changing || '');
        }
        if (!_changing && instance && instance.$schema) {
            checkProp(instance, instance.$schema, '', root, '');
        }
        return { valid: !errors.length, errors: errors };
    };
    const mustBeValid = (result) => {
        if (!result.valid) {
            throw new TypeError(result.errors.map(function (error) {
                return "for property " + error.property + ': ' + error.message;
            }).join(", \n"));
        }
    };
    exports.DataSchemaValidator = {
        checkPropertyChange,
        mustBeValid,
        validate
    };
    function renderUI(target, options, confirmCallback, valueChangedCallback) {
        const defaultDateFormat = options.dateFormat || 'DD/MM/YYYY';
        const defaultTimeFormat = options.timeFormat || 'HH:mm:ss';
        const defaultDateTimeFormat = options.dateTimeFormat || 'DD/MM/YYYY HH:mm:ss';
        const controls = {};
        const descriptions = {};
        const errorMsgs = {};
        const flatRules = [];
        const validateOnValueChanged = async (idxScope) => {
            const data = await getData(options.jsonSchema);
            const validationResult = validate(data, options.jsonSchema, { changing: false });
            let showErrMsg = false;
            let errMsg = "";
            if (validationResult?.valid == false) {
                for (let idx = 0; idx < validationResult.errors.length; idx++) {
                    if (validationResult.errors[idx].scope == idxScope) {
                        showErrMsg = true;
                        errMsg = validationResult.errors[idx].message;
                    }
                }
            }
            if (showErrMsg == true) {
                if (descriptions.hasOwnProperty(idxScope))
                    descriptions[idxScope].visible = false;
                if (errorMsgs[idxScope]) {
                    errorMsgs[idxScope].caption = errMsg;
                    errorMsgs[idxScope].visible = true;
                }
            }
            else {
                if (descriptions.hasOwnProperty(idxScope))
                    descriptions[idxScope].visible = true;
                if (errorMsgs[idxScope]) {
                    errorMsgs[idxScope].caption = "";
                    errorMsgs[idxScope].visible = false;
                }
            }
            valueChangedCallback && valueChangedCallback(data, errMsg);
        };
        // No UI Schema
        const renderForm = (schema, scope = "#", isArray = false, idx, schemaOptions) => {
            if (!schema)
                return undefined;
            const currentField = scope.substr(scope.lastIndexOf('/') + 1);
            const labelName = schema.title || (scope != '#/' ? convertFieldNameToLabel(currentField) : '');
            const columnWidth = options.columnWidth ? options.columnWidth : '100px';
            const idxScope = idx !== undefined ? `${scope}_${idx}` : scope;
            const tooltip = schema.tooltip;
            let isRequired = false;
            let arrRequired = [];
            if (typeof schema.required === 'boolean') {
                isRequired = schema.required;
            }
            else if (typeof schema.required === 'object') {
                arrRequired = schema.required;
            }
            // Combo Box
            if ((schema.enum && schema.enum.length > 0) || (schema.oneOf && schema.oneOf.length > 0)) {
                const items = [];
                if (schema.oneOf && schema.oneOf.length > 0) {
                    for (const item of schema.oneOf) {
                        items.push({
                            label: item.title,
                            value: item.const
                        });
                    }
                }
                else if (schema.enum && schema.enum.length > 0) {
                    for (const item of schema.enum) {
                        items.push({ label: item, value: item });
                    }
                }
                const groupPnl = new layout_1.Panel();
                const hStack = new layout_1.HStack(groupPnl, { alignItems: 'center', gap: 2 });
                if (!isArray) {
                    new label_1.Label(hStack, { caption: labelName });
                    if (isRequired) {
                        new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                    }
                    if (tooltip) {
                        new icon_1.Icon(hStack, {
                            width: '1rem',
                            height: '1rem',
                            name: 'info-circle',
                            margin: { left: 2 },
                            tooltip: { content: tooltip, placement: 'bottom' }
                        });
                    }
                }
                const controlPnl = new layout_1.Panel(groupPnl);
                let combobox = new combo_box_1.ComboBox(controlPnl, {
                    width: '100%',
                    items: items,
                    icon: { name: 'caret-down' },
                    readOnly: schema.readOnly
                });
                combobox.id = idxScope;
                combobox.classList.add(jsonUI_css_1.jsonUIComboboxStyle);
                combobox.onChanged = () => validateOnValueChanged(idxScope);
                controls[idxScope] = combobox;
                if (isArray) {
                    controls[idxScope].setAttribute('role', 'column');
                    controls[idxScope].setAttribute('field', currentField);
                }
                if (schema.description)
                    descriptions[idxScope] = new label_1.Label(groupPnl, { caption: schema.description });
                errorMsgs[idxScope] = new label_1.Label(groupPnl, { visible: false, font: { color: '#ff0000' } });
                return groupPnl;
            }
            else if (schema.type === 'string') {
                // Date Picker
                if (['date', 'time', 'date-time'].indexOf(schema.format || '') >= 0) {
                    let datePickerType = schema.format;
                    if (schema.format === 'date-time')
                        datePickerType = 'dateTime';
                    const groupPnl = new layout_1.Panel();
                    const hStack = new layout_1.HStack(groupPnl, { alignItems: 'center', gap: 2 });
                    if (!isArray) {
                        new label_1.Label(hStack, { caption: labelName });
                        if (isRequired) {
                            new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                        }
                        if (tooltip) {
                            new icon_1.Icon(hStack, {
                                width: '1rem',
                                height: '1rem',
                                name: 'info-circle',
                                margin: { left: 2 },
                                tooltip: { content: tooltip, placement: 'bottom' }
                            });
                        }
                    }
                    const controlPnl = new layout_1.Panel(groupPnl);
                    let dateTimeFormat;
                    if (schema.format === 'date') {
                        dateTimeFormat = defaultDateFormat;
                    }
                    else if (schema.format === 'date-time') {
                        dateTimeFormat = defaultDateTimeFormat;
                    }
                    else if (schema.format === 'time') {
                        dateTimeFormat = defaultTimeFormat;
                    }
                    const datePicker = new datepicker_1.Datepicker(controlPnl, {
                        width: columnWidth,
                        type: datePickerType,
                        dateTimeFormat: dateTimeFormat,
                        readOnly: schema.readOnly
                    });
                    datePicker.id = idxScope;
                    datePicker.onChanged = () => validateOnValueChanged(idxScope);
                    controls[idxScope] = datePicker;
                    if (isArray) {
                        controls[idxScope].setAttribute('role', 'column');
                        controls[idxScope].setAttribute('field', currentField);
                        controls[idxScope].setAttribute('format', schema.format || '');
                    }
                    if (schema.description)
                        descriptions[idxScope] = new label_1.Label(groupPnl, { caption: schema.description });
                    errorMsgs[idxScope] = new label_1.Label(groupPnl, { visible: false, font: { color: '#ff0000' } });
                    return groupPnl;
                }
                // Uploader
                else if (schema.format === 'data-url') {
                    const groupPnl = new layout_1.Panel();
                    const hStack = new layout_1.HStack(groupPnl, { alignItems: 'center', gap: 2 });
                    if (!isArray) {
                        new label_1.Label(hStack, { caption: labelName });
                        if (isRequired) {
                            new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                        }
                        if (tooltip) {
                            new icon_1.Icon(hStack, {
                                width: '1rem',
                                height: '1rem',
                                name: 'info-circle',
                                margin: { left: 2 },
                                tooltip: { content: tooltip, placement: 'bottom' }
                            });
                        }
                    }
                    const controlPnl = new layout_1.Panel(groupPnl);
                    let upload = new upload_1.Upload(controlPnl, {
                        readOnly: schema.readOnly
                    });
                    upload.id = idxScope;
                    upload.onChanged = () => validateOnValueChanged(idxScope);
                    controls[idxScope] = upload;
                    if (isArray) {
                        controls[idxScope].setAttribute('role', 'column');
                        controls[idxScope].setAttribute('field', currentField);
                        controls[idxScope].setAttribute('format', schema.format);
                    }
                    return groupPnl;
                }
                // Input
                else {
                    const groupPnl = new layout_1.Panel();
                    const hStack = new layout_1.HStack(groupPnl, { alignItems: 'center', gap: 2 });
                    if (!isArray) {
                        new label_1.Label(hStack, { caption: labelName });
                        if (isRequired) {
                            new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                        }
                        if (tooltip) {
                            new icon_1.Icon(hStack, {
                                width: '1rem',
                                height: '1rem',
                                name: 'info-circle',
                                margin: { left: 2 },
                                tooltip: { content: tooltip, placement: 'bottom' }
                            });
                        }
                    }
                    const controlPnl = new layout_1.Panel(groupPnl);
                    let inputType = 'text';
                    if (schema.format === 'color')
                        inputType = 'color';
                    else if (schema.format === 'multi')
                        inputType = 'textarea';
                    let input = new input_1.Input(controlPnl, {
                        width: columnWidth,
                        inputType,
                        readOnly: schema.readOnly
                    });
                    input.id = idxScope;
                    input.onBlur = () => validateOnValueChanged(idxScope);
                    controls[idxScope] = input;
                    if (isArray) {
                        controls[idxScope].setAttribute('role', 'column');
                        controls[idxScope].setAttribute('field', currentField);
                    }
                    if (schema.description)
                        descriptions[idxScope] = new label_1.Label(groupPnl, { caption: schema.description });
                    errorMsgs[idxScope] = new label_1.Label(groupPnl, { visible: false, font: { color: '#ff0000' } });
                    return groupPnl;
                }
            }
            // Number Input
            else if (['integer', 'number'].indexOf(schema.type?.toString() || '') >= 0) {
                const groupPnl = new layout_1.Panel();
                const hStack = new layout_1.HStack(groupPnl, { alignItems: 'center', gap: 2 });
                if (!isArray) {
                    new label_1.Label(hStack, { caption: labelName });
                    if (isRequired) {
                        new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                    }
                    if (tooltip) {
                        new icon_1.Icon(hStack, {
                            width: '1rem',
                            height: '1rem',
                            name: 'info-circle',
                            margin: { left: 2 },
                            tooltip: { content: tooltip, placement: 'bottom' }
                        });
                    }
                }
                const controlPnl = new layout_1.Panel(groupPnl);
                let inputType = 'number';
                if (schema.type === 'integer')
                    inputType = 'integer';
                let input = new input_1.Input(controlPnl, {
                    width: columnWidth,
                    inputType,
                    readOnly: schema.readOnly
                });
                input.id = idxScope;
                input.onBlur = () => validateOnValueChanged(idxScope);
                controls[idxScope] = input;
                if (isArray) {
                    controls[idxScope].setAttribute('role', 'column');
                    controls[idxScope].setAttribute('field', currentField);
                    controls[idxScope].setAttribute('format', inputType);
                }
                if (schema.description)
                    descriptions[idxScope] = new label_1.Label(groupPnl, { caption: schema.description });
                errorMsgs[idxScope] = new label_1.Label(groupPnl, { visible: false, font: { color: '#ff0000' } });
                return groupPnl;
            }
            // Checkbox
            else if (schema.type === 'boolean') {
                const groupPnl = new layout_1.Panel();
                groupPnl.classList.add(jsonUI_css_1.jsonUICheckboxStyle);
                const hStack = new layout_1.HStack(groupPnl, { alignItems: 'center', gap: 2 });
                if (!isArray) {
                    new label_1.Label(hStack, { caption: labelName });
                    if (isRequired) {
                        new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                    }
                    if (tooltip) {
                        new icon_1.Icon(hStack, {
                            width: '1rem',
                            height: '1rem',
                            name: 'info-circle',
                            margin: { left: 2 },
                            tooltip: { content: tooltip, placement: 'bottom' }
                        });
                    }
                }
                const controlPnl = new layout_1.Panel(groupPnl);
                let checkbox = new checkbox_1.Checkbox(controlPnl, {
                    readOnly: schema.readOnly
                });
                checkbox.id = idxScope;
                checkbox.onChanged = () => validateOnValueChanged(idxScope);
                controls[idxScope] = checkbox;
                if (isArray) {
                    controls[idxScope].setAttribute('role', 'column');
                    controls[idxScope].setAttribute('field', currentField);
                }
                return groupPnl;
            }
            // Group Box / Sublevel
            else if (schema.type === 'object') {
                const properties = schema.properties;
                if (!properties)
                    return undefined;
                const groupPnl = new layout_1.Panel(undefined, {
                    border: {
                        width: 1,
                        style: 'solid',
                        color: '#EEE',
                        radius: "0.4rem"
                    },
                    padding: {
                        top: 16,
                        bottom: 16,
                        left: 16,
                        right: 16
                    }
                });
                // const box = new Panel(undefined, borderStyle);
                const templateColumns = [];
                if (options.columnsPerRow)
                    for (let i = 0; i < options.columnsPerRow; i++)
                        templateColumns.push('1fr');
                let form = new layout_1.GridLayout(undefined, {
                    templateColumns,
                    gap: {
                        row: 10,
                        column: 10
                    },
                    padding: {
                        top: 5,
                        bottom: 5,
                        left: 10,
                        right: 10
                    }
                });
                if (scope !== '#') {
                    const pnl = new layout_1.Panel(groupPnl, {
                        padding: {
                            top: 5,
                            bottom: 5,
                            left: 10,
                            right: 10
                        },
                        border: {
                            bottom: {
                                width: 1,
                                style: 'solid',
                                color: '#CCC',
                                radius: 5
                            }
                        }
                    });
                    const hStack = new layout_1.HStack(pnl, { alignItems: 'center', gap: 2 });
                    new label_1.Label(hStack, { caption: labelName, font: { size: '1.6rem' } });
                    if (isRequired) {
                        new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                    }
                    if (tooltip) {
                        new icon_1.Icon(hStack, {
                            width: '1rem',
                            height: '1rem',
                            name: 'info-circle',
                            margin: { left: 2 },
                            tooltip: { content: tooltip, placement: 'bottom' }
                        });
                    }
                }
                for (const propertyName in properties) {
                    let currentSchema = properties[propertyName];
                    if (!currentSchema?.required && arrRequired.includes(propertyName)) {
                        currentSchema.required = true;
                    }
                    const control = renderForm(currentSchema, `${idxScope}/properties/${propertyName}`, false, idx);
                    form.append(control);
                }
                groupPnl.append(form);
                controls[idxScope] = groupPnl;
                return groupPnl;
            }
            // Card List
            else if (schema.type === 'array') {
                // Todo: card view editor
                if (!schema.items)
                    return undefined;
                let isVertical = false;
                if (typeof schemaOptions?.detail === 'object') {
                    isVertical = schemaOptions.detail.type === 'VerticalLayout';
                }
                const groupPnl = new layout_1.Panel(undefined, {
                    border: {
                        width: 1,
                        style: 'solid',
                        color: '#EEE',
                        radius: "0.4rem"
                    },
                    padding: {
                        top: 16,
                        bottom: 16,
                        left: 8,
                        right: 8
                    }
                });
                groupPnl.setAttribute('role', 'array');
                const arrayField = scope.split('/');
                groupPnl.setAttribute('array-field', arrayField[arrayField.length - 1]);
                groupPnl.setAttribute('array-field-idx', `${idx === undefined ? '' : idx}`);
                const pnlTitle = new layout_1.HStack(groupPnl, {
                    padding: {
                        top: 5,
                        bottom: 5,
                        left: 10,
                        right: 10
                    },
                    border: {
                        bottom: {
                            width: 1,
                            style: 'solid',
                            color: "#DADDE1"
                        },
                    },
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    backgroundColor: 'transparent'
                });
                const hStack = new layout_1.HStack(pnlTitle, { alignItems: 'center', gap: 2 });
                new label_1.Label(hStack, { caption: labelName, font: { size: '1rem' } });
                if (isRequired) {
                    new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                }
                if (tooltip) {
                    new icon_1.Icon(hStack, {
                        width: '1rem',
                        height: '1rem',
                        name: 'info-circle',
                        margin: { left: 2 },
                        tooltip: { content: tooltip, placement: 'bottom' }
                    });
                }
                const btnAdd = new icon_1.Icon(new layout_1.Panel(pnlTitle), {
                    name: 'plus',
                    fill: style_1.Theme.ThemeVars.colors.primary.main,
                    width: '1em',
                    height: '1em'
                });
                btnAdd.classList.add('pointer');
                btnAdd.setAttribute('role', 'add');
                const pnlItems = new layout_1.Panel(groupPnl, {
                    padding: {
                        top: 5,
                        bottom: 5,
                        left: 5,
                        right: 5
                    }
                });
                const _items = schema.items;
                const itemsRequired = typeof _items?.required === 'object' ? _items.required : [];
                const updateIndex = (props, newIdx, currentIdx, prefixScope, newPrefix, subIdx) => {
                    for (const propertyName in props) {
                        const subIndex = subIdx || 0;
                        const finalIndex = subIdx ? subIndex : newIdx;
                        const currentScope = `${prefixScope}/properties/${propertyName}_${subIdx ? subIndex : currentIdx}`;
                        const newScope = `${newPrefix || prefixScope}/properties/${propertyName}_${finalIndex}`;
                        if (props[propertyName].type === 'object') {
                            updateIndex(props[propertyName].properties, newIdx, currentIdx, currentScope, newScope);
                        }
                        else if (props[propertyName].type === 'array' && props[propertyName].items?.type === 'object') { //TODO: type is not an object
                            const rows = controls[currentScope]?.querySelectorAll(":scope > i-panel > [role='row']") || [];
                            let _currentItemIdx = 0;
                            while (_currentItemIdx < rows.length) {
                                _currentItemIdx++;
                                updateIndex(props[propertyName].items.properties, newIdx, currentIdx, currentScope, newScope, subIndex + _currentItemIdx);
                            }
                        }
                        const parentLayout = controls[newScope]?.closest('[array-item-idx]');
                        if (parentLayout) {
                            parentLayout.setAttribute('array-item-idx', `${newIdx}`);
                            parentLayout['options']['array-item-idx'] = `${newIdx}`;
                        }
                        updateSingleIndex(currentScope, newScope, finalIndex);
                    }
                };
                const updateNonObjIndex = (newIdx, currentIdx, prefixScope) => {
                    const currentScope = `${prefixScope}_${currentIdx}`;
                    const newScope = `${prefixScope}_${newIdx}`;
                    updateSingleIndex(currentScope, newScope);
                };
                const updateSingleIndex = (currentScope, newScope, finalIndex) => {
                    const tempControl = controls[currentScope];
                    controls[newScope] = tempControl;
                    if (controls[newScope].id) {
                        controls[newScope].id = newScope;
                    }
                    else if (controls[newScope].getAttribute('object-field-idx') && finalIndex != undefined) {
                        controls[newScope].setAttribute('object-field-idx', `${finalIndex}`);
                        controls[newScope]['options']['object-field-idx'] = `${finalIndex}`;
                    }
                    else if (controls[newScope].getAttribute('array-field-idx') && finalIndex != undefined) {
                        controls[newScope].setAttribute('array-field-idx', `${finalIndex}`);
                        controls[newScope]['options']['array-field-idx'] = `${finalIndex}`;
                    }
                    const tempErrMsg = errorMsgs[currentScope];
                    if (tempErrMsg) {
                        errorMsgs[newScope] = tempErrMsg;
                        controls[newScope].onChanged = () => validateOnValueChanged(newScope);
                    }
                    const tempDescription = descriptions[currentScope];
                    if (tempDescription) {
                        descriptions[newScope] = tempDescription;
                    }
                    delete descriptions[currentScope];
                    delete errorMsgs[currentScope];
                    delete controls[currentScope];
                };
                const isObject = _items.type === 'object';
                if (!isObject)
                    isVertical = true; // Todo: horizontal non-object item
                const itemType = schema.items?.type;
                if (isVertical && _items.type) {
                    const addCard = () => {
                        const index = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length + 1;
                        const arrIndex = groupPnl.getAttribute('array-field-idx') || idx;
                        const newIdxScope = idx !== undefined ? `${scope}_${arrIndex}` : scope;
                        const gridSize = (isObject) ? ['1fr', '3fr'] : ['3fr', '1fr'];
                        const gridLayout = new layout_1.GridLayout(pnlItems, {
                            templateColumns: gridSize,
                            border: {
                                bottom: {
                                    width: 1,
                                    style: 'solid',
                                    color: "#DADDE1"
                                }
                            },
                            padding: {
                                top: 32,
                                bottom: 32,
                                left: 8,
                                right: 8
                            },
                            gap: {
                                row: 10,
                                column: 10
                            },
                        });
                        gridLayout.position = 'relative';
                        gridLayout.setAttribute('role', 'row');
                        gridLayout.setAttribute('array-item-idx', `${index}`);
                        if (isObject == false) {
                            if (schema.required === true) {
                                _items.required = true;
                            }
                            const control = renderForm(_items, `${idxScope}`, true, index);
                            if (control) {
                                control.setAttribute('object-field-idx', `${index}`);
                                if (itemType !== 'array' && itemType !== 'object') {
                                    control.setAttribute("single-field", '');
                                }
                                gridLayout.append(control);
                            }
                        }
                        else if (typeof _items === 'object' && _items.type === 'object' && _items.properties) {
                            for (const propertyName in _items.properties) {
                                let property = schema.items.properties[propertyName];
                                if (!property?.required && (arrRequired.includes(propertyName) || itemsRequired.includes(propertyName))) {
                                    property.required = true;
                                }
                                const control = renderForm(property, `${newIdxScope}/properties/${propertyName}`, true, index);
                                if (control && property?.type === 'object') {
                                    control.setAttribute('object-field', propertyName);
                                    control.setAttribute('object-field-idx', `${index}`);
                                    if (itemType !== 'array' && itemType !== 'object') {
                                        control.setAttribute("single-field", '');
                                    }
                                    const lb = control.querySelector(':scope > i-panel');
                                    if (lb) {
                                        lb.style.display = 'none';
                                    }
                                }
                                ;
                                const hStack = new layout_1.HStack(undefined, { gap: 2 });
                                const _property = property;
                                new label_1.Label(hStack, { caption: _property.title || convertFieldNameToLabel(propertyName) });
                                if (_property.required) {
                                    new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                                }
                                gridLayout.append(hStack);
                                gridLayout.append(control);
                            }
                        }
                        // Append delete card
                        const btnDelete = new icon_1.Icon(undefined, {
                            name: 'times',
                            fill: '#ff0000',
                            width: '1rem',
                            height: '1rem'
                        });
                        if (!isObject) {
                            const hStack = new layout_1.HStack(gridLayout, {
                                height: '40px',
                                padding: {
                                    top: 10,
                                    bottom: 10,
                                    left: 15,
                                    right: 15
                                },
                            });
                            hStack.verticalAlignment = 'center';
                            hStack.horizontalAlignment = 'end';
                            hStack.append(btnDelete);
                        }
                        else {
                            btnDelete.style.top = '5px';
                            btnDelete.style.right = '5px';
                            gridLayout.append(btnDelete);
                        }
                        btnDelete.position = 'absolute';
                        btnDelete.classList.add('pointer');
                        btnDelete.onClick = () => {
                            let currentIdx = Number(gridLayout.getAttribute('array-item-idx') || '1');
                            let newIdx = Number(gridLayout.getAttribute('array-item-idx') || '1');
                            let idxItem = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length;
                            while (newIdx < idxItem) {
                                currentIdx++;
                                if (isObject)
                                    updateIndex(_items.properties, newIdx, currentIdx, newIdxScope);
                                else
                                    updateNonObjIndex(newIdx, currentIdx, newIdxScope);
                                newIdx = Number(currentIdx);
                            }
                            gridLayout.remove();
                        };
                    };
                    btnAdd.onClick = () => {
                        addCard();
                    };
                    addCard();
                }
                else {
                    let colCount = 0;
                    if (schema.items instanceof Array)
                        colCount = schema.items.length;
                    else if (typeof schema.items === 'object' && schema.items.type === 'object' && schema.items.properties)
                        colCount = Object.keys(schema.items.properties).length;
                    const templateColumns = [];
                    for (let i = 0; i < colCount; i++)
                        templateColumns.push('1fr');
                    templateColumns.push('1em');
                    const headerColumn = new layout_1.GridLayout(pnlItems, {
                        templateColumns,
                        border: {
                            top: {
                                width: 1,
                                style: 'solid',
                                color: "#DADDE1"
                            },
                            bottom: {
                                width: 1,
                                style: 'solid',
                                color: "#DADDE1"
                            }
                        },
                        padding: {
                            top: 16,
                            bottom: 16,
                            left: 16,
                            right: 16
                        },
                        gap: {
                            row: 10,
                            column: 10
                        },
                    });
                    if (schema.items instanceof Array) {
                        for (const item of schema.items) {
                            const _item = item;
                            if (_item.title) {
                                const hStack = new layout_1.HStack(headerColumn, { gap: 2 });
                                new label_1.Label(hStack, { caption: _item.title });
                                if (_item.required) {
                                    new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                                }
                            }
                        }
                    }
                    else if (typeof schema.items === 'object') {
                        if (schema.items.type === 'object' && schema.items.properties) {
                            // Header
                            for (const propertyName in schema.items.properties) {
                                let property = schema.items.properties[propertyName];
                                if (!property?.required && (arrRequired.includes(propertyName) || itemsRequired.includes(propertyName))) {
                                    property.required = true;
                                }
                                const hStack = new layout_1.HStack(headerColumn, { gap: 2 });
                                const _property = property;
                                new label_1.Label(hStack, { caption: _property.title || convertFieldNameToLabel(propertyName) });
                                if (_property.required) {
                                    new label_1.Label(hStack, { caption: '*', font: { color: '#ff0000' } });
                                }
                            }
                        }
                    }
                    // Body
                    const addRow = () => {
                        const index = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length + 1;
                        const arrIndex = groupPnl.getAttribute('array-field-idx') || idx;
                        const newIdxScope = idx !== undefined ? `${scope}_${arrIndex}` : scope;
                        const bodyColumn = new layout_1.GridLayout(pnlItems, {
                            templateColumns,
                            gap: {
                                row: 10,
                                column: 10
                            },
                            padding: {
                                top: 16,
                                bottom: 16,
                                left: 16,
                                right: 16
                            },
                            border: {
                                bottom: {
                                    width: 1,
                                    style: "solid",
                                    color: "#DADDE1"
                                }
                            }
                        });
                        bodyColumn.setAttribute('role', 'row');
                        bodyColumn.setAttribute('array-item-idx', `${index}`);
                        if (typeof schema.items === 'object' && _items.type === 'object' && _items.properties) {
                            for (const propertyName in _items.properties) {
                                const property = schema.items.properties[propertyName];
                                if (!property?.required && (arrRequired.includes(propertyName) || itemsRequired.includes(propertyName))) {
                                    property.required = true;
                                }
                                const control = renderForm(property, `${newIdxScope}/properties/${propertyName}`, true, index);
                                if (control && property?.type === 'object') {
                                    control.setAttribute('object-field', propertyName);
                                    control.setAttribute('object-field-idx', `${index}`);
                                    if (itemType !== 'array' && itemType !== 'object') {
                                        control.setAttribute("single-field", '');
                                    }
                                    const lb = control.querySelector(':scope > i-panel');
                                    if (lb) {
                                        lb.style.display = 'none';
                                    }
                                }
                                ;
                                bodyColumn.append(control);
                            }
                            // Append delete row
                            const btnDelete = new icon_1.Icon(bodyColumn, {
                                name: 'times',
                                fill: '#ff0000',
                                width: '1em',
                                height: '1em',
                                marginBlock: {
                                    top: 'auto'
                                }
                            });
                            btnDelete.classList.add('pointer');
                            btnDelete.onClick = () => {
                                let currentIdx = Number(bodyColumn.getAttribute('array-item-idx') || '1');
                                let newIdx = Number(bodyColumn.getAttribute('array-item-idx') || '1');
                                let idxItem = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length;
                                while (newIdx < idxItem) {
                                    currentIdx++;
                                    updateIndex(_items.properties, newIdx, currentIdx, newIdxScope);
                                    newIdx = Number(currentIdx);
                                }
                                bodyColumn.remove();
                            };
                        }
                    };
                    addRow();
                    btnAdd.onClick = () => { addRow(); };
                }
                controls[idxScope] = groupPnl;
                return groupPnl;
            }
            else if (schema.type === 'null') {
                return undefined;
            }
            else if (schema.type === 'any') {
                // To do
                return undefined;
            }
            else
                return undefined;
        };
        // By UI Schema
        const renderFormBySchema = (dataSchema, uiSchema, scope = "#") => {
            if (!dataSchema || !uiSchema)
                return;
            clearUI();
            let uiWrapper = new layout_1.Panel(target, {
                padding: {
                    left: 10,
                    right: 10,
                    top: 0,
                    bottom: 10
                }
            });
            uiWrapper.id = 'uiWrapper';
            let formTabs = new tab_1.Tabs(uiWrapper, {
                mode: 'vertical'
            });
            formTabs.id = "formTabs";
            formTabs.classList.add(jsonUI_css_1.jsonUITabStyle);
            formTabs.visible = ['Categorization', 'Category'].includes(uiSchema.type);
            let ui = createUI(uiSchema);
            if (ui)
                uiWrapper.append(ui);
            setupRules();
        };
        const setupRules = () => {
            for (const item of flatRules) {
                const { rule, elm } = item;
                if (rule && rule.condition && rule.condition.scope && rule.condition.schema) {
                    const control = document.getElementById(rule.condition.scope);
                    if (control) {
                        const toggleValidate = () => {
                            if (rule.effect === 'HIDE' || rule.effect === 'SHOW') {
                                if (control.checked === rule.condition.schema.const) {
                                    elm.visible = rule.effect === 'SHOW';
                                }
                                else {
                                    elm.visible = !(rule.effect === 'SHOW');
                                }
                            }
                            else if (rule.effect == 'ENABLE' || rule.effect == 'DISABLE') {
                                if (control.checked === rule.condition.schema.const) {
                                    elm.enabled = rule.effect === 'ENABLE';
                                }
                                else {
                                    elm.enabled = !(rule.effect === 'ENABLE');
                                }
                            }
                        };
                        if (control.tagName === 'I-CHECKBOX' || control.tagName === 'I-SWITCH') {
                            control.onChanged = (target, event) => {
                                toggleValidate();
                            };
                            toggleValidate();
                        }
                    }
                }
            }
        };
        const clearUI = () => {
            let uiWrapper = document.getElementById("uiWrapper");
            if (uiWrapper)
                uiWrapper.innerHTML = "";
        };
        const generateTemplateColumnsByNumber = (count) => {
            let columns = [];
            for (let i = 0; i < count; i++)
                columns.push('1fr');
            return columns;
        };
        const getDataSchemaByScope = (scope) => {
            const segments = scope.split('/');
            let obj = {};
            for (const segment of segments) {
                if (segment === '#')
                    obj = options.jsonSchema;
                else
                    obj = obj[segment];
            }
            if (obj == undefined)
                console.log("No corresponding scope:", scope);
            return [segments[segments.length - 1], obj];
        };
        const createUI = (uiSchema, carryData) => {
            if (!uiSchema)
                return null;
            const { elements, type, scope, label, options, rule } = uiSchema;
            if (type === 'VerticalLayout') {
                const elm = new layout_1.VStack(undefined, {
                    justifyContent: 'center',
                    alignItems: 'center'
                });
                if (elements)
                    elements.map(v => {
                        let ui = createUI(v);
                        if (ui)
                            elm.append(ui);
                    });
                if (rule)
                    flatRules.push({ elm, rule });
                return elm;
            }
            else if (type === 'HorizontalLayout') {
                const elm = new layout_1.GridLayout(undefined, {
                    width: '100%',
                    gap: { column: 16 },
                    templateColumns: (elements) ? generateTemplateColumnsByNumber(elements.length) : ""
                });
                if (elements)
                    elements.map(v => {
                        let ui = createUI(v);
                        if (ui)
                            elm.append(ui);
                    });
                if (rule)
                    flatRules.push({ elm, rule });
                return elm;
            }
            else if (type === 'Group') {
                const elm = new layout_1.Panel(undefined, {
                    width: '100%'
                });
                elm.classList.add('box');
                if (label !== false && !!label) {
                    let boxHeader = new layout_1.Panel(elm);
                    let boxHeaderLabel = new label_1.Label(boxHeader, {
                        caption: label
                    });
                    boxHeaderLabel.classList.add('box-header');
                }
                const boxContent = new layout_1.Panel(elm);
                boxContent.classList.add('box-content');
                if (elements)
                    elements.map(v => {
                        let ui = createUI(v);
                        if (ui)
                            boxContent.append(ui);
                    });
                if (rule)
                    flatRules.push({ elm, rule });
                return elm;
            }
            else if (type === 'Categorization') {
                let elm = new tab_1.Tabs();
                elm.classList.add(jsonUI_css_1.jsonUITabStyle);
                let formTabs = document.getElementById('formTabs');
                if (formTabs)
                    formTabs.visible = true;
                if (elements) {
                    for (let i = 0; i < elements.length; i++) {
                        const element = elements[i];
                        createUI(element, { tabs: formTabs, index: i });
                    }
                }
                elm = formTabs;
                if (rule)
                    flatRules.push({ elm, rule });
                return formTabs;
            }
            else if (type === 'Category') {
                let caption;
                if (label !== false) {
                    caption = label;
                }
                if (carryData && carryData.tabs && carryData.index != undefined) {
                    const children = new layout_1.Panel(undefined, {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    });
                    if (elements) {
                        for (const element of elements) {
                            let ui = createUI(element);
                            if (ui)
                                children.append(ui);
                        }
                    }
                    let tabCaption = (typeof caption == 'boolean') ? "" : caption;
                    const formTabs = document.getElementById("formTabs");
                    // (carryData.tabs as Tabs).add({ caption: tabCaption, children: children });
                    let tab = formTabs.add({ caption: tabCaption, children: children });
                    formTabs.activeTabIndex = 0;
                    if (rule)
                        flatRules.push({ elm: tab, rule });
                }
            }
            else if (type === 'Control' && scope) {
                const [key, dataSchema] = getDataSchemaByScope(scope);
                const stub = new layout_1.Panel(undefined, {
                    padding: {
                        left: 5,
                        right: 5,
                        top: 5,
                        bottom: 5
                    }
                });
                stub.classList.add('form-group');
                let caption, labelElm, descriptionElm;
                let formControlElm = new layout_1.Panel();
                formControlElm.classList.add('form-control');
                let hideLabel = false;
                if (label !== false) {
                    caption = label;
                    if (!caption)
                        caption = convertFieldNameToLabel(key);
                }
                const control = renderForm(dataSchema, scope, false, undefined, options);
                formControlElm.append(control);
                if (formControlElm)
                    stub.append(formControlElm);
                if (descriptionElm)
                    stub.append(descriptionElm);
                if (rule) {
                    flatRules.push({ elm: stub, rule });
                }
                ;
                return stub;
            }
            else
                return null;
        };
        const setDataUpload = (url, control) => {
            if (!url || !control)
                return;
            const getImageTypeFromUrl = (url) => {
                const extension = url.match(/\.([^.]+)$/);
                switch (extension && extension[1].toLowerCase()) {
                    case 'jpg':
                    case 'jpeg':
                        return 'image/jpeg';
                    case 'png':
                        return 'image/png';
                    case 'gif':
                        return 'image/gif';
                    case 'svg':
                        return 'image/svg';
                    default:
                        return 'image/png';
                }
            };
            const getExtensionFromType = (fileType) => {
                return fileType.split('/')[1];
            };
            try {
                let imgUrl = url;
                if (url.startsWith('ipfs://')) {
                    imgUrl = imgUrl.replace('ipfs://', 'https://ipfs.scom.dev/ipfs/');
                }
                fetch(imgUrl)
                    .then(response => response.arrayBuffer())
                    .then(arrayBuffer => {
                    const fileType = getImageTypeFromUrl(imgUrl);
                    const blob = new Blob([arrayBuffer], { type: fileType });
                    const fileName = `image-${Date.now()}.${getExtensionFromType(fileType)}`;
                    const file = new File([blob], fileName, { type: fileType });
                    control.fileList = [file];
                    control.preview(imgUrl);
                });
            }
            catch {
                control.fileList = [];
            }
        };
        const setData = (schema, data, scope = '#', idx) => {
            if (!schema || (!data && !(schema.type === 'number' && data === 0)))
                return;
            const idxScope = idx !== undefined ? `${scope}_${idx}` : scope;
            if (schema.type === 'object') {
                if (!schema.properties)
                    return;
                for (const propertyName in schema.properties) {
                    setData(schema.properties[propertyName], data[propertyName], `${idxScope}/properties/${propertyName}`, idx);
                }
            }
            else if (schema.type === 'array') {
                if (typeof schema.items === 'object' && schema.items.properties) {
                    const grid = controls[idxScope];
                    const btnAdd = grid.querySelector("[role='add']");
                    let rows = grid.querySelectorAll("[role='row']");
                    if (data instanceof Array) {
                        for (let i = 0; i < data.length; i++) {
                            const columnData = data[i];
                            if (btnAdd && i > 0)
                                btnAdd.onClick(btnAdd);
                            if (typeof columnData === 'object') {
                                for (const propertyName in columnData) {
                                    const fieldData = columnData[propertyName];
                                    rows = grid.querySelectorAll(":scope > i-panel > [role='row']");
                                    if (rows) {
                                        const row = rows[rows.length - 1];
                                        const column = row.querySelector(`[role='column'][field='${propertyName}']`);
                                        if (column) {
                                            if (column.tagName === 'I-CHECKBOX') {
                                                column.checked = fieldData;
                                            }
                                            else if (column.tagName === 'I-COMBO-BOX') {
                                                column.selectedItem = column.items.find(v => v.value === fieldData) || undefined;
                                            }
                                            else if (column.tagName === 'I-DATEPICKER') {
                                                const format = column.getAttribute('format');
                                                let dateFormat;
                                                if (format === 'date')
                                                    dateFormat = defaultDateFormat;
                                                else if (format === 'time')
                                                    dateFormat = defaultTimeFormat;
                                                else
                                                    dateFormat = defaultDateTimeFormat;
                                                column.value = (0, moment_1.moment)(fieldData, dateFormat);
                                            }
                                            else if (column.tagName === "I-UPLOAD") {
                                                setDataUpload(fieldData, column);
                                            }
                                            else {
                                                column.value = fieldData;
                                            }
                                            continue;
                                        }
                                        const properties = schema.items?.properties || {};
                                        const objectField = row.querySelector(`:scope > [object-field='${propertyName}']`);
                                        if (objectField) {
                                            const idxObj = objectField.getAttribute('object-field-idx');
                                            setData(properties[propertyName], fieldData, `${idxScope}/properties/${propertyName}`, Number(idxObj));
                                            continue;
                                        }
                                        const arrayField = row.querySelector(`:scope > [array-field='${propertyName}']`);
                                        if (arrayField) {
                                            const idxObj = arrayField.getAttribute('array-field-idx');
                                            setData(properties[propertyName], fieldData, `${idxScope}/properties/${propertyName}`, Number(idxObj));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    const grid = controls[idxScope];
                    const btnAdd = grid.querySelector("[role='add']");
                    for (let i = 0; i < data.length; i++) {
                        if (btnAdd && i > 0)
                            btnAdd.onClick(btnAdd);
                        if (typeof (schema.items) != 'boolean' && typeof (schema.items) != 'undefined')
                            setData(schema.items, data[i], `${scope}_${i + 1}`);
                    }
                }
            }
            else {
                const control = controls[idxScope];
                if (control.tagName === 'I-CHECKBOX')
                    control.checked = data;
                else if (control.tagName === 'I-DATEPICKER') {
                    const format = schema.format;
                    let dateFormat;
                    if (format === 'date')
                        dateFormat = defaultDateFormat;
                    else if (format === 'time')
                        dateFormat = defaultTimeFormat;
                    else
                        dateFormat = defaultDateTimeFormat;
                    control.value = (0, moment_1.moment)(data, dateFormat);
                }
                else if (control.tagName === 'I-COMBO-BOX') {
                    control.selectedItem = control.items.find(v => v.value === data) || undefined;
                }
                else if (control.tagName === "I-UPLOAD") {
                    setDataUpload(data, control);
                }
                else
                    control.value = data;
            }
        };
        const getData = async (schema, scope = '#', idx) => {
            if (!schema)
                return null;
            const idxScope = idx !== undefined ? `${scope}_${idx}` : scope;
            if (schema.type === 'object') {
                const properties = schema.properties;
                if (!properties)
                    return undefined;
                const data = {};
                for (const propertyName in properties) {
                    data[propertyName] = await getData(properties[propertyName], `${idxScope}/properties/${propertyName}`, idx);
                }
                return data;
            }
            else if (schema.type === 'array') {
                const grid = controls[idxScope];
                if (!grid)
                    return undefined;
                const rows = grid.querySelectorAll("[role='row']");
                if (!rows)
                    return undefined;
                const listData = [];
                for (const row of rows) {
                    const parentRow = row.closest("[role='array']");
                    if (parentRow !== grid)
                        continue;
                    const columns = row.querySelectorAll("[role='column']");
                    const objects = row.querySelectorAll(":scope > [object-field]");
                    const arrayField = row.querySelectorAll(":scope > [array-field]");
                    if (!columns && !objects && !arrayField)
                        continue;
                    let columnData = {};
                    for (const column of columns) {
                        const parentCol = column.closest("[role='row']");
                        if (parentCol !== row)
                            continue;
                        const fieldName = column.getAttribute('field');
                        if (!fieldName)
                            continue;
                        const isSingle = column.closest("[single-field]");
                        if (column.tagName === 'I-CHECKBOX') {
                            columnData[fieldName] = column.checked;
                        }
                        else if (column.tagName === 'I-COMBO-BOX') {
                            columnData[fieldName] = column.value?.value;
                        }
                        else if (column.tagName === 'I-DATEPICKER') {
                            const format = column.getAttribute('format');
                            let dateFormat;
                            if (format === 'date')
                                dateFormat = defaultDateFormat;
                            else if (format === 'time')
                                dateFormat = defaultTimeFormat;
                            else
                                dateFormat = defaultDateTimeFormat;
                            columnData[fieldName] = column.value?.format(dateFormat) || '';
                        }
                        else if (column.tagName === 'I-UPLOAD') {
                            if (!column.fileList || column.fileList && column.fileList.length === 0)
                                return undefined;
                            columnData[fieldName] = await column.toBase64(column.fileList[0]);
                        }
                        else if (column.tagName === 'I-INPUT') {
                            const format = column.getAttribute('format');
                            if (format === 'number')
                                columnData[fieldName] = parseFloat(column.value);
                            else if (format === 'integer')
                                columnData[fieldName] = parseInt(column.value);
                            else
                                columnData[fieldName] = column.value;
                        }
                        if (isSingle) {
                            columnData = columnData[fieldName];
                        }
                    }
                    const properties = schema.items?.properties || {};
                    for (const obj of objects) {
                        const field = obj.getAttribute('object-field');
                        const idxObj = obj.getAttribute('object-field-idx');
                        if (field && properties[field]) {
                            columnData[field] = await getData(properties[field], `${idxScope}/properties/${field}`, Number(idxObj));
                        }
                    }
                    for (const card of arrayField) {
                        const field = card.getAttribute('array-field');
                        const idxObj = card.getAttribute('array-field-idx');
                        if (field && properties[field]) {
                            columnData[field] = await getData(properties[field], `${idxScope}/properties/${field}`, Number(idxObj));
                        }
                    }
                    listData.push(columnData);
                }
                return listData;
            }
            else {
                const control = controls[idxScope];
                if (!control)
                    return undefined;
                if (control.tagName === 'I-CHECKBOX')
                    return control.checked;
                else if (control.tagName === 'I-COMBO-BOX') {
                    return control.value?.value;
                }
                else if (control.tagName === 'I-DATEPICKER') {
                    const value = control.value;
                    if (value === undefined)
                        return '';
                    if (schema.format === 'date')
                        return value?.format(defaultDateFormat) || '';
                    else if (schema.format === 'time')
                        return value?.format(defaultTimeFormat) || '';
                    else if (schema.format === 'date-time')
                        return value?.format(defaultDateTimeFormat) || '';
                }
                else if (control.tagName === 'I-UPLOAD') {
                    if (!control.fileList || control.fileList && control.fileList.length === 0)
                        return undefined;
                    const dataUrl = await control.toBase64(control.fileList[0]);
                    return dataUrl;
                }
                else if (control.tagName === 'I-INPUT') {
                    if (schema.type === 'string')
                        return control.value;
                    else if (schema.type === 'integer') {
                        const value = parseInt(control.value);
                        return isNaN(value) ? undefined : value;
                    }
                    else if (schema.type === 'number') {
                        const value = parseFloat(control.value);
                        return isNaN(value) ? undefined : value;
                    }
                    else
                        return control.value;
                }
                return control.value;
            }
        };
        const panel = new layout_1.Panel();
        if (options?.jsonUISchema) {
            renderFormBySchema(options.jsonSchema, options.jsonUISchema);
        }
        else {
            const form = renderForm(options.jsonSchema);
            panel.append(form);
        }
        const pnlButton = new layout_1.HStack();
        const confirmButtonCaption = options.confirmButtonCaption ? options.confirmButtonCaption : 'Confirm';
        const buttonStack = new layout_1.HStack(undefined, {
            justifyContent: 'end',
            alignItems: 'center',
            width: '100%',
            padding: {
                left: 10,
                right: 10,
                top: 5,
                bottom: 5
            }
        });
        if (options.showClearButton) {
            const clearButtonCaption = options.clearButtonCaption ? options.clearButtonCaption : 'Clear';
            const btnClear = new button_1.Button(buttonStack, {
                caption: clearButtonCaption,
                padding: {
                    top: 5,
                    bottom: 5,
                    left: 5,
                    right: 5
                },
                margin: {
                    right: 5
                },
                font: {
                    color: (options.clearButtonFontColor ? options.clearButtonFontColor : '#FFF')
                },
                background: {
                    color: (options.clearButtonBackgroundColor ? options.clearButtonBackgroundColor : '#3F51B5')
                }
            });
            btnClear.onClick = () => {
                for (const scope in controls) {
                    const control = controls[scope];
                    if (control.tagName === 'I-COMBO-BOX')
                        control.clear();
                    else if (control.tagName === 'I-CHECKBOX')
                        control.checked = false;
                    else
                        control.value = undefined;
                }
            };
        }
        if (!options.hideConfirmButton) {
            const btnConfirm = new button_1.Button(buttonStack, {
                caption: confirmButtonCaption,
                padding: {
                    top: 5,
                    bottom: 5,
                    left: 5,
                    right: 5
                },
                font: {
                    color: (options.confirmButtonFontColor ? options.confirmButtonFontColor : '#FFF')
                },
                background: {
                    color: (options.confirmButtonBackgroundColor ? options.confirmButtonBackgroundColor : '#3F51B5')
                }
            });
            btnConfirm.onClick = async () => {
                if (!confirmCallback)
                    return;
                const data = await getData(options.jsonSchema);
                const validationResult = validate(data, options.jsonSchema, { changing: false });
                if (validationResult?.valid)
                    confirmCallback(true, data);
                else
                    confirmCallback(false, validationResult);
            };
            panel.append(pnlButton);
        }
        if (target) {
            target.append(panel);
            if (buttonStack.childNodes.length > 0) {
                target.append(buttonStack);
            }
            if (options.data) {
                const validationResult = validate(options.data, options.jsonSchema, { changing: false });
                if (validationResult?.valid)
                    setData(options.jsonSchema, options.data);
                else
                    console.log(validationResult);
            }
        }
    }
    exports.renderUI = renderUI;
    function convertFieldNameToLabel(name) {
        let label = '';
        for (let i = 0; i < name.length; i++) {
            let char = name[i];
            if (i == 0) {
                label += char.toUpperCase();
                continue;
            }
            if (char == char.toUpperCase())
                label += ` ${char}`;
            else
                label += char;
        }
        return label;
    }
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/alert/style/alert.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Styles.cssRule("i-alert", {
        $nest: {
            ".modal": {
                padding: 0,
                borderRadius: 4,
            },
        },
    });
});
define("@ijstech/alert/alert.ts", ["require", "exports", "@ijstech/base", "@ijstech/button", "@ijstech/icon", "@ijstech/label", "@ijstech/modal", "@ijstech/layout", "@ijstech/style", "@ijstech/application", "@ijstech/types", "@ijstech/alert/style/alert.css.ts"], function (require, exports, base_1, button_1, icon_1, label_1, modal_1, layout_1, style_1, application_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Alert = void 0;
    const DEFAULT_VALUES = {
        target: '_blank'
    };
    let Alert = class Alert extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this.contentElm = null;
            this.titleElm = null;
            this.linkElm = null;
            this.closeModal = () => {
                this.mdAlert.visible = false;
            };
            this.showModal = () => {
                this.renderUI();
                this.mdAlert.visible = true;
            };
            this.closeModal = this.closeModal.bind(this);
        }
        get status() {
            return this._status;
        }
        set status(value) {
            this._status = value;
        }
        get title() {
            return this.getTranslatedText(this._title || '');
        }
        set title(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._title = value;
        }
        get content() {
            return this.getTranslatedText(this._content || '');
        }
        set content(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._content = value;
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.titleElm && this._title?.startsWith('$'))
                this.titleElm.textContent = i18n.get(this._title) || '';
            if (this.contentElm && this._content?.startsWith('$')) {
                const text = i18n.get(this._content) || '';
                this.createLabels(text);
            }
            if (this.linkElm)
                this.linkElm.updateLocale(i18n);
        }
        getTranslatedText(value) {
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        get link() {
            return this._link;
        }
        set link(value) {
            this._link = value;
        }
        get iconName() {
            switch (this.status) {
                case "error":
                    return "times";
                case "warning":
                case "confirm":
                    return "exclamation";
                case "success":
                    return "check";
                default:
                    return "spinner";
            }
        }
        get color() {
            switch (this.status) {
                case "error":
                    return style_1.Theme.ThemeVars.colors.error.main;
                case "warning":
                case "confirm":
                    return style_1.Theme.ThemeVars.colors.warning.main;
                case "success":
                    return style_1.Theme.ThemeVars.colors.success.main;
                default:
                    return style_1.Theme.ThemeVars.colors.primary.main;
            }
        }
        renderUI() {
            this.pnlMain.clearInnerHTML();
            const wrapperElm = new layout_1.VStack(this.pnlMain, {
                horizontalAlignment: "center",
                gap: "1.75rem",
            });
            const border = this.status === "loading"
                ? {}
                : {
                    border: {
                        width: 2,
                        style: "solid",
                        color: this.color,
                        radius: "50%",
                    },
                };
            const paddingSize = this.status === "loading" ? "0.25rem" : "0.6rem";
            new icon_1.Icon(wrapperElm, {
                width: 55,
                height: 55,
                name: this.iconName,
                fill: this.color,
                padding: {
                    top: paddingSize,
                    bottom: paddingSize,
                    left: paddingSize,
                    right: paddingSize,
                },
                spin: this.status === "loading",
                ...border,
            });
            this.renderContent(wrapperElm);
            this.renderLink(wrapperElm);
            this.renderButtons(wrapperElm);
        }
        renderContent(wrapperElm) {
            if (!this.title && !this.content)
                return [];
            const contentElm = new layout_1.VStack(wrapperElm, {
                horizontalAlignment: "center",
                gap: "0.75rem",
                lineHeight: 1.5,
            });
            this.titleElm = this.title
                ? new label_1.Label(contentElm, {
                    caption: this.title,
                    font: { size: "1.25rem", bold: true },
                })
                : null;
            this.contentElm = new layout_1.Panel(contentElm, { width: '100%' });
            if (this.content) {
                this.createLabels(this.content);
            }
        }
        createLabels(text) {
            this.contentElm?.clearInnerHTML();
            if (!text || !this.contentElm)
                return;
            const elements = [];
            const newText = text.replace(/\r\n|\r|<br>/g, '\n');
            const lines = newText.split('\n');
            lines.forEach(line => {
                const label = new label_1.Label(this.contentElm, {
                    caption: line,
                    overflowWrap: "anywhere",
                });
                elements.push(label);
            });
            return elements;
        }
        renderLink(wrapperElm) {
            if (this.link)
                this.linkElm = new label_1.Label(wrapperElm, {
                    class: "text-center",
                    caption: this.link.caption,
                    font: { size: "0.875rem" },
                    link: { href: this.link.href, target: "_blank" },
                    overflowWrap: "anywhere",
                });
        }
        renderButtons(wrapperElm) {
            if (this.status === "confirm") {
                const hStack = new layout_1.HStack(wrapperElm, {
                    verticalAlignment: "center",
                    gap: "0.5rem",
                });
                new button_1.Button(hStack, {
                    padding: {
                        top: "0.5rem",
                        bottom: "0.5rem",
                        left: "2rem",
                        right: "2rem",
                    },
                    caption: "$cancel",
                    font: { color: style_1.Theme.ThemeVars.colors.secondary.contrastText, transform: 'capitalize' },
                    background: { color: style_1.Theme.ThemeVars.colors.secondary.main },
                    onClick: () => {
                        this.closeModal();
                        if (typeof this.onClose === 'function') {
                            this.onClose();
                        }
                    },
                });
                new button_1.Button(hStack, {
                    padding: {
                        top: "0.5rem",
                        bottom: "0.5rem",
                        left: "2rem",
                        right: "2rem",
                    },
                    caption: "$confirm",
                    font: { color: style_1.Theme.ThemeVars.colors.primary.contrastText, transform: 'capitalize' },
                    onClick: () => {
                        if (typeof this.onConfirm === 'function') {
                            this.onConfirm();
                        }
                        this.closeModal();
                    },
                });
            }
            else {
                new button_1.Button(wrapperElm, {
                    padding: {
                        top: "0.5rem",
                        bottom: "0.5rem",
                        left: "2rem",
                        right: "2rem",
                    },
                    caption: "$close",
                    font: { color: style_1.Theme.ThemeVars.colors.primary.contrastText, transform: 'capitalize' },
                    onClick: () => {
                        this.closeModal();
                        if (typeof this.onClose === 'function') {
                            this.onClose();
                        }
                    },
                });
            }
        }
        async init() {
            if (!this.mdAlert) {
                super.init();
                this.status = this.getAttribute("status", true);
                this.title = this.getAttribute("title", true);
                this.content = this.getAttribute("content", true);
                this.link = this.getAttribute("link", true);
                this.onClose = this.getAttribute("onClose", true);
                this.onConfirm = this.getAttribute("onConfirm", true);
                this.mdAlert = await modal_1.Modal.create({
                    width: "400px",
                });
                this.appendChild(this.mdAlert);
                this.pnlMain = new layout_1.Panel(this, {
                    width: "100%",
                    padding: {
                        top: "1.5rem",
                        bottom: "1.5rem",
                        left: "1.5rem",
                        right: "1.5rem",
                    },
                });
                this.mdAlert.item = this.pnlMain;
            }
        }
    };
    Alert = __decorate([
        (0, base_1.customElements)('i-alert', {
            icon: 'exclamation-circle',
            group: types_1.GroupType.BASIC,
            className: 'Alert',
            props: {
                status: { type: 'string' },
                title: { type: 'string' },
                content: { type: 'string' },
                link: {
                    type: 'object',
                    default: { target: DEFAULT_VALUES.target }
                },
            },
            dataSchema: {
                type: 'object',
                properties: {
                    status: {
                        type: 'string',
                        enum: ['warning', 'success', 'error', 'loading', 'confirm']
                    },
                    title: {
                        type: 'string'
                    },
                    content: {
                        type: 'string'
                    },
                    link: {
                        type: 'object',
                        properties: {
                            href: {
                                type: 'string'
                            },
                            target: {
                                type: 'string',
                                enum: ['_blank', '_self', '_parent', '_top'],
                                default: DEFAULT_VALUES.target
                            }
                        }
                    }
                }
            },
            events: {}
        })
    ], Alert);
    exports.Alert = Alert;
});
define("@ijstech/alert", ["require", "exports", "@ijstech/alert/alert.ts"], function (require, exports, alert_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Alert = void 0;
    Object.defineProperty(exports, "Alert", { enumerable: true, get: function () { return alert_1.Alert; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/data-grid/style/dataGrid.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-data-grid', {
        border: '0.5px solid #dadada',
        $nest: {
            '.container': {
                position: 'absolute',
                overflow: 'hidden',
                height: '100%',
                width: '100%'
            },
            '.scrollBox': {
                overflow: 'auto',
                position: 'absolute',
                height: '100%',
                width: '100%',
                top: 0,
                zIndex: 4
            },
            '.grid': {
                position: 'absolute',
                fontSize: '12px',
                fontFamily: '"Segoe UI", Tahoma, Arial, Helvetica, sans-serif',
                color: '#5A5757',
                // borderCollapse: 'seperate',
                borderSpacing: 0,
                tableLayout: 'fixed',
                // backgroundColor: 'white',
                // width: '100%'
            },
            '.grid tr': {
                overflow: 'hidden'
            },
            '.grid tr div': {
                /* border-box: border-box; */
                paddingLeft: '2px',
                paddingRight: '2px',
            },
            '.grid_cell_hidden': {
                display: 'none'
            },
            '.grid_fixed_cell': {
                background: '#F9F9F9',
                borderBottom: '0.5px solid #dadada',
                borderRight: '0.5px solid #dadada',
                // outline: '0.5px solid #dadada',
                boxSizing: 'border-box'
                /*border-left: none;*/
            },
            '.grid_curr_cell': {
                border: '2px solid #5f5f5f',
                boxSizing: 'border-box'
                /*pointer-events: none;*/
            },
            '.grid_selected_cell': {
                backgroundColor: 'rgb(160, 195, 255)',
                pointerEvents: 'none',
                opacity: 0.2
            },
            '.grid_cell': {
                borderBottom: '0.5px solid #dadada',
                borderRight: '0.5px solid #dadada',
                // outline: '0.5px solid #dadada',
                boxSizing: 'border-box',
                background: 'white',
                cursor: 'default',
                // overflow: 'hidden'
            },
            '.grid_cell_value': {
                textOverflow: 'ellipsis',
                wordWrap: 'break-word',
                whiteSpace: 'pre',
                width: '100%'
            },
            '.grid_cell_value.image img': {
                maxHeight: '100%',
                maxWidth: '100%'
            },
            '.grid_header_splitter': {
                position: 'relative',
                zoom: 1,
                filter: 'alpha(opacity=50)',
                opacity: 0.5,
                float: 'right',
                cursor: 'e-resize'
            },
            'input': {
                border: 'none',
                outline: 'none'
            },
            'table': {
                marginLeft: '1px',
                marginTop: '1px'
            }
        }
    });
});
define("@ijstech/data-grid/dataGrid.ts", ["require", "exports", "@ijstech/base", "@ijstech/application", "@ijstech/checkbox", "@ijstech/datepicker", "@ijstech/combo-box", "@ijstech/label", "@ijstech/moment", "@ijstech/data-grid/style/dataGrid.css.ts"], function (require, exports, base_1, application_1, checkbox_1, datepicker_1, combo_box_1, label_1, moment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataGrid = exports.DataGridCell = void 0;
    ;
    ;
    ;
    ;
    function parseNumber(value, decimal) {
        if (typeof (value) == 'string')
            value = value.replace(/,/g, '');
        if (decimal)
            return parseFloat(parseFloat(value).toFixed(decimal));
        else
            return parseFloat(value);
    }
    ;
    function getCursorPosX(event) {
        event = event; // || window.event;
        let pos = 0;
        if (event instanceof TouchEvent) {
            if (event.changedTouches && event.changedTouches[0])
                pos = event.changedTouches[0].pageX || event.changedTouches[0].clientX;
            else if (event.touches && event.touches[0])
                pos = event.touches[0].pageX || event.touches[0].clientX;
        }
        else
            pos = event.pageX || event.clientX;
        return pos + document.body.scrollLeft + document.documentElement.scrollLeft;
    }
    ;
    function getCursorPosY(event) {
        event = event; // || window.event;
        let pos = 0;
        if (event instanceof TouchEvent) {
            if (event.changedTouches && event.changedTouches[0])
                pos = event.changedTouches[0].pageY || event.changedTouches[0].clientY;
            else if (event.touches && event.touches[0])
                pos = event.touches[0].pageY || event.touches[0].clientY;
        }
        else
            pos = event.pageY || event.clientY;
        return pos + document.body.scrollTop + document.documentElement.scrollTop;
    }
    ;
    function getInputCaretPos(input) {
        try {
            let CaretPos = 0;
            if (input.selectionStart)
                CaretPos = input.selectionStart;
            return (CaretPos);
        }
        catch (err) {
            return 0;
        }
    }
    ;
    class TGridOptions {
        constructor(owner) {
            this._autoRowHeight = false;
            this._rowSelect = false;
            this.autoAddRow = false;
            this.fileDropUpload = false;
            this.sortOnClick = true;
            this.owner = owner;
        }
        ;
        get autoRowHeight() {
            return this._autoRowHeight;
        }
        ;
        set autoRowHeight(value) {
            if (value != this._autoRowHeight) {
                this.owner.rowHeights = [];
                this._autoRowHeight = value;
                this.owner.enableUpdateTimer();
            }
            ;
        }
        ;
        get rowSelect() {
            return this._rowSelect;
        }
        ;
        set rowSelect(value) {
            if (this._rowSelect != value) {
                this._rowSelect = value;
                this.owner.enableUpdateTimer();
            }
            ;
        }
        ;
    }
    ;
    class DataGridCell {
        // private _height: number | undefined;
        constructor(grid, col, row) {
            this._visible = true;
            this.grid = grid;
            this._col = col;
            this._row = row;
        }
        ;
        get button() {
            return this._button;
        }
        ;
        set button(value) {
            this._button = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get checkBox() {
            return this._checkBox;
        }
        ;
        set checkBox(value) {
            this._checkBox = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get col() {
            return this._col;
        }
        ;
        set col(value) {
            this._col = value;
        }
        ;
        get color() {
            return this._color;
        }
        ;
        set color(value) {
            this._color = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get displayValue() {
            return;
            // let col = this.grid.columns.getColumn(this._col)
            // if (this._displayValue != undefined)
            //     return this._displayValue
            // return this._displayValue || this.grid._getDisplayValue(col, this) || '';	
        }
        ;
        get formula() {
            return this._formula;
        }
        ;
        set formula(value) {
            this._formula = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get hint() {
            return this._hint;
        }
        ;
        set hint(value) {
            this._hint = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get horizontalAlign() {
            return this._horizontalAlign;
        }
        ;
        set horizontalAlign(value) {
            this._horizontalAlign = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get html() {
            return this._html;
        }
        ;
        set html(value) {
            this._html = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get image() {
            return this._image;
        }
        ;
        set image(value) {
            this._image = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get object() {
            return this._object;
        }
        ;
        set object(value) {
            this._object = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get readOnly() {
            return this._readOnly;
        }
        ;
        set readOnly(value) {
            this._readOnly = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get row() {
            return this._row;
        }
        ;
        set row(value) {
            this._row = value;
        }
        ;
        get text() {
            return this._text;
        }
        ;
        set text(value) {
            this._text = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get value() {
            return this._value;
        }
        ;
        set value(value) {
            // this._imgUrl = undefined;
            this._value = value;
            // this._height = undefined;
            this.grid.enableUpdateTimer();
        }
        ;
        get visible() {
            return this._visible;
        }
        ;
        set visible(value) {
            this._visible = value;
            this.grid.enableUpdateTimer();
        }
        ;
    }
    exports.DataGridCell = DataGridCell;
    class DataGridCells {
        constructor(owner) {
            this.data = [[]];
            this.grid = owner;
        }
        ;
        assign(data) {
            for (let r = 0; r < data.length; r++) {
                let d = data[r]['data'];
                let row = data[r]['row'];
                for (let c = 0; c < d.length; c++) {
                    this.setValue(c, row, d[c]);
                }
                // this.data[d.row] = d.data;
            }
        }
        ;
        cells(aCol, aRow, refresh) {
            if (refresh)
                return this.getCell(aCol, aRow);
            else if (this.data[aRow]) {
                let cell = this.data[aRow][aCol];
                if (cell && cell.mergeRect && (aCol != cell.mergeRect.startCol || aRow != cell.mergeRect.startRow)) {
                    cell = this.data[cell.mergeRect.startRow][cell.mergeRect.startCol];
                }
                return cell || this.getCell(aCol, aRow);
            }
            else
                return this.getCell(aCol, aRow);
        }
        ;
        clear() {
            // for (let r = 0; r < this.data.length; r++) {			
            // let row = this.data[r];
            // for (let c = 0; c < row.length; c++) {
            // let cell = row[c];
            // if (cell){
            // cell._object = null;
            // cell.grid = null;
            // if (cell._font){
            // cell._font.grid = null;
            // cell._cell = null;
            // }
            // cell._font = null;
            // }
            // row[c] = null;	
            // }
            // }
            this.data = [[]];
        }
        ;
        deleteCol(aCol) {
            for (let r = 0; r < this.data.length; r++) {
                let row = this.data[r];
                if (row)
                    row.splice(aCol, 1);
            }
            this.updateCellIndex();
        }
        ;
        deleteRow(aRow) {
            if (this.data.length > aRow)
                this.data.splice(aRow, 1);
            this.updateCellIndex();
        }
        ;
        getCell(aCol, aRow, refresh) {
            if (typeof (this.data[aRow]) == "undefined")
                this.data[aRow] = [];
            if (typeof (this.data[aRow][aCol]) == "undefined")
                this.data[aRow][aCol] = new DataGridCell(this.grid, aCol, aRow);
            if (refresh && this.data[aRow][aCol])
                this.data[aRow][aCol]._displayValue = undefined;
            return this.data[aRow][aCol];
        }
        ;
        getObject(aCol, aRow) {
            let cell = this.cells(aCol, aRow);
            if (cell)
                return cell.object;
            else
                return undefined;
        }
        ;
        getValue(aCol, aRow) {
            let cell = this.cells(aCol, aRow);
            if (cell) {
                if (cell.mergeRect)
                    cell = this.getCell(cell.mergeRect.startCol, cell.mergeRect.startRow);
                if (cell.value != undefined) {
                    return cell.value;
                }
                else
                    return '';
            }
            ;
        }
        ;
        getExcelValue(aCol, aRow, callback) {
            // let cell = this.cells(aCol, aRow);
            // if (cell) {
            // 	let result = {};
            // 	if (cell.mergeRect){
            // 		if (aCol == cell.mergeRect.startCol && aRow == cell.mergeRect.startRow)				
            // 			let cell = this.getCell(cell.mergeRect.startCol, cell.mergeRect.startRow)
            // 		else if (callback)
            // 			return callback({})
            // 		else
            // 			return {};
            // 	}			
            // 	if (cell._row < this.grid.fixedRow || cell._col < this.grid.fixedCol){
            // 		let value = $ML(cell._value, this.grid.parentForm)
            // 		if (value != undefined)
            // 			result['v'] = value;
            // 		if (cell._formula != undefined)
            // 			result['f'] = cell._formula;
            // 		if (callback)
            // 			return callback(result)
            // 		else
            // 			return result;
            // 	}
            // 	else if (this.grid['onDisplayCell']) {
            // 		let disp = {
            // 			'button': cell._button,
            // 			'checkBox': cell._checkBox,
            // 			'col': cell._col,
            // 			'color': cell._color,
            // 			'dataType': cell._dataType,
            // 			'font': {},
            // 			'formula': cell._formula,
            // 			'horizontalAlign': cell._horizontalAlign,
            // 			'html': cell._html,
            // 			'image': cell._image,
            // 			'object': cell._object,
            // 			'readOnly': cell._readOnly,
            // 			'row': cell._row,
            // 			'text': cell._text,
            // 			'value': cell._value,
            // 			'visible': cell._visible
            // 		}
            // 		try {
            // 			this.grid['onDisplayCell'](this['__this'], disp);
            // 			let value = disp.value;
            // 		} catch(e) {
            // 			let value = '';
            // 		}
            // 	} 
            // 	else
            // 		let value = cell._value;
            // 	if (value != undefined){// || cell._formula != undefined){				
            // 		let grid = this.grid
            // 		if (grid.columns)
            // 			let column = grid.columns.getColumn(aCol);				
            // 		if (column){
            // 			if (column && (column._type == 'lookupDetail')){							
            // 				if (cell._record)
            // 					let rd = cell._record
            // 				else{
            // 					let record = this.getObject(0, aRow);
            // 					if (record){
            // 						let rs = record[column._lookupTable]
            // 						if (rs){
            // 							let rd = rs['first'];									
            // 							cell._field = column._lookupField;
            // 							let v1 = column._lookupDetailValue;
            // 							switch (column._lookupDetailType){
            // 								case 'date':
            // 									v1 = new Date(v1)
            // 									v1.setHours(0,0,0,0);
            // 									break;
            // 								case 'numeric':
            // 									if (typeof(v1) == 'string')
            // 										v1 = parseFloat(v1);
            // 									break;
            // 							}
            // 							while (rd){
            // 								let v2 = rd[column._lookupField];
            // 								switch (column._lookupDetailType){
            // 									case 'date':
            // 										v2 = new Date(rd[column._lookupDetailField])
            // 										v2.setHours(0,0,0,0);
            // 										break;
            // 									case 'numeric':
            // 										if (typeof(v2) == 'string')
            // 											v2 = parseFloat(v2);
            // 										break;
            // 								}
            // 								if (v1 == v2)
            // 									break
            // 								else if (column._lookupDetailType == 'date' && v1.getTime() == v2.getTime())											
            // 									break
            // 								rd = rs['next']
            // 							}
            // 						}	
            // 					}									
            // 				}								
            // 				if (rd){
            // 					value = rd[column._lookupField];
            // 				}
            // 			}
            // 			else if (column._type == 'listOfValue' && column._listOfValue){
            // 				let lsv = grid.listOfValue[column._listOfValue];
            // 				if (lsv != undefined){
            // 					value = lsv[value] || value
            // 				}
            // 			}
            // 			else if (column._type == 'lookup' || column._type == 'lookupCombo'){							
            // 				if (!column._lookupContext)
            // 					let context = grid.context
            // 				else
            // 					let context = grid.parentForm[column._lookupContext];
            // 				if (context){								
            // 					let rs = context[column._lookupTable]
            // 					if (rs && value){									
            // 						let records = rs['_fetchRecordsByKeyValue']([value])									
            // 						if (records.length == 1){										
            // 							// let value = records[0][column._lookupField] || ''
            // 							if (value && (column._displayUserName)){
            // 								let name = application.userNameList[value];
            // 								if (name != undefined){
            // 									value = name || ''
            // 								}
            // 								else if (callback){
            // 									application.getUserNameList([value], function(){									
            // 										let name = application.userNameList[value];
            // 										value = name || ''
            // 										if (value != undefined)
            // 											result['v'] = value;
            // 										if (cell._formula != undefined)
            // 											result['f'] = cell._formula;
            // 										callback(result);
            // 									})
            // 									return;
            // 								}
            // 								else {
            // 									let name = application.userNameList[value];
            // 									value = name || ''
            // 									if (value != undefined)
            // 										result['v'] = value;
            // 									if (cell._formula != undefined)
            // 										result['f'] = cell._formula;
            // 									return result;
            // 								}	
            // 							}
            // 							else{
            // 								let fields = column._lookupField.split(' ');
            // 								let value = '';
            // 								for (let i = 0; i < fields.length; i ++){
            // 									if (value)
            // 										value += ' ' + (records[0][fields[i]] || '')
            // 									else
            // 										value = records[0][fields[i]] || ''
            // 								}
            // 								value =  value
            // 							}
            // 						}
            // 					}
            // 				}
            // 			}
            // 			else if (column && column._type == '{userAccount}'){
            // 				if (value){
            // 					let name = application.userNameList[value];
            // 					if (name != undefined)
            // 						value = name || ''
            // 					else if (callback){
            // 						application.getUserNameList([value], function(){		
            // 							result['v'] = application.userNameList[value] || ''
            // 							if (cell._formula != undefined)
            // 								result['f'] = cell._formula;
            // 							callback(result);
            // 						})
            // 						return;
            // 					}
            // 					else{
            // 						result['v'] = application.userNameList[value] || ''
            // 						if (cell._formula != undefined)
            // 							result['f'] = cell._formula;
            // 						return result;
            // 					}
            // 				}
            // 				else
            // 					value =  '';
            // 			}
            // 			else if (cell && cell._dataType == 4){
            // 				value = formatDateTimeStr(value);
            // 			}
            // 			else if (cell && cell._dataType == 2)
            // 				value = formatDateStr(value);
            // 			else if (column._dataType == 4 || column._type == 'dateTime'){							
            // 				value = formatDateTimeStr(value);
            // 			}
            // 			else if (column._dataType == 3 || column._type == 'time'){
            // 				value = formatTimeStr(value);
            // 			}
            // 			else if (column._dataType == 2 || column._type == 'date'){
            // 				value = formatDateStr(value);
            // 			}
            // 		}				
            // 		if (value != undefined)
            // 			result['v'] = value;
            // 		if (cell._formula != undefined)
            // 			result['f'] = cell._formula;				
            // 		if (callback)
            // 			callback(result)
            // 		else
            // 			return result;
            // 	}
            // 	else if (callback)
            // 		callback()
            // 	else
            // 		return;
            // }
        }
        ;
        getExcelValues(startCol, startRow, callback) {
            // let startCol = startCol || 0;
            // let startRow = startRow || 0;
            // let count = 0;
            // function datenum(v: number, date1904?: boolean) {
            // 	if (date1904)
            // 		v += 1462;
            // 	let epoch = Date.parse(v);
            // 	return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);
            // }
            // let ws = {};
            // let range = {
            // 	's': {
            // 		'c': 0,
            // 		'r': 0
            // 	},
            // 	'e': {
            // 		'c': this.grid.colCount - startCol - 1,
            // 		'r': this.grid.rowCount - startRow - 1
            // 	}
            // };	
            // let grid = this.grid;
            // let self = this;	
            // function getCellValues(row, col, callback){
            // 	if (row < grid.rowCount){
            // 		if (col < grid.colCount){
            // 			self.getExcelValue(col, row, function(cell){						
            // 				if(cell && col - startCol > -1 && row - startRow > -1){
            // 					let cell_ref = window['XLSX']['utils']['encode_cell']({
            // 						"c": col - startCol,
            // 						"r": row - startRow
            // 					});
            // 					if ( typeof cell['v'] === 'number')
            // 						cell['t'] = 'n';
            // 					else if ( typeof cell['v'] === 'boolean')
            // 						cell['t'] = 'b';
            // 					else if (cell['v'] instanceof Date) {
            // 						cell['t'] = 'n';
            // 						// cell['z'] = window['XLSX']['SSF._table'][14];
            // 						cell['v'] = datenum(cell['v']);
            // 					} else
            // 						cell['t'] = 's';
            // 					ws[cell_ref] = cell;
            // 				}	
            // 				count++
            // 				if (count > 1000)					
            // 					setTimeout(function(){
            // 						count = 0;
            // 						getCellValues(row, col+1, callback)
            // 					},0)
            // 				else
            // 					getCellValues(row, col+1, callback)
            // 			});						
            // 		}
            // 		else{
            // 			count ++
            // 			if (count > 1000)
            // 				setTimeout(function(){
            // 					getCellValues(row+1, 0, callback)
            // 				},0)
            // 			else
            // 				getCellValues(row+1, 0, callback)
            // 		}
            // 	}
            // 	else
            // 		callback()
            // }
            // getCellValues(startRow, startCol, function(){
            // 	ws['!ref'] = window['XLSX']['utils']['encode_range'](range);
            // 	let colWidths = [];
            // 	for (let col = startCol; col < grid.colCount; col ++){
            // 		colWidths.push({
            // 			'wpx': grid.getColWidth(col)
            // 		})
            // 	}
            // 	ws['!cols'] = colWidths;
            // 	callback(ws)
            // })			
        }
        ;
        getExcelValues1(startCol, startRow, callback) {
            // let startCol = startCol || 0;
            // let startRow = startRow || 0;
            // function datenum(v, date1904) {
            // 	if (date1904)
            // 		v += 1462;
            // 	let epoch = Date.parse(v);
            // 	return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);
            // }
            // let ws = {};
            // let range = {
            // 	's': {
            // 		'c': 0,
            // 		'r': 0
            // 	},
            // 	'e': {
            // 		'c': this.grid.colCount - startCol - 1,
            // 		'r': this.grid.rowCount - startRow - 1
            // 	}
            // };		
            // for (let row = 0; row < this.grid.rowCount; row++) {
            // 	for (let col = 0; col < this.grid.colCount; col++) {
            // 		let cell = this.getExcelValue(col, row);
            // 		if(!cell) continue;
            // 		let cell_ref = window['XLSX']['utils']['encode_cell']({
            // 			"c": col - startCol,
            // 			"r": row - startRow
            // 		});
            // 		if ( typeof cell['v'] === 'number')
            // 			cell['t'] = 'n';
            // 		else if ( typeof cell['v'] === 'boolean')
            // 			cell['t'] = 'b';
            // 		else if (cell['v'] instanceof Date) {
            // 			cell['t'] = 'n';
            // 			// cell['z'] = window['XLSX']['SSF._table'][14];
            // 			cell['v'] = datenum(cell['v']);
            // 		} else
            // 			cell['t'] = 's';
            // 		ws[cell_ref] = cell;
            // 	}
            // }
            // ws['!ref'] = window['XLSX']['utils']['encode_range'](range);
            // let colWidths = [];
            // for (let col = startCol; col < this.grid.colCount; col ++){
            // 	colWidths.push({
            // 		'wpx': this.grid.getColWidth(col)
            // 	})
            // }
            // ws['!cols'] = colWidths;
            // if (callback)
            // 	callback(ws)
            // else
            // 	return ws;
        }
        ;
        insertCol(aCol) {
            for (let r = 0; r < this.data.length; r++) {
                let row = this.data[r];
                if (row)
                    row.splice(aCol, 0, undefined);
            }
            this.updateCellIndex();
        }
        ;
        insertRow(aRow) {
            this.data.splice(aRow, 0, []);
            this.updateCellIndex();
        }
        ;
        loadFromJSON(json) {
            let data = json['data'];
            for (let i = 0; i < data.length; i++) {
                let row = data[i];
                for (let k = 0; k < row.length; k++) {
                    let cell = row[k];
                    if (cell)
                        this.setValue(k, i, cell['v']);
                }
            }
        }
        ;
        moveRow(fromIdx, toIdx) {
            if (toIdx < this.data.length) {
                this.data.splice(toIdx, 0, this.data.splice(fromIdx, 1)[0]);
                this.updateCellIndex();
            }
        }
        ;
        saveToJSON(json) {
            let data = [];
            json['data'] = data;
            for (let i = 0; i < this.data.length; i++) {
                let row = this.data[i];
                data[i] = [];
                for (let k = 0; k < row.length; k++) {
                    let cell = row[k];
                    if (cell)
                        data[i][k] = {
                            'v': cell._value
                        };
                }
            }
        }
        ;
        setDateValue(aCol, aRow, aValue) {
            let cell = this.getCell(aCol, aRow);
            cell._value = aValue;
            cell._isDate = true;
        }
        ;
        setMergeCell(rect) {
            for (let col = rect.startCol; col <= rect.endCol; col++)
                for (let row = rect.startRow; row <= rect.endRow; row++) {
                    let cell = this.getCell(col, row);
                    cell.mergeRect = rect;
                }
        }
        ;
        setObject(aCol, aRow, aObject) {
            let cell = this.getCell(aCol, aRow);
            cell.object = aObject;
        }
        ;
        setRowCount(value) {
            if (this.data.length > value)
                this.data.length = value;
        }
        ;
        setValue(aCol, aRow, aValue, disp) {
            let cell = this.getCell(aCol, aRow);
            if (!disp)
                cell._value = aValue;
            else
                cell._dispValue = aValue;
        }
        ;
        setFile(aCol, aRow, aValue) {
            let cell = this.getCell(aCol, aRow);
            cell._file = aValue;
        }
        ;
        sort(col, descending) {
            let fixedRow = this.data.slice(0, this.grid.fixedRow);
            let data = this.data.slice(this.grid.fixedRow);
            for (let i = 0; i < data.length; i++) {
                if (data[i] && data[i][col])
                    data[i][col]._idx = i;
            }
            ;
            let self = this;
            data.sort(function (item1, item2) {
                if (self.grid['onSort']) {
                    if (item1[col] && item2[col])
                        return self.grid['onSort'](self.grid, descending, col, item1[col]._row, item2[col].row);
                    else if (item1[col]) {
                        if (descending)
                            return -1;
                        else
                            return 1;
                    }
                    else {
                        if (descending)
                            return 1;
                        else
                            return -1;
                    }
                }
                else {
                    let value1;
                    let value2;
                    let idx1 = 0;
                    let idx2 = 0;
                    ;
                    if (item1[col]) {
                        value1 = item1[col]._displayValue || item1[col]._value;
                        idx1 = item1[col]._idx;
                    }
                    if (value1 == undefined)
                        value1 = '';
                    if (item2[col]) {
                        value2 = item2[col]._displayValue || item2[col]._value;
                        idx2 = item2[col]._idx;
                    }
                    if (value2 == undefined)
                        value2 = '';
                    if (typeof (value1) == 'string')
                        value1 = value1.toLowerCase();
                    if (typeof (value2) == 'string')
                        value2 = value2.toLowerCase();
                    if (value1 == value2)
                        return idx1 > idx2 ? 1 : idx1 < idx2 ? -1 : 0;
                    else if (value1 > value2)
                        return (descending ? -1 : 1);
                    else
                        return (descending ? 1 : -1);
                }
            });
            this.data = fixedRow.concat(data);
            this.updateCellIndex();
        }
        ;
        updateCellIndex() {
            for (let r = 0; r < this.data.length; r++) {
                let row = this.data[r];
                for (let c = 0; c < row.length; c++) {
                    let cell = this.data[r][c];
                    if (cell) {
                        cell._col = c;
                        cell._row = r;
                    }
                    ;
                }
                ;
            }
            ;
        }
        ;
    }
    ;
    class TGridColumn {
        constructor(grid, colIdx) {
            this._visible = true;
            this._resizable = true;
            this._sortable = true;
            this._readOnly = false;
            this.grid = grid;
            this._colIdx = colIdx;
            if (!this._type)
                this._type = "string";
        }
        ;
        get asJSON() {
            return {
                "color": (this._color && this._color != 'clNone') ? this._color : undefined,
                "horizontalAlign": (this._horizontalAlign != undefined && this._horizontalAlign != 1) ? this._horizontalAlign : undefined,
                "type": (this._type && this._type != 'string') ? this._type : undefined,
                "width": this.width,
                "readOnly": this._readOnly ? this._readOnly : undefined,
                "visible": !this._visible ? this._visible : undefined,
                "resizable": !this._resizable ? this._resizable : undefined,
                "lookupContext": this._lookupContext ? this._lookupContext : undefined,
                "lookupTable": this._lookupTable ? this._lookupTable : undefined,
                "suggestTable": this._suggestTable ? this._suggestTable : undefined,
                "lookupField": this._lookupField ? this._lookupField : undefined,
                "lookupDetailField": this._lookupDetailField ? this._lookupDetailField : undefined,
                "lookupDetailValue": this._lookupDetailValue ? this._lookupDetailValue : undefined,
                "lookupDetailType": this._lookupDetailType ? this._lookupDetailType : undefined,
                "listOfValue": this._listOfValue ? this._listOfValue : undefined,
                "format": this._format ? this._format : undefined,
                "formula": this._formula ? this._formula : undefined,
                "displayUserName": this._displayUserName,
                "binding": this._binding
            };
        }
        ;
        set asJSON(value) {
            this._color = value.color;
            this._horizontalAlign = value['horizontalAlign'] != undefined ? value['horizontalAlign'] : value['alignment'];
            this._type = value['type'] || value['dataType'];
            this._readOnly = value['readOnly'];
            this._visible = value['visible'];
            this._resizable = value['resizable'];
            this._lookupContext = value['lookupContext'];
            this._lookupTable = value['lookupTable'];
            this._lookupField = value['lookupField'];
            this._suggestTable = value['suggestTable'];
            this._lookupDetailField = value['lookupDetailField'];
            this._lookupDetailValue = value['lookupDetailValue'];
            this._lookupDetailType = value['lookupDetailType'];
            this._listOfValue = value['listOfValue'];
            this._displayUserName = value['displayUserName'];
            this._format = value['format'];
            this._formula = value['formula'];
            this._binding = value['binding'];
            // switch (this._horizontalAlign){
            // 	case 'center':
            // 		this._horizontalAlign = 0;
            // 		break;
            // 	case 'left':
            // 		this._horizontalAlign = 1;
            // 		break;
            // 	case 'right':
            // 		this._horizontalAlign = 2;
            // 		break;
            // }
            if (value['width'] != undefined)
                this["width"] = value['width'];
            // if (value['caption'] != undefined)
            // 	this.grid.setValue(value['colIdx'], 0, value['caption'])			
            if (value['rows'] && value['rows'] > 1)
                this._rows = value['rows'];
            this.grid.enableUpdateTimer();
        }
        ;
        get binding() {
            return this._binding;
        }
        ;
        set binding(value) {
            this._binding = value;
        }
        ;
        get colIdx() {
            return this._colIdx;
        }
        ;
        set colIdx(value) {
            if (this.colIdx > -1)
                this.grid.columns[this.colIdx] = null;
            this._colIdx = value;
            this.grid.columns[value] = this;
            this.grid.enableUpdateTimer();
        }
        ;
        get color() {
            return this._color || 'clNone';
        }
        ;
        set color(value) {
            this._color = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get comboItems() {
            return this._comboItems;
        }
        set comboItems(value) {
            this._comboItems = value;
            this.grid.enableUpdateTimer();
        }
        get default() {
            return (!this._color || this._color == 'clNone') &&
                (this._horizontalAlign == undefined || this._horizontalAlign == 1) &&
                (!this._type || this._type == 'string') &&
                !this._readOnly &&
                this._visible &&
                (!this._dataType) &&
                this._resizable &&
                !this._lookupContext &&
                !this._lookupTable &&
                !this._lookupField &&
                !this._listOfValue;
        }
        ;
        get format() {
            return this._format;
        }
        ;
        set format(value) {
            this._format = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get formula() {
            return this._formula;
        }
        ;
        set formula(value) {
            this._formula = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get horizontalAlign() {
            return this._horizontalAlign || 1;
        }
        ;
        set horizontalAlign(value) {
            this._horizontalAlign = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get readOnly() {
            return this._readOnly;
        }
        ;
        set readOnly(value) {
            this._readOnly = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get resizable() {
            return this._resizable !== false;
        }
        ;
        set resizable(value) {
            this._resizable = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get sortable() {
            return this._sortable !== false;
        }
        ;
        set sortable(value) {
            this._sortable = value;
        }
        ;
        get type() {
            return this._type;
        }
        ;
        set type(value) {
            this._type = value;
            switch (value) {
                case "checkBox":
                    this._dataType = "boolean";
                    break;
                case "comboBox":
                    this._dataType = "string";
                    break;
                case "datePicker":
                    this._dataType = "date";
                    break;
                case "dateTimePicker":
                    this._dataType = "dateTime";
                    break;
                case "integer":
                    this._dataType = "integer";
                    break;
                case "number":
                    this._dataType = "number";
                    break;
                case "string":
                    this._dataType = "string";
                    break;
                case "timePicker":
                    this._dataType = "time";
                    break;
                default:
                    this._dataType = "string";
                    break;
            }
            this.grid.enableUpdateTimer();
        }
        ;
        get dataType() {
            return this._dataType;
        }
        ;
        get visible() {
            return this._visible !== false;
        }
        ;
        set visible(value) {
            this._visible = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get width() {
            return this.grid.getColWidth(this._colIdx);
        }
        ;
        set width(value) {
            this.grid.setColWidth(this._colIdx, value);
            this.grid.enableUpdateTimer();
        }
        ;
    }
    ;
    class TGridColumns {
        constructor(grid) {
            this.columns = [];
            this.grid = grid;
        }
        ;
        // assign(option: any) {
        // 	this.columns = [];
        // 	for (let i = 0; i < option.length; i++) {
        // 		let item = option[i];
        // 		let col = this.getColumn(item.col);
        // 		col.checkBox = item['checkBox'] || item['checkBox'] == 'Y';
        // 	};		
        // 	this.count = this.columns.length;
        // 	this.grid.colCount = this.count;
        // };
        clear() {
            // for (let i = 0; i < this.columns.length; i++)
            // if (this.columns[i])
            // this.columns[i].grid = null;
            this.columns = [];
        }
        ;
        deleteCol(aCol) {
            this.columns.splice(aCol, 1);
            this.updateColIndex();
        }
        ;
        getColumn(index) {
            if (index > this.columns.length) {
                let len = this.columns.length;
                for (let i = len; i <= index; i++)
                    this.columns.push('');
            }
            let col = this.columns[index];
            if (!col) {
                col = new TGridColumn(this.grid, index);
                this.columns[index] = col;
            }
            return col;
        }
        ;
        insertCol(colIdx) {
            let col = new TGridColumn(this.grid, colIdx);
            this.columns.splice(colIdx, 0, col);
            this.updateColIndex();
        }
        ;
        loadFromJSON(value) {
            this.count = value.length;
            for (let i = 0; i < value.length; i++) {
                if (value[i]) {
                    let col = this.getColumn(i);
                    if (value[i]['colIdx'] == undefined)
                        value[i]['colIdx'] = i;
                    col['asJSON'] = value[i];
                }
            }
            this.grid.colCount = this.count;
        }
        ;
        _loadFromJSON(value) {
            this.loadFromJSON(value);
        }
        ;
        saveToJSON() {
            let result = [];
            let withValue = false;
            for (let i = 0; i < this.columns.length; i++) {
                if (this.columns[i] && !this.columns[i]['default']) {
                    withValue = true;
                    result.push(this.columns[i]['asJSON']);
                }
                else
                    result.push('');
            }
            if (withValue)
                return result;
        }
        ;
        setColCount(value) {
            this.columns.length = value;
        }
        ;
        updateColIndex() {
            for (let i = 0; i < this.columns.length; i++)
                this.columns[i]._colIdx = i;
        }
        ;
    }
    ;
    class TGridRow {
        constructor(grid) {
            this._visible = true;
            this._resizable = false;
            this.grid = grid;
            if (!this._type)
                this._type = "string";
        }
        ;
        get color() {
            return this._color;
        }
        ;
        set color(value) {
            this._color = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get comboItems() {
            return this._comboItems;
        }
        set comboItems(value) {
            this._comboItems = value;
            this.grid.enableUpdateTimer();
        }
        get height() {
            return this._height;
        }
        ;
        set height(value) {
            this._height = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get readOnly() {
            return this._readOnly;
        }
        ;
        set readOnly(value) {
            this._readOnly = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get resizable() {
            return this._resizable;
        }
        ;
        set resizable(value) {
            this._resizable = value;
            this.grid.enableUpdateTimer();
        }
        ;
        get type() {
            return this._type;
        }
        ;
        set type(value) {
            this._type = value;
            switch (value) {
                case "checkBox":
                    this._dataType = "boolean";
                    break;
                case "comboBox":
                    this._dataType = "string";
                    break;
                case "datePicker":
                    this._dataType = "date";
                    break;
                case "dateTimePicker":
                    this._dataType = "dateTime";
                    break;
                case "integer":
                    this._dataType = "integer";
                    break;
                case "number":
                    this._dataType = "number";
                    break;
                case "string":
                    this._dataType = "string";
                    break;
                case "timePicker":
                    this._dataType = "time";
                    break;
                default:
                    this._dataType = "string";
                    break;
            }
            this.grid.enableUpdateTimer();
        }
        ;
        get dataType() {
            return this._dataType;
        }
        ;
        get visible() {
            return this._visible;
        }
        ;
        set visible(value) {
            this._visible = value;
            this.grid.enableUpdateTimer();
        }
        ;
    }
    ;
    class TGridRows {
        constructor(grid, defaultHeight) {
            this.rows = [];
            this.grid = grid;
            this.defaultHeight = defaultHeight;
        }
        ;
        clear() {
            this.rows = [];
        }
        ;
        getHeight(index) {
            let row = this.rows[index];
            if (row)
                return row.height;
            else
                return this.defaultHeight;
        }
        ;
        getRow(index) {
            let row = this.rows[index];
            if (!row) {
                row = new TGridRow(this.grid);
                this.rows[index] = row;
            }
            ;
            return row;
        }
        ;
    }
    ;
    // export type GridMode = 'vertical'|'horizontal';
    let DataGrid = class DataGrid extends base_1.Control {
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        ;
        constructor(parent, options) {
            super(parent, options);
            this._listOfValue = {};
            this._defaultRowHeight = 19;
            this._defaultColWidth = 64;
            this._layout = 'grid';
            this.mergeRect = [];
            this.tableCells = [[]];
            this.tableSplitters = [];
            this.selectedCells = [];
            this.selectedCellsHighlight = [];
            // private _mode: GridMode; // = "horizontal";// "vertical";
            this._colCount = 3;
            this._rowCount = 3;
            this.colWidths = [];
            this._rowHeights = [];
            this._fixedCol = 0;
            this._fixedRow = 1;
            this._leftCol = 0;
            this._topRow = 1;
            this._row = 0;
            this._col = 0;
            this._scrollLeft = 0;
            this._scrollTop = 0;
            // private updateRowHeightFlag = false;
            // private updateColWidthFlag = false;
            this.showDataInternalFlag = false;
            // private updateTimerCounter = 0;
            // private updateCounter = 0;
            this._sorting = false;
            this._updateTableInternalFlag = false;
            this._totalColWidth = 0;
            this._totalRowHeight = 0;
            this.visibleRowCount = 0;
            this.visibleColCount = 0;
            this.sortingDescending = false;
            // setTimeout(()=>{
            //     this._init();
            // }, 100);
        }
        ;
        get fixedCol() {
            return this._fixedCol;
        }
        ;
        set fixedCol(value) {
            this._fixedCol = value;
            if (this._leftCol < this._fixedCol)
                this._leftCol = this._fixedCol;
        }
        ;
        get fixedRow() {
            return this._fixedRow;
        }
        ;
        set fixedRow(value) {
            this._fixedRow = value;
            if (this._topRow < this._fixedRow)
                this._topRow = this._fixedRow;
        }
        get layout() {
            return this._layout;
        }
        ;
        set layout(value) {
            this._layout = value;
        }
        ;
        async init() {
            await super.init();
            this._init();
        }
        _init() {
            // this._mode = this.getAttribute('mode', true);
            // if (!this.mode)
            // 	this._mode = "vertical";
            // if (this._mode == "vertical") {
            this._fixedCol = 0;
            this._fixedRow = 1;
            this._leftCol = 0;
            this._topRow = 1;
            // } else if (this._mode == "horizontal") {
            // 	this._fixedCol = 1;
            // 	this._fixedRow = 0;
            // 	this._leftCol = 1;
            // 	this._topRow = 0;
            // } else {
            // 	this._fixedCol = 0;
            // 	this._fixedRow = 0;
            // 	this._leftCol = 0;
            // 	this._topRow = 0;
            // }
            this.options = new TGridOptions(this);
            // this.cardViewOptions = new TGridCardViewOptions(this);
            // let container = createElement(this, 'div');
            this.placeHolder = this.createElement('div', this);
            this._table = this.createElement('table', this);
            this.data = new DataGridCells(this);
            // this.dataBinding = {};
            // this.dataBindingAuto = true;
            this.columns = new TGridColumns(this); //, this.defaultColWidth);
            this.gridRows = new TGridRows(this, this._defaultRowHeight);
            this.cellHighlight = this.createElement('div', this);
            this.placeHolder.style.position = 'absolute';
            this.cellHighlight.className = 'grid_curr_cell';
            this.cellHighlight.style.position = 'absolute';
            this.cellHighlight.style.display = 'none';
            this.cellHighlight.style.zIndex = '3';
            // this.cellHighlight.style.border = '2px solid black';
            this.selectedRangeHighlight = this.createElement('div', this);
            this.selectedRangeHighlight.className = 'grid_selected_cell';
            this.selectedRangeHighlight.style.position = 'absolute';
            this.selectedRangeHighlight.style.display = 'none';
            this.selectedRangeHighlight.style.zIndex = '3';
            this._table.className = 'grid';
            this._table.style.tableLayout = 'fixed';
            this._table.style.position = 'relative';
            // table.style.top = '-1px';
            this.tableContainer = this.createElement('div', this);
            this.tableContainer.className = 'container';
            // this.tableContainer.style.overflow = 'hidden'
            // this.tableContainer.style.width = '100%';
            // this.tableContainer.style.height = '100%';
            this.tableContainer.appendChild(this._table);
            this._scrollBox = this.createElement('div', this);
            this._scrollBox.className = 'scrollBox';
            // this._scrollBox.style.position = 'absolute';
            // this._scrollBox.style.top = '0px';
            this._scrollBox.tabIndex = 0;
            // this._scrollBox.style.zIndex = '4'
            this._scrollBox.appendChild(this.placeHolder);
            this.edit = this.createElement('input', this);
            this.edit.setAttribute('autocomplete', 'disabled');
            this.edit.className = 'grid_edit';
            // this.edit.owner = this;
            // this.table.owner = this;
            // this.placeHolder.owner = this;
            this.edit.style.border = '0px';
            this.edit.style.width = '10px';
            this.edit.style.height = '10px';
            this.edit.style.position = 'absolute';
            this.edit.style.top = '-100px';
            this.edit.style.left = '-100px';
            // this['font'] = new TFont(this);
            // this['font']['size'] = 12;
            // this.eventOptions.bindDblClick = true;
            this.style.overflow = 'hidden';
            this.style.backgroundColor = '#FFFFFF';
            this._height = 89;
            this._width = 324;
            this.colWidths = [];
            // this.colWidths[0] = 10;
            this._scrollLeft = 0;
            this._scrollTop = 0;
            this._scrollBox.addEventListener('mousewheel', (event) => {
                // abortEvent(event)	
                console.dir(event);
                let delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));
                this._handleMouseWheel(event, delta);
            });
            this._handleInput = this._handleInput.bind(this);
            this._handleDragOver = this._handleDragOver.bind(this);
            this._handleFileDrop = this._handleFileDrop.bind(this);
            this.edit.addEventListener('input', this._handleInput);
            this.edit.addEventListener('propertychange', this._handleInput);
            this.addEventListener('dragover', this._handleDragOver);
            this.addEventListener('drop', this._handleFileDrop);
            this._scrollBox.onscroll = this._handleScroll.bind(this);
            // this._updateTable();		
            this.setCurrCell(this._fixedCol, this._fixedRow);
            this._updateLanguage();
            this._updateListOfValues();
            this.enableUpdateTimer(true, true);
        }
        ;
        calcTopRow(rowIdx) {
            if (rowIdx == this._fixedRow)
                return rowIdx;
            let row = rowIdx;
            let height = this._scrollBox.clientHeight; // this.heightValue;
            if (this.layout == 'card') {
                // row = rowIdx - Math.floor(height / this._cardHeight);
                // if (row <= this.fixedRow)
                // 	row = this.fixedRow;
            }
            else {
                for (let i = 0; i < this._fixedRow; i++)
                    height = height - this.getRowHeight(i) - 0.8;
                height = height - this.getRowHeight(row);
                while (row > this._fixedRow) {
                    // try {
                    let h = this.getRowHeight(row) + 0.8;
                    height = height - h;
                    if (height < h - 4) {
                        return row - 1;
                    }
                    ;
                    row--;
                    // } catch(err) {
                    // 	return row;
                    // }
                }
            }
            return row;
        }
        ;
        cells(aCol, aRow, refresh) {
            return this.data.getCell(aCol, aRow, refresh);
        }
        ;
        get col() {
            return this._col;
        }
        ;
        set col(value) {
            this._col = value;
        }
        ;
        get row() {
            return this._row;
        }
        ;
        set row(value) {
            this._row = value;
        }
        get colCount() {
            return this._colCount;
        }
        ;
        set colCount(value) {
            this._colCount = value;
            this.enableUpdateTimer(false, true);
        }
        ;
        // get currCell(): HTMLTableCellElement | undefined{
        //     return this._currCell;
        // };
        // set currCell(value: HTMLTableCellElement | undefined){
        //     this._currCell = value;
        // };
        // get mode(): GridMode{
        // 	return this._mode;
        // }
        // set mode(value: GridMode){
        // 	this._mode = value;
        // 	this.init();
        // }
        get readOnly() {
            return this._readOnly;
        }
        ;
        set readOnly(value) {
            this._readOnly = value;
        }
        ;
        get rowCount() {
            return this._rowCount;
        }
        ;
        set rowCount(value) {
            this._rowCount = value;
            this.enableUpdateTimer(true, false);
        }
        ;
        get topRow() {
            return this._topRow;
        }
        ;
        set topRow(value) {
            this._topRow = value;
        }
        ;
        _updateRowHeights(row) {
            let height = this._defaultRowHeight;
            for (let col = 0; col < this._colCount; col++) {
                let cell = this.data.cells(col, row);
                if (cell && cell._height && cell._height > height) {
                    height = cell._height;
                }
            }
            ;
            this._rowHeights[row] = height;
            this._updateTotalRowHeight();
            return height;
        }
        ;
        setObject(aCol, aRow, aObject) {
            if (this.data)
                this.data.setObject(aCol, aRow, aObject);
        }
        ;
        setJSONValue(value, prop, newValue) {
            let obj;
            try {
                if (value)
                    obj = JSON.parse(value);
                else
                    obj = {};
            }
            catch (err) {
                obj = {};
            }
            obj[prop] = newValue;
            return JSON.stringify(obj);
        }
        ;
        updateBindingData(cell, column) {
            column = column || this.columns.getColumn(cell._col);
            if (column && column.binding) {
                let obj = this.getObject(0, cell._row);
                if (!obj) {
                    obj = {};
                    this.setObject(0, this._row, obj);
                }
                obj[column.binding] = cell._value;
            }
        }
        ;
        _updateCurrCellValue(editor) {
            console.dir('### _updateCurrCellValue');
            let cardViewEditor = false;
            if (editor)
                cardViewEditor = true;
            if (this.editorMode || this._cardPanel) {
                let oldValue = this.data.getValue(this._col, this._row);
                editor = editor || this.editor;
                if (!editor || editor._isModified === false)
                    return;
                // if (typeof(TDateTimePicker) != 'undefined' && (editor instanceof DatePicker))
                // 	let newValue = editor.date
                // else 
                let cell = this.data.getCell(this._col, this._row);
                // let rowOrColDataType = (this.mode == "vertical")? this.cols(this._col).dataType : this.rows(this._row).dataType;
                // let rowOrColType = (this.mode == "vertical")? this.cols(this._col).type : this.rows(this._row).type;
                let rowOrColDataType = this.cols(this._col).dataType;
                let rowOrColType = this.cols(this._col).type;
                if (rowOrColDataType == "boolean" && rowOrColType == "checkBox") {
                    cell._value = editor.checked;
                }
                else if (rowOrColDataType == "date" && rowOrColType == "datePicker") {
                    cell._value = editor.value;
                }
                else if (rowOrColDataType == "dateTime" && rowOrColType == "dateTimePicker") {
                    cell._value = editor.value;
                }
                else if (rowOrColDataType == "time" && rowOrColType == "timePicker") {
                    cell._value = editor.value;
                }
                else if (rowOrColDataType == "string" && rowOrColType == "comboBox") {
                    cell._value = (editor.selectedItem)?.value;
                }
                else if (rowOrColDataType == "number" && rowOrColType == "number") {
                    cell._value = parseFloat(editor.value);
                }
                else if (rowOrColDataType == "integer" && rowOrColType == "integer") {
                    cell._value = parseInt(editor.value);
                }
                else {
                    let newValue;
                    if (editor.valueCode)
                        newValue = editor.valueCode;
                    else if (editor.getText)
                        newValue = editor.getText();
                    else
                        newValue = application_1.application.xssSanitize(editor.value);
                    let text = '';
                    if (editor.getText)
                        text = editor.getText();
                    else
                        text = newValue;
                    if (cell.mergeRect && (this._col != cell.mergeRect.startCol || this._row != cell.mergeRect.startRow))
                        cell = this.data.getCell(cell.mergeRect.startCol, cell.mergeRect.startRow);
                    if (true /*!this._cardPanel*/) {
                        if (this.options._autoRowHeight) {
                            let div = this._currCell.div;
                            div.textContent = text;
                            let height = div.clientHeight + 3;
                            if (cell.mergeRect) {
                                height = height / (cell.mergeRect.endRow - cell.mergeRect.startRow + 1);
                                for (let i = cell.mergeRect.startRow; i <= cell.mergeRect.endRow; i++) {
                                    // let c = this.data.cells(cell.startCol, i);
                                    cell._height = height;
                                    this._updateRowHeights(i);
                                }
                            }
                            else {
                                cell._height = height;
                                this._updateRowHeights(this._row);
                            }
                        }
                        else
                            this._currCell.div.textContent = text;
                    }
                    cell._value = newValue;
                    this.origValue = undefined;
                    if (!cardViewEditor)
                        this.enableUpdateTimer();
                    if (cell._field) {
                        if (!cell._record) {
                            let column = this.columns.getColumn(cell._col);
                            let record = this.getObject(0, cell._row);
                            let rs = record[cell._lookupTable];
                            cell._record = rs.append();
                            let v = column._lookupDetailValue;
                            switch (column._lookupDetailType) {
                                case 'date':
                                    v = new Date(v);
                                    v.setHours(0, 0, 0, 0);
                                    break;
                                case 'numeric':
                                    if (typeof (v) == 'string')
                                        v = parseFloat(v);
                                    break;
                            }
                            ;
                            cell._record[column._lookupDetailField] = v;
                        }
                        cell._record[cell._field] = newValue;
                    }
                    else if (this._dataBindingContext) {
                        let record = this.getObject(0, this._row);
                        let field = this.getObject(this._col, 0);
                        let idx = 0;
                        let jsonValue;
                        if (typeof (field) == 'number') {
                            idx = field;
                            field = this.dataBinding['fields'][idx];
                            if (this.dataBinding['jsonValues'])
                                jsonValue = this.dataBinding['jsonValues'][idx];
                        }
                        this.data.getCell(0, this._row)._newRow = false;
                        // let idx = this.dataBinding['fields'].indexOf(field)
                        let fieldType = this.dataBinding['fieldTypes'][idx];
                        if (fieldType == 'float')
                            newValue = parseNumber(newValue);
                        else if (fieldType == 'integer')
                            newValue == Math.round(parseNumber(newValue));
                        else if (editor && editor['dataType'] == 'dtNumber')
                            newValue = parseNumber(newValue);
                        if (!record && field) {
                            record = this._dataBindingContext['append']();
                            this.setObject(0, this._row, record);
                        }
                        if (record && field) {
                            if (jsonValue)
                                newValue = this.setJSONValue(record[field], jsonValue, newValue);
                            if (record[field] != newValue)
                                record[field] = newValue;
                        }
                        if (true /*!cardViewEditor*/)
                            this.enableUpdateTimer();
                    }
                    this.updateBindingData(cell);
                    if (this.onCellChange)
                        this.onCellChange(this, cell, oldValue, newValue);
                }
                this.enableUpdateTimer();
            }
            ;
        }
        ;
        hideEditor(updateValue) {
            this.edit.value = '';
            if (updateValue && this.editor && this.editor['dataType'] == 'dtUserAccount') {
                let editor = this.editor;
                editor['dataType'] = '';
                this.editor = null;
                let self = this;
                // application['get']('/admin/service/userInfo.tsp', {
                // 	"userID": [editor.text]
                // }, function (result) {
                // 	self.editor = editor;
                // 	if (result && Array.isArray(result['data']) && result['data']['length'] > 0)
                // 		self.editor.text = result['data'][0]['guid']
                // 	self.hideEditor(updateValue)			
                // })			
                return;
            }
            if (updateValue && this.editor && this.editor['dataType'] == 'dtFile')
                updateValue = false;
            else if (this.editor && this.editor.buildInEditor && this.editor['dataType'] == 'dtLookup') {
                this.editor['onChange'] = undefined;
                this.editor.hide(updateValue);
            }
            if (updateValue)
                this._updateCurrCellValue();
            // globalEvents.editor = undefined;
            // if (this.editLookup)
            // 	this.editLookup['setVisible'](false);
            if (this.editor) {
                this.editorMode = false;
                let editor = this.editor;
                this.editor = undefined;
                this.removeChild(editor);
                // if (editor.buildInEditor) {
                // editor.free();
                // } else {
                // 	editor['setVisible'](false);
                // }			
                this.edit.removeEventListener('propertychange', this._handleInput);
                this.edit.removeEventListener('input', this._handleInput);
                this.edit.value = '';
                this.edit.addEventListener('propertychange', this._handleInput);
                this.edit.addEventListener('input', this._handleInput);
                this.focus();
                this.edit.focus();
                if (this.onEditModeChanged)
                    this.onEditModeChanged(this);
            }
            ;
        }
        ;
        checkEmptyRow(row) {
            let cell = this.data.getCell(0, row);
            if (cell._newRow != undefined)
                return cell._newRow;
            for (let i = 0; i < this._colCount; i++) {
                if (this.data.getValue(i, row) != '' && this.data.getValue(i, row) != undefined) {
                    return false;
                }
            }
            return true;
        }
        ;
        setRowCount(aRowCount) {
            if (this._rowCount != aRowCount) {
                this._rowCount = aRowCount;
                if (this._row >= this._rowCount || this._row < this._fixedRow)
                    this._row = this._fixedRow;
                this.data.setRowCount(aRowCount);
                this.refresh();
                this.enableUpdateTimer(true);
            }
        }
        ;
        refresh() {
            super.refresh();
            this.highlightCurrCell();
            // if (this.autoHeight){
            // 	this['height'] = this.rowCount * (this.defaultRowHeight)
            // 	this.container.style.height = 'auto';//100%';
            // 	this._scrollBox.style.height = '100%';
            // }
            // else{
            // 	this.container.style.height = this['height'] + 'px';
            // 	this._scrollBox.style.height = this['height'] + 'px'
            // }
            // if (this.autoWidth)
            // 	this.container.style['width'] = '100%'
            // else
            // 	this.container.style['width'] = this['width'] + 'px';
            // this.container.style['height'] = this['height'] + 'px';
            if (this._scrollBox) {
                this._scrollBox.style.height = this.heightValue + 'px';
                this._scrollBox.style.width = this.widthValue + 'px';
            }
            ;
            // this.enableUpdateTimer();
        }
        ;
        deleteRow(row) {
            if (this._dataBindingContext && this._dataBindingContext['readOnly'])
                return;
            this.data.deleteRow(row);
            if (this._rowHeights.length > row)
                this._rowHeights.splice(row, 1);
            this.setRowCount(this._rowCount - 1);
            if (this._dataBindingContext) {
                let record = this.getObject(0, this._row);
                if (record && this._dataBindingContext['current'] !== record) {
                    if (this._bindingRecordSet)
                        this._bindingRecordSet['current'] = record;
                    this._dataBindingContext['current'] = record;
                }
            }
            ;
            this.enableUpdateTimer();
        }
        ;
        getObject(aCol, aRow) {
            return this.data.getObject(aCol, aRow);
        }
        ;
        getValue(col, row) {
            return this.data.getValue(col, row);
        }
        ;
        setScrollLeft() {
            console.dir('#setScrollLeft');
            this._scrollBox.onscroll = null;
            clearTimeout(this._restScrollboxHandler);
            clearTimeout(this._setScrollLeftInterval);
            this._setScrollLeftInterval = setTimeout(() => {
                this.setScrollLeftInternal();
                this._restScrollboxHandler = setTimeout(() => {
                    this._scrollBox.onscroll = this._handleScroll.bind(this);
                }, 10);
            }, 10);
        }
        ;
        setScrollLeftInternal() {
            if (this._leftCol == this._fixedCol) {
                this._scrollBox.scrollLeft = 0;
                this._scrollLeft = this._scrollBox.scrollLeft;
            }
            else {
                let w = 0;
                for (let i = 0; i < this._fixedCol; i++)
                    w = w + this.getColWidth(i) + 0.8;
                for (let i = this._leftCol; i < this._colCount; i++)
                    w = w + this.getColWidth(i) + 0.8;
                this._scrollBox.scrollLeft = this._scrollBox.scrollWidth - w;
                this._scrollLeft = this._scrollBox.scrollLeft;
            }
            ;
        }
        ;
        setScrollTop() {
            this._scrollBox.onscroll = null;
            clearInterval(this._restScrollboxHandler);
            clearInterval(this._setScrollTopInterval);
            this._setScrollTopInterval = setTimeout(() => {
                this.setScrollTopInternal();
                this._restScrollboxHandler = setTimeout(() => {
                    this._scrollBox.onscroll = this._handleScroll.bind(this);
                }, 10);
            }, 10);
        }
        ;
        setScrollTopInternal() {
            console.dir('setScrollTopInternal');
            if (this._topRow == this._fixedRow) {
                this._scrollBox.scrollTop = 0;
                this._scrollTop = this._scrollBox.scrollTop;
            }
            if (this.layout == 'card') {
                // let h = this.topRow * this._cardHeight;
                // this.scrollTop = h;
                // this._scrollBox.scrollTop = this.scrollTop;
                // this._updateCardPanelTop();						
            }
            else {
                let h = 0;
                for (let i = 0; i < this._fixedRow; i++)
                    h = h + this.getRowHeight(i) + 0.8;
                for (let i = this._topRow; i < this._rowCount; i++)
                    h = h + this.getRowHeight(i) + 0.8;
                this._scrollBox.scrollTop = this._scrollBox.scrollHeight - h;
                this._scrollTop = this._scrollBox.scrollTop;
            }
            ;
        }
        ;
        setLeftCol(aLeftCol, skipSetScroll) {
            if (aLeftCol != this._leftCol) {
                if (this.editorMode) {
                    this.hideEditor(true);
                }
                ;
                if (aLeftCol < this._fixedCol)
                    this._leftCol = this._fixedCol;
                else if (aLeftCol >= this._colCount)
                    this._leftCol = this._colCount - 1;
                else
                    this._leftCol = aLeftCol;
                this.showData(100);
                if (!skipSetScroll)
                    this.setScrollLeft();
                this.enableUpdateTimer();
            }
        }
        ;
        setTopRow(row, skipSetScroll) {
            if (row != this._topRow) {
                if (this.editorMode) {
                    this.hideEditor(true);
                }
                ;
                if (row < this._fixedRow)
                    this._topRow = this._fixedRow;
                else if (row >= this._rowCount)
                    this._topRow = this._rowCount - 1;
                else
                    this._topRow = row;
                this.showData(100);
                if (!skipSetScroll)
                    this.setScrollTop();
                this.enableUpdateTimer();
            }
            ;
        }
        ;
        showData(interval) {
            let self = this;
            self.showDataFlag = true;
            if (self._showDataTimeout) {
                clearTimeout(self._showDataTimeout);
            }
            if (interval && !self._refreshDataTimeout) {
                self._refreshDataTimeout = setTimeout(function () {
                    clearTimeout(self._refreshDataTimeout);
                    self._refreshDataTimeout = undefined;
                    // if (!self._destroyed)
                    // 	self.showDataInternal();
                }, 10);
            }
            ;
            self._showDataTimeout = setTimeout(function () {
                if (self._refreshDataTimeout) {
                    clearTimeout(self._refreshDataTimeout);
                    self._refreshDataTimeout = undefined;
                }
                clearTimeout(self._showDataTimeout);
                self._showDataTimeout = undefined;
                if (self.showDataFlag) {
                    self.showDataFlag = false;
                    self._updateTableInternal();
                    if (!self['_destroyed'])
                        self.showDataInternal();
                }
            }, 100);
        }
        ;
        getTableCellByActualIndex(aColIdx, aRowIdx) {
            let aCol;
            let aRow;
            if (aColIdx < this._fixedCol)
                aCol = aColIdx;
            else
                aCol = aColIdx - this._leftCol + this._fixedCol;
            if (aRowIdx < this._fixedRow)
                aRow = aRowIdx;
            else
                aRow = aRowIdx - this._topRow + this._fixedRow;
            for (let i = this._topRow; i < aRow; i++) {
                if (this.gridRows.rows[i] && this.gridRows.rows[i]._visible == false)
                    aRow--;
            }
            if (aRow >= this._fixedRow && aCol >= this._fixedCol && this.tableCells[aRow] && this.tableCells[aRow][aCol])
                return this.tableCells[aRow][aCol];
            else
                return undefined;
        }
        ;
        getTableCell(aColIdx, aRowIdx) {
            if (this.tableCells && this.tableCells[aRowIdx])
                return this.tableCells[aRowIdx][aColIdx];
            else
                return undefined;
        }
        ;
        highlightCurrCell() {
            this._currCell = this.getTableCellByActualIndex(this._col, this._row);
            if (!this.options._rowSelect) {
                if (!this._currCell) {
                    if (this.cellHighlight)
                        this.cellHighlight.style.display = 'none';
                    return;
                }
                ;
                // if (this._currCell && (this._currCell.offsetTop + this._currCell.clientHeight) > this['height'])
                // 	return this.setTopRow(this._topRow + 1);		
            }
            ;
            this.highlightSelectedCell();
            this.selectedRangeHighlight.style.display = 'none';
            if (this._currCell || (this.options._rowSelect && this._row < this._rowCount)) {
                if (this.options._rowSelect) {
                    this.cellHighlight.style.display = 'block';
                    if (this._currCell) {
                        this.cellHighlight.style.display = '';
                        this.cellHighlight.style.top = this._currCell.offsetTop - 1 + 'px';
                        this.cellHighlight.style.height = this._currCell.offsetHeight + 1 + 'px';
                    }
                    else
                        this.cellHighlight.style.display = 'none';
                    this.cellHighlight.style.left = '0px';
                    if ((this._totalColWidth + 2) < this.tableContainer.clientWidth)
                        this.cellHighlight.style.width = (this._totalColWidth + 2) + 'px';
                    else
                        this.cellHighlight.style.width = (this.tableContainer.clientWidth + 2) + 'px'; // (width) + 1 + 'px';				
                }
                else if (this._currCell) {
                    let tableCell = this.getTableCell(this._col, this._row);
                    if (tableCell && this._currCell.cell) {
                        let edit = this.edit;
                        edit.value = this._currCell.cell._displayValue || this._currCell.cell._value || '';
                        if (edit instanceof HTMLInputElement)
                            edit.setSelectionRange(0, edit.value.length);
                        // if (globalEvents.activeControl == this)
                        // 	setTimeout(function(){
                        // 		edit.focus();
                        // 		edit.setSelectionRange(0, edit.value.length) 
                        // 	},5)
                    }
                    else {
                        this.edit.value = '';
                    }
                    ;
                    this.cellHighlight.style.display = 'block';
                    let parentRect = this.getBoundingClientRect();
                    let elemRect = this._currCell?.getBoundingClientRect();
                    this.cellHighlight.style.top = this._currCell.offsetTop + 'px';
                    this.cellHighlight.style.left = this._currCell.offsetLeft + 'px';
                    if (this._currCell?.offsetWidth)
                        this.cellHighlight.style.width = this._currCell.offsetWidth + 1 + 'px';
                    else
                        this.cellHighlight.style.width = '0px';
                    if (this._currCell?.offsetHeight)
                        this.cellHighlight.style.height = this._currCell.offsetHeight + 1 + 'px';
                    else
                        this.cellHighlight.style.height = '0px';
                }
                ;
            }
            else {
                this.cellHighlight.style.display = 'none';
            }
            if (this._currCell && this._currCell.cell)
                this.cellHighlight.title = this._currCell.cell._hint || '';
            else
                this.cellHighlight.title = '';
        }
        setCurrCell(aCol, aRow, triggerEvent) {
            if (this._col == aCol && this._row == aRow)
                return;
            // if (!globalEvents.ctrlKey){
            this.selectedCells = [];
            // }
            let cell = this.data.getCell(aCol, aRow);
            let idx = this.selectedCells.indexOf(cell);
            if (idx < 0) {
                this.selectedCells.push(cell);
            }
            else {
                this.selectedCells.splice(idx, 1);
            }
            this.highlightSelectedCell();
            if (this.editorMode) {
                this.hideEditor(true);
            }
            ;
            // if (aCol < 0)
            // 	aCol = 0;
            if (aCol < this._fixedCol)
                aCol = this._fixedCol;
            if (aRow < this._fixedRow)
                aRow = this._fixedRow;
            let rowChange = false;
            if (aCol < this._colCount && aRow < this._rowCount) {
                this._col = aCol;
                if (this._row != aRow) {
                    rowChange = true;
                    if (!this._readOnly && this.options._autoAddRow && this._row == this._rowCount - 1 && this.checkEmptyRow(this._row)) {
                        if (this._dataBindingContext) {
                            let record = this.getObject(0, this._row);
                            if (record)
                                this._dataBindingContext['delete'](record);
                            this.deleteRow(this._row);
                        }
                        else
                            this._rowCount = this._rowCount - 1;
                        this.enableUpdateTimer();
                    }
                }
                this._row = aRow;
                if (aCol < this._leftCol)
                    this.setLeftCol(aCol);
                if (aRow < this._topRow)
                    this.setTopRow(aRow);
                if (this._scrollBox.clientWidth > 0) { //the grid is visible
                    let topRow = this.calcTopRow(aRow);
                    if (topRow > this._topRow)
                        this.setTopRow(topRow);
                    let leftCol = this.calcLeftCol(aCol);
                    if (leftCol > this._leftCol)
                        this.setLeftCol(leftCol);
                    // this._currCell = this.getTableCellByActualIndex(aCol, aRow);
                }
                this.highlightCurrCell();
                if (rowChange) {
                    let record = this.getObject(0, this._row);
                    if (this._bindingRecordSet && this._bindingRecordSet['current'] !== record)
                        this._bindingRecordSet['current'] = record;
                    if (this._dataBindingContext && this._dataBindingContext['current'] !== record) {
                        this._skipRefreshData = true;
                        if (this._bindingRecordSet)
                            this._bindingRecordSet['current'] = record;
                        this._dataBindingContext['current'] = record;
                    }
                    if (triggerEvent && this.onRowChange) {
                        this.onRowChange(this);
                    }
                }
                if (triggerEvent && this.onCellSelect) {
                    this.onCellSelect(this, cell);
                }
            }
            ;
        }
        ;
        highlightSelectedCell() {
            if (this.selectedCells.length > 1) {
                let idx = {};
                for (let i = 0; i < this.selectedCells.length; i++) {
                    let cell = this.selectedCells[i];
                    idx[cell.col + '-' + cell.row] = false;
                }
                for (let i = this.selectedCellsHighlight.length - 1; i > -1; i--) {
                    let div = this.selectedCellsHighlight[i];
                    if (typeof (idx[div.col + '-' + div.row]) == 'undefined') {
                        this.removeChild(this.selectedCellsHighlight[i]);
                        this.selectedCellsHighlight['splice'](i, 1);
                    }
                    else
                        idx[div.col + '-' + div.row] = true;
                }
                for (let i = 0; i < this.selectedCells.length; i++) {
                    let cell = this.selectedCells[i];
                    if (idx[cell['col'] + '-' + cell['row']] == false) {
                        let tableCell = this.getTableCellByActualIndex(cell.col, cell.row);
                        if (tableCell) {
                            let div = this.createElement('div', this);
                            this.appendChild(div);
                            this.selectedCellsHighlight.push(div);
                            div.className = 'grid_selected_cell';
                            div.style.position = 'absolute';
                            div.style.display = 'block';
                            div.style.zIndex = '3';
                            div.col = cell['col'];
                            div.row = cell['row'];
                            div.style.top = tableCell.offsetTop + 'px';
                            div.style.left = tableCell.offsetLeft + 'px';
                            div.style.width = tableCell.offsetWidth + 'px';
                            div.style.height = tableCell.offsetHeight + 'px';
                        }
                        ;
                    }
                    ;
                }
                ;
            }
            else {
                for (let i = this.selectedCellsHighlight.length - 1; i > -1; i--)
                    this.removeChild(this.selectedCellsHighlight[i]);
                this.selectedCellsHighlight = [];
            }
            ;
        }
        ;
        _updateLanguage() {
        }
        ;
        _updateListOfValues() {
        }
        ;
        _handleScrollHorizontal(sender) {
            if (sender.scrollLeft == 0) {
                this.setLeftCol(this._fixedCol, true);
                return;
            }
            let width = sender.scrollWidth - sender.scrollLeft - sender.clientWidth;
            for (let i = 0; i < this._fixedCol; i++)
                width = width - this.getColWidth(i) - 1;
            for (let i = this._colCount - 1; i > 0; i--) {
                let w = this.getColWidth(i);
                width = width - w - 1;
                if (width <= 0) {
                    let col = this.calcLeftCol(i);
                    this.setLeftCol(col, true);
                    break;
                }
            }
            this.highlightCurrCell();
        }
        ;
        _handleScrollVertical(sender) {
            if (sender.scrollTop == 0) {
                if (this._cardPanel)
                    this._cardPanel['setTop'](0);
                this.setTopRow(this._fixedRow, true);
                return;
            }
            if (this.layout == 'card') {
                // sender.focus();
                // if (this.scrollTop <= this._cardHeight)
                // 	this.setTopRow(this.fixedRow, true)
                // else{
                // 	let row = Math.floor(sender.scrollTop / this._cardHeight) + this.fixedRow;
                // 	this.setTopRow(row, true);
                // }	
            }
            else {
                let height = sender.scrollHeight - sender.scrollTop - sender.clientHeight;
                for (let i = 0; i < this._fixedRow; i++) {
                    height = height - this.getRowHeight(i);
                }
                for (let i = this._rowCount - 1; i > 0; i--) {
                    let h = this.getRowHeight(i);
                    height = height - h;
                    if (height <= 0) {
                        let row = this.calcTopRow(i);
                        this.setTopRow(row, true);
                        break;
                    }
                }
                ;
            }
            this.highlightCurrCell();
        }
        ;
        _handleScroll(event) {
            // let sender = getSender(event)
            // let self = sender.owner;		
            let target = event.target;
            clearTimeout(this.scrollHorizontalTimer);
            clearTimeout(this.scrollVerticalTimer);
            if (this._scrollLeft != target.scrollLeft) {
                this._scrollLeft = target.scrollLeft;
                this.scrollHorizontalTimer = setTimeout(() => {
                    this._handleScrollHorizontal(target);
                }, 10);
            }
            else if (this._scrollTop != target.scrollTop) {
                this._scrollTop = target.scrollTop;
                this.scrollVerticalTimer = setTimeout(() => {
                    this._handleScrollVertical(target);
                }, 10);
            }
        }
        ;
        _handleFileDrop(event) {
            console.dir('## _handleFileDrop');
        }
        ;
        _handleDragOver(event) {
            console.dir('## _handleDragOver');
        }
        ;
        _handleInput(event) {
            this.showEditor(this.edit.value);
            // if (owner._chineseInput && !owner.edit['value']['trim']()){
            // 	owner._chineseInput = false;			
            // 	return;
            // }
            // if (owner && owner == globalEvents.activeControl)
        }
        ;
        _handleMouseWheel(event, delta) {
            console.dir('## _handleMouseWheel');
        }
        ;
        getColLeft(aCol) {
            let cell = this.getTableCellByActualIndex(aCol, 1);
            if (cell)
                return cell.offsetLeft;
            let r = 0;
            for (let i = 0; i < this._fixedCol; i++) {
                r = r + this.getColWidth(i);
            }
            for (let i = this._leftCol; i < aCol; i++) {
                r = r + this.getColWidth(i);
            }
            return r;
        }
        ;
        getColRight(aCol) {
            let cell = this.getTableCellByActualIndex(aCol, 1);
            if (cell)
                return cell.offsetLeft + this.getColWidth(aCol);
            let r = 0;
            for (let i = 0; i < this._fixedCol; i++) {
                r = r + this.getColWidth(i);
                if (i == aCol)
                    return r;
            }
            ;
            for (let i = this._leftCol; i < aCol; i++) {
                r = r + this.getColWidth(i);
            }
            ;
            return r + this.getColWidth(aCol);
        }
        ;
        getColWidth(col) {
            let column = this.cols(col);
            if (column && column._visible === false)
                return 0;
            let w = this.colWidths[col];
            if (w != undefined)
                return w;
            else
                return this._defaultColWidth;
        }
        ;
        getRowHeight(row) {
            let h = this._rowHeights[row];
            if (h)
                return h;
            else
                return this._defaultRowHeight;
        }
        ;
        _updateTotalRowHeight() {
            this._totalRowHeight = 0;
            for (let i = 0; i < this._rowCount; i++) {
                this._totalRowHeight = this._totalRowHeight + this.getRowHeight(i) + 0.8;
            }
            this.placeHolder.style.height = this._totalRowHeight + 'px';
        }
        ;
        _updateTotalColWidth() {
            this._totalColWidth = 0;
            for (let i = 0; i < this._colCount; i++) {
                this._totalColWidth = this._totalColWidth + this.getColWidth(i);
            }
            if (this._totalColWidth < parseFloat(this['width'].toString()))
                this.placeHolder.style.width = '100%';
            else
                this.placeHolder.style.width = this._totalColWidth + 'px';
            // this.tableContainer.style.width = this._scrollBox.clientWidth + 'px';
        }
        ;
        _updateTableRows() {
            for (let i = this._table.rows.length - 1; i >= 0; i--) {
                this._table.deleteRow(i);
            }
            this.visibleRowCount = Math.round(this.heightValue / (this._defaultRowHeight)) + 1;
            if (this.visibleRowCount > this._rowCount)
                this.visibleRowCount = this._rowCount;
            // for (let i = this._fixedRow; i < this._rowCount; i ++){
            // 	if (this.gridRows.rows[i] && this.gridRows.rows[i]._visible == false)
            // 		this.visibleRowCount --;
            // };
            for (let i = this._table.rows.length; i < this.visibleRowCount; i++) {
                let r = this._table.insertRow(this._table.rows.length);
            }
            ;
        }
        ;
        getActualColIdx(col) {
            if (col < this._fixedCol)
                return col;
            else
                return col + this._leftCol - this._fixedCol;
        }
        ;
        getActualRowIdx(row) {
            if (row < this._fixedRow)
                return row;
            else {
                let result = row + this._topRow - this._fixedRow;
                for (let i = this._topRow; i <= result; i++) {
                    if (this.gridRows.rows[i] && this.gridRows.rows[i]._visible == false)
                        result++;
                }
                ;
                return result;
            }
            ;
        }
        ;
        cols(colIdx) {
            return this.columns.getColumn(colIdx);
        }
        ;
        rows(rowIdx) {
            return this.gridRows.getRow(rowIdx);
        }
        ;
        _updateTableCellDiv(tableCell, col, row) {
            if (!tableCell.div) {
                let div = this.createElement('div');
                tableCell.div = div;
                div.owner = this;
                // if (this.mode == "vertical") {
                if (row < this._fixedRow)
                    tableCell.className = 'header grid_fixed_cell';
                else if (col < this._fixedCol)
                    tableCell.className = 'grid_fixed_cell';
                // } else {
                // 	if (col < this._fixedCol)
                // 		tableCell.className = 'header grid_fixed_cell';
                // 	else if (row < this._fixedRow)
                // 		tableCell.className = 'grid_fixed_cell';
                // }
                let actCol = this.getActualColIdx(col);
                let actRow = this.getActualRowIdx(row);
                let cell = this.data.cells(actCol, actRow);
                let w = 0;
                let h = 0;
                if (cell && cell.mergeRect) {
                    let divRect = this.createElement('div');
                    divRect.style.overflow = 'hidden';
                    divRect.style.position = 'relative';
                    tableCell.appendChild(divRect);
                    w = this.getColWidth(cell.mergeRect.startCol) - 2;
                    h = this.getRowHeight(cell.mergeRect.startRow) - 1;
                    for (let i = cell.mergeRect.startCol + 1; i <= cell.mergeRect.endCol; i++)
                        w = w + this.getColWidth(i) - 2;
                    for (let i = cell.mergeRect.startRow + 1; i <= cell.mergeRect.endRow; i++)
                        h = h + this.getRowHeight(i) - 2;
                    let left = 0;
                    let top = 0;
                    if (cell.mergeRect.startCol > this._fixedCol && cell.mergeRect.startCol < this._leftCol) {
                        for (let i = cell.mergeRect.startCol; i < this._leftCol; i++)
                            left = left + this.getColWidth(i) - 2;
                    }
                    if (cell.mergeRect.startRow > this._fixedRow && cell.mergeRect.startRow < this._topRow) {
                        for (let i = cell.mergeRect.startRow; i < this._topRow; i++)
                            top = top + this.getRowHeight(i) - 1;
                    }
                    divRect.appendChild(div);
                    divRect.style.width = (w - left) + 'px';
                    divRect.style.height = (h - top) + 'px';
                    div.style.position = 'absolute';
                    div.style.left = -left + 'px';
                    div.style.top = -top + 'px';
                }
                else {
                    w = this.getColWidth(actCol) - 2;
                    let column = this.cols(actCol);
                    if (column && column._visible === false)
                        tableCell.className += ' grid_cell_hidden';
                    h = this.getRowHeight(actRow) - 2;
                    if (row < this._fixedRow)
                        tableCell.style.minWidth = w + 'px';
                    tableCell.style.position = 'relative';
                    tableCell.appendChild(div);
                }
                div.style.width = w + 'px';
                // if (this.options._autoRowHeight) {
                div.style.height = 'auto';
                div.style.whiteSpace = 'wrap';
                // } else {
                // 	div.style.maxHeight = h + 'px';
                // 	div.style.whiteSpace = 'nowrap';
                // }
                div.style.maxHeight = h + 'px';
                div.style.overflow = 'hidden';
                if (col == 0)
                    div.style.minHeight = h + 'px';
                // div.style.whiteSpace = 'pre-line';
                div.className = 'grid_cell_value';
            }
            ;
        }
        ;
        _updateTableCols() {
            let w = 0;
            for (let i = 0; i < this._fixedCol; i++)
                w = w + this.getColWidth(i); //this.colWidths[i];
            this.visibleColCount = this._fixedCol;
            let width = this.widthValue; //this._scrollBox.clientWidth;		
            if (width == 0)
                this._needUpdate = true;
            else
                this._needUpdate = false;
            for (let i = this._leftCol; i < this._colCount; i++) {
                w = w + this.getColWidth(i);
                if (this.visibleColCount < this._colCount)
                    this.visibleColCount++;
                if (w >= width)
                    break;
            }
            ;
            for (let row = 0; row < this._table.rows.length; row++) {
                let r = this._table.rows[row];
                this.tableCells[row] = [];
                for (let col = 0; col < this.visibleColCount; col++) {
                    let tableCell = r.insertCell(r.cells.length);
                    if (col == 0)
                        tableCell.style.height = this._defaultRowHeight + 'px';
                    tableCell.owner = this;
                    if ((col + this._leftCol) % 2 == 0)
                        tableCell.className = 'grid_cell even_col';
                    else
                        tableCell.className = 'grid_cell odd_col';
                    if ((row + this._topRow) % 2 == 0)
                        tableCell.className += ' even_row';
                    else
                        tableCell.className += ' odd_row';
                    this._updateTableCellDiv(tableCell, col, row);
                    this.tableCells[row][col] = tableCell;
                    if (row == 0 && (col < this._fixedCol && col == this.sortingCol || (col >= this._fixedCol && col + (this._leftCol > 0 ? this._leftCol - this._fixedCol : 0)) == this.sortingCol)) {
                        tableCell.style.position = 'relative';
                        let elm = this.createElement('div');
                        elm.style.position = 'absolute';
                        elm.style.width = '6px';
                        elm.style.height = '6px';
                        elm.style.right = '4px';
                        if (this.sortingDescending) {
                            elm.style.top = '2px';
                            elm.className = 'fa fa-sort-desc';
                        }
                        else {
                            elm.style.top = '6px';
                            elm.className = 'fa fa-sort-asc';
                        }
                        tableCell.appendChild(elm);
                    }
                }
            }
        }
        ;
        setColWidth(aColIndex, width, trigerEvent) {
            let orig = 0;
            orig = this.colWidths[aColIndex];
            this.colWidths[aColIndex] = width;
            // if (aColIndex > this._fixedCol)
            // let col = aColIndex - this._leftCol + this.fixedCol
            // else
            // let col = aColIndex;
            // this.totalColWidth = this.totalColWidth + width - orig;			
            for (let i = 0; i < this.tableCells.length; i++) {
                let tableCell = this.getTableCell(aColIndex, i);
                let tableCellDiv = tableCell?.div;
                let column = this.cols(aColIndex);
                if (tableCell && tableCell.div && !column._checkBox && !column._radioButton)
                    tableCellDiv.style.width = (width - 3) + 'px';
                // if (this.tableCells[i].length > col)
                // this.tableCells[i][col].childNodes[0].style.width = width -3 + 'px';
            }
            // this.rowHeights = [];
            for (let i = 0; i < this._rowCount; i++) {
                let cell = this.cells(aColIndex, i);
                if (cell)
                    cell._height = undefined;
                // this.rowHeights[i] = undefined;
            }
            if (trigerEvent && this.onColResize) {
                if (this.resizeTimer)
                    clearTimeout(this.resizeTimer);
                this.resizeTimer = setTimeout(() => {
                    this.onColResize(this, aColIndex, width);
                }, 50);
            }
            this.enableUpdateTimer(true, true);
        }
        ;
        _updateTableMergedCells() {
            console.dir('### _updateTableMergedCells');
        }
        ;
        sort(col, descending) {
            let currRow = this.data.data[this._row];
            if (this.editorMode)
                this.hideEditor();
            this._rowHeights = [];
            if (this.data.data.length > this._rowCount)
                this.data.data.length = this._rowCount;
            if (col >= 0)
                this.data.sort(col, descending);
            this.sortingDescending = descending || false;
            this.sortingCol = col;
            if (currRow)
                this._row = this.data.data.indexOf(currRow);
            this.enableUpdateTimer();
        }
        ;
        getEditor(col, row, cell, inputValue) {
            // let colOrRowType: ColRowType;
            // colOrRowType = (this.mode == "vertical")? this.columns.getColumn(col).type : this.gridRows.getRow(row).type;
            let colOrRowType = this.columns.getColumn(col).type;
            if (colOrRowType == "checkBox") {
                let editor = new checkbox_1.Checkbox(undefined, {
                    checked: (cell.value != undefined) ? cell.value : false
                });
                editor.style.marginLeft = "1px";
                editor.className = 'grid_edit';
                this.appendChild(editor);
                return editor;
            }
            else if (colOrRowType == "datePicker") {
                let editor = new datepicker_1.Datepicker(undefined, {
                    type: "date",
                    width: this.getColWidth(cell.col) - 1
                });
                editor.className = 'grid_edit';
                this.appendChild(editor);
                if (cell.value != undefined) {
                    editor.value = cell.value;
                }
                else {
                    editor.value = moment_1.moment.unix(moment_1.moment.now() / 1000);
                }
                // adjust style of datePicker
                let inputElm = editor.getElementsByTagName("input")[0];
                inputElm.style.height = "";
                inputElm.style.padding = "0px";
                inputElm.style.backgroundColor = "white";
                let btn = editor.getElementsByClassName("datepicker-toggle")[0];
                btn.style.backgroundColor = "white";
                return editor;
            }
            else if (colOrRowType == "timePicker") {
                let editor = new datepicker_1.Datepicker(undefined, {
                    type: "time",
                    width: this.getColWidth(cell.col) - 1
                });
                editor.className = 'grid_edit';
                this.appendChild(editor);
                if (cell.value != undefined) {
                    editor.value = cell.value;
                }
                else {
                    editor.value = moment_1.moment.unix(moment_1.moment.now() / 1000);
                }
                // adjust style of datePicker
                let inputElm = editor.getElementsByTagName("input")[0];
                inputElm.style.height = "";
                inputElm.style.padding = "0px";
                inputElm.style.backgroundColor = "white";
                let btn = editor.getElementsByClassName("datepicker-toggle")[0];
                btn.style.backgroundColor = "white";
                return editor;
            }
            else if (colOrRowType == "dateTimePicker") {
                let editor = new datepicker_1.Datepicker(undefined, {
                    type: "dateTime",
                    width: this.getColWidth(cell.col) - 1
                });
                editor.className = 'grid_edit';
                this.appendChild(editor);
                if (cell.value != undefined) {
                    editor.value = cell.value;
                }
                else {
                    editor.value = moment_1.moment.unix(moment_1.moment.now() / 1000);
                }
                // adjust style of datePicker
                let inputElm = editor.getElementsByTagName("input")[0];
                inputElm.style.height = "";
                inputElm.style.padding = "0px";
                inputElm.style.backgroundColor = "white";
                let btn = editor.getElementsByClassName("datepicker-toggle")[0];
                btn.style.backgroundColor = "white";
                return editor;
            }
            else if (colOrRowType == "comboBox") {
                // let colOrRowComboItems: IComboItem[];
                // colOrRowComboItems = (this.mode == "vertical")? this.cols(col).comboItems : this.rows(row).comboItems;
                let colOrRowComboItems = this.cols(col).comboItems;
                let _selectedItem = colOrRowComboItems[0];
                for (let i = 0; i < colOrRowComboItems.length; i++) {
                    if (cell.value === colOrRowComboItems[i].value) {
                        _selectedItem = colOrRowComboItems[i];
                        break;
                    }
                }
                let editor = new combo_box_1.ComboBox(undefined, {
                    items: colOrRowComboItems,
                    selectedItem: _selectedItem,
                    icon: { name: 'caret-down', width: '16px', height: '16px' }
                });
                editor.className = 'grid_edit comboBoxEditor';
                this.appendChild(editor);
                // adjust style of comboBox
                let rowHeight = this.getRowHeight(cell.row);
                let selectionElm = editor.getElementsByClassName("selection")[0];
                selectionElm.style.maxWidth = `100%`;
                selectionElm.style.padding = "0px";
                let inputElm = selectionElm.getElementsByTagName("input")[0];
                inputElm.style.padding = "0px";
                let iconBtn = editor.getElementsByClassName("icon-btn")[0];
                iconBtn.style.padding = "0px";
                iconBtn.style.width = rowHeight + 'px';
                iconBtn.style.height = rowHeight + 'px';
                let iconElm = iconBtn.getElementsByTagName('i-icon')[0];
                iconElm.style.width = rowHeight + 'px';
                iconElm.style.height = rowHeight + 'px';
                return editor;
            }
            else if (colOrRowType == "number") {
                let editor = this.createElement('input', this);
                editor.type = "number";
                editor.value = cell.value;
                editor.setAttribute('autocomplete', 'disabled');
                editor.className = 'grid_edit';
                this.appendChild(editor);
                return editor;
            }
            else if (colOrRowType == "integer") {
                let editor = this.createElement('input', this);
                editor.type = "text";
                editor.addEventListener('input', () => {
                    const currentValue = editor.value;
                    const sanitizedValue = currentValue.replace(/[^0-9]/g, '');
                    editor.value = sanitizedValue;
                });
                editor.value = cell.value;
                editor.setAttribute('autocomplete', 'disabled');
                editor.className = 'grid_edit';
                this.appendChild(editor);
                return editor;
            }
            // else if (this.columns.getColumn(col).type == "string") {
            // 	let editor = <any>this.createElement('input', this);
            // 	editor.setAttribute('autocomplete', 'disabled');
            // 	editor.className = 'grid_edit';
            // 	editor.setAttribute('editorType', this.columns.getColumn(col).type);
            // 	this.appendChild(editor);
            // 	return editor;
            // } 
            else {
                let editor = this.createElement('input', this);
                if (inputValue)
                    editor.value = inputValue;
                editor.setAttribute('autocomplete', 'disabled');
                editor.className = 'grid_edit';
                // this.appendChild(editor);
                return editor;
            }
        }
        ;
        handleEditControlChange(event) {
            console.dir('## handleEditControlChange');
        }
        ;
        _handleEditDblClick(event, stopPropagation) {
            return true;
        }
        ;
        colLeft() {
            let aRow = this._row;
            let aCol = this._col - 1;
            while (aCol > this._fixedCol) {
                let column = this.cols(aCol);
                if (column && column.visible === false)
                    aCol--;
                else
                    break;
            }
            ;
            if (aCol < this._colCount) {
                let cell = this.data.cells(aCol, aRow);
                if (cell && cell.mergeRect) {
                    if (cell.mergeRect.startRow != aRow) {
                        aRow = cell.mergeRect.endRow + 1;
                    }
                    ;
                    this.setCurrCell(aCol, aRow, true);
                }
                else
                    this.setCurrCell(aCol, aRow, true);
            }
            ;
        }
        ;
        colRight() {
            let aRow = this._row;
            let aCol = this._col + 1;
            while (aCol < this._colCount - 1) {
                let column = this.cols(aCol);
                if (column && column.visible === false)
                    aCol++;
                else
                    break;
            }
            ;
            if (aCol < this._colCount) {
                let cell = this.data.cells(aCol, aRow);
                if (cell && cell.mergeRect) {
                    if (cell.mergeRect.startRow != aRow) {
                        aRow = cell.mergeRect.endRow + 1;
                    }
                    this.setCurrCell(aCol, aRow, true);
                }
                else
                    this.setCurrCell(aCol, aRow, true);
            }
            ;
        }
        ;
        autoAddRow() {
            if (!this._readOnly && !this.options._rowSelect && this.options._autoAddRow && this._row == this._rowCount - 1) {
                let emptyRow = this.checkEmptyRow(this._row);
                if (!emptyRow) {
                    this._rowCount = this._rowCount + 1;
                    this.setCurrCell(this._col, this._row + 1, true);
                    let cell = this.data.getCell(0, this._row);
                    if (this._dataBindingContext) {
                        cell._newRow = true;
                        let rd = this._dataBindingContext['append']();
                        this.setObject(0, this._row, rd);
                        this._skipRefreshData = true;
                        if (this._bindingRecordSet)
                            this._bindingRecordSet['current'] = rd;
                        this._dataBindingContext['current'] = rd;
                    }
                    this._updateTotalRowHeight();
                    this.enableUpdateTimer();
                }
            }
        }
        ;
        rowDown(disableAutoAddRow) {
            let aCol = this._col;
            let aRow = this._row + 1;
            while (aRow < this._rowCount - 1 && this.gridRows.rows[aRow] && this.gridRows.rows[aRow]._visible == false) {
                aRow++;
            }
            if (this.gridRows.rows[aRow] && this.gridRows.rows[aRow]._visible == false)
                aRow = this._row;
            this.gridRows.rows[aRow] && this.gridRows.rows[aRow]._visible == false;
            if (!disableAutoAddRow)
                this.autoAddRow();
            if (aRow < this._rowCount) {
                let cell = this.data.cells(aCol, aRow);
                if (cell && cell.mergeRect) {
                    if (cell.mergeRect.startRow != aRow) {
                        aRow = cell.mergeRect.endRow + 1;
                    }
                    this.setCurrCell(aCol, aRow, true);
                }
                else
                    this.setCurrCell(aCol, aRow, true);
            }
            ;
        }
        ;
        calcBottomRow(topRowIdx) {
            if (topRowIdx == this._rowCount - 1)
                return topRowIdx;
            let row = topRowIdx;
            let height = this._scrollBox.clientHeight;
            if (this.layout == 'card') {
                // row = topRowIdx + Math.ceil(height / this._cardHeight);
                // if (row >= this.rowCount)
                // 	row = this.rowCount -1;
            }
            else {
                for (let i = 0; i < this._fixedRow; i++)
                    height = height - this.getRowHeight(i) - 0.8;
                height = height - this.getRowHeight(row);
                while (row < this._rowCount - 1) {
                    let h = this.getRowHeight(row - 1) + 0.8;
                    height = height - h;
                    if (height <= 0)
                        return row;
                    row++;
                }
                ;
            }
            ;
            return row;
        }
        ;
        calcLeftCol(colIdx) {
            if (colIdx == this._fixedCol)
                return colIdx;
            let col = colIdx;
            let width = this._scrollBox.clientWidth;
            for (let i = 0; i < this._fixedCol; i++)
                width = width - this.getColWidth(i) - 0.8;
            width = width - this.getColWidth(col) - 0.8;
            while (col > this._fixedCol - 1) {
                let w = this.getColWidth(col - 1) + 0.8;
                width = width - w;
                if (width <= 0) {
                    return col;
                }
                col--;
            }
            return col;
        }
        ;
        rowUp() {
            let aCol = this._col;
            let aRow = this._row - 1;
            let cell = this.data.cells(aCol, aRow);
            if (cell && cell.mergeRect) {
                if (cell.mergeRect.endRow != aRow) {
                    aRow = cell.mergeRect.startRow - 1;
                }
                ;
                this.setCurrCell(aCol, aRow, true);
            }
            else
                this.setCurrCell(aCol, aRow, true);
        }
        ;
        restoreOrigCellValue() {
            if (this.origValue != undefined) {
                if (this.editorMode)
                    this.editor.value = this.origValue;
                else
                    this._currCell.div.textContent = this.origValue;
            }
            ;
        }
        ;
        _handleKeyDown(event, stopPropagation) {
            if (!this.editorMode)
                this.edit.focus();
            if (!this.enabled)
                return false;
            else if (event.keyCode == 229) {
                // this._chineseInput = true;
                setTimeout(() => {
                    // this._chineseInput = false;
                }, 10);
                return true;
            }
            ;
            // if (event.bubbles && this.onKeyDown)
            // 	this['onKeyDown'].call(this.parentForm, this['__this'], keyInfo, event)
            // if (event && event['cancelBubble'])
            // 	return;
            // if (this['_destroyed'])
            // 	return;
            let keyCode = event.keyCode;
            switch (keyCode) {
                case 9: {
                    //tab
                    if (event.shiftKey)
                        this.colLeft();
                    else
                        this.colRight();
                    return true;
                }
                case 13: {
                    //enter
                    if (this.editorMode) {
                        // if ((typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox) || this.editor['listOfValue']){						
                        // 	if (this.editor['listOfValue']){
                        // 		if (this.editor instanceof TComboBox){
                        // 			if (this.editor.itemIndex > -1)
                        // 				this.editor.setItemIndex(this.editor.itemIndex)
                        // 			else
                        // 				this.editor.setValueCode(this.editor.input.value)
                        // 		}
                        // 		else
                        // 			this.editor.setItemIndex(this.editor.itemIndex);
                        // 	}
                        // 	else if (typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox){
                        // 		let text = this.editor.items.getString(this.editor.itemIndex);
                        // 		let v = this.editor.input.value;
                        // 		if (v)
                        // 			v = v.toLowerCase()
                        // 		if (text && text.toLowerCase().indexOf(v) == 0)
                        // 			this.editor.valueCode = text;
                        // 	}
                        // 	this.editor.hideDropDownPanel(false, true);
                        // }	
                        if (!event.shiftKey) {
                            // if (this.editor instanceof TEdit && this.editor['dataType'] == 'dtLookup'){
                            // 	this.hideEditor(true);
                            // }
                            // else {
                            this.hideEditor(true);
                            this.colRight();
                            // }
                        }
                    }
                    else {
                        this.setCurrCell(this._col + 1, this._row, true);
                    }
                    return true;
                }
                case 32: {
                    //space
                    let col = this.cols(this._col);
                    let row = this.rows(this._row);
                    let cell = this.cells(this._col, this._row);
                    if (cell && cell.checkBox) {
                        if (this._currCell) {
                            this.toggleCellValue(col, cell);
                            this._updateCell(this._currCell, cell, col, row);
                        }
                        ;
                        event.stopPropagation();
                    }
                    break;
                }
                case 33: {
                    //page up
                    // if (this.editorMode && ((typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox) || this.editor['listOfValue'])){					
                    // 	return true;
                    // }
                    let bottomRow = this.calcBottomRow(this._topRow);
                    let row = this.calcTopRow(bottomRow);
                    row = this.calcTopRow(row);
                    this.setCurrCell(this._col, row);
                    return true;
                }
                case 34: {
                    //page down
                    // if (this.editorMode && ((typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox) || this.editor['listOfValue'])){				
                    // 	return true;
                    // }
                    let bottomRow = this.calcBottomRow(this._topRow);
                    let row = this.calcBottomRow(bottomRow);
                    this.setCurrCell(this._col, row);
                    return true;
                }
                case 35: {
                    //end
                    if (!this.editorMode) {
                        if (event.ctrlKey) {
                            this.setCurrCell(this._colCount - 1, this._rowCount - 1);
                        }
                        else
                            this.setCurrCell(this._colCount - 1, this._row);
                    }
                    return true;
                }
                case 36: {
                    //home
                    if (!this.editorMode) {
                        if (event.ctrlKey)
                            this.setCurrCell(this._fixedCol, this._fixedRow);
                        else
                            this.setCurrCell(this._fixedCol, this._row);
                    }
                    return true;
                }
                case 38: {
                    //arrow up
                    // if (this.editorMode && ((this.editor instanceof TEdit && this.editor['dataType'] == 'dtLookup') || (typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox) || this.editor['listOfValue'])){					
                    // 	return true;
                    // }
                    this.rowUp();
                    return true;
                }
                case 40: {
                    //arrow down
                    // if (this.editorMode && ((this.editor instanceof TEdit && this.editor['dataType'] == 'dtLookup') || (typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox) || this.editor['listOfValue'])){
                    // 	return true;
                    // }
                    if (this.editorMode) {
                        // if ((typeof(TComboBox) != 'undefined' && this.editor instanceof TComboBox) || this.editor['listOfValue'])
                        // 	this.editor.hideDropDownPanel(false, true);
                        this.hideEditor(true);
                    }
                    this.rowDown();
                    return true;
                }
                default: {
                    let col = this.cols(this._col);
                    let cell = this.cells(this._col, this._row);
                    if (cell && cell.checkBox)
                        event.stopPropagation();
                }
            }
            ;
            if (this.editorMode) {
                switch (keyCode) {
                    case 27:
                        //escape
                        this.restoreOrigCellValue();
                        this.hideEditor();
                        this.focus();
                        return true;
                    case 37:
                        //arrow left
                        // if (getInputCaretPos(this.editor) == 0)
                        // 	this.colLeft()
                        return;
                    case 39:
                        //arrow right
                        // if (getInputCaretPos(this.editor) == this.editor.value.length)
                        // 	this.colRight();
                        return;
                }
                ;
            }
            else {
                switch (keyCode) {
                    case 37:
                        //arrow left
                        this.colLeft();
                        return true;
                    case 39:
                        //arrow right
                        this.colRight();
                        return true;
                }
            }
            ;
        }
        ;
        _handleBlur(event, stopPropagation) {
            return true;
        }
        ;
        showEditor(inputValue) {
            let column = this.columns.getColumn(this._col);
            let contextReadonly = false;
            if (this._dataBindingContext) {
                contextReadonly = this._dataBindingContext['readOnly'] || this._dataBindingContext['_context']['options']['_readOnly'];
            }
            if (!column._file && contextReadonly)
                return;
            if (!column._file && this.checkCellReadOnly())
                return;
            let cell = this.data.cells(this._col, this._row);
            this._currCell = this.getTableCellByActualIndex(this._col, this._row);
            if (this._currCell && !this.editorMode) {
                let top = this._currCell.offsetTop - 1;
                //this.table.style.zIndex = 1;
                this.editorMode = true;
                this.origValue = this._currCell.div.innerHTML || '';
                if (this.editor) {
                    this.editor.owner = null;
                    this.editor['onChange'] = null;
                    this.editor['onDblClick'] = null;
                    this.editor['onKeyDown'] = null;
                    this.editor['onHideDropDownPanel'] = null;
                }
                let editor;
                if (this.onGetEditControl) {
                    editor = this.onGetEditControl(this, cell);
                    if (editor)
                        this.appendChild(editor);
                }
                if (!editor) {
                    editor = this.getEditor(this._col, this._row, cell, inputValue);
                    // editor.editorMode = true;
                    // editor.buildInEditor = true;
                    // globalEvents.editor = this
                }
                if (editor) {
                    // editor.owner = this;
                    editor.onchange = this.handleEditControlChange.bind(this);
                    editor.ondblclick = this._handleEditDblClick.bind(this);
                    editor.onkeydown = this._handleKeyDown.bind(this);
                    // editor['onHideDropDownPanel'] = this.handHideDropDownPanel.bind(this);
                    editor.onblur = this._handleBlur.bind(this);
                    this.editor = editor;
                    editor.style.position = 'absolute';
                    editor.style.display = 'block'; //['setVisible'](true);
                    // editor.value = this.edit.value;
                    // if (editor instanceof Datepicker) {
                    // 	editor.value = this.edit.value as Moment;
                    // } else if (editor instanceof ComboBox) {
                    // 	editor.value = this.edit.value as IComboItem;
                    // } else {
                    // 	editor.value = this.edit.value as string
                    // }
                    // else if (this.edit instanceof HTMLInputElement) {
                    // 	if (editor.getAttribute("editorType"), "number")
                    // 		editor.value = parseFloat(this.edit.value) as number
                    // 	else if (editor.getAttribute("editorType"), "integer")
                    // 		editor.value = parseInt(this.edit.value) as number
                    // 	else if (editor.getAttribute("editorType"), "string")
                    // 		editor.value = this.edit.value as string
                    // }
                    editor.focus();
                    if (cell.mergeRect) {
                        let w = 0;
                        let h = 0;
                        for (let i = cell.mergeRect.startCol; i < cell.mergeRect.endCol; i++)
                            w += this.getColWidth(i);
                        editor.style.width = (w - 1) + 'px'; //['setWidth'](w -1);
                        for (let i = cell.mergeRect.startCol; i < cell.mergeRect.endCol; i++)
                            h += this.getRowHeight(i) + 0.8;
                        editor.style.height = (h - 1) + 'px';
                        // this.editor['setHeight'](h -1);
                        this.editor['setTop'](this._currCell.offsetTop + 1);
                        this.editor['setLeft'](this._currCell.offsetLeft + 1);
                    }
                    else {
                        editor.style.width = (this.getColWidth(this._col) - 2) + 'px';
                        editor.style.height = (this.getRowHeight(this._row) - 2) + 'px';
                        editor.style.top = (this._currCell.offsetTop + 2) + 'px';
                        editor.style.left = (this._currCell.offsetLeft + 2) + 'px';
                        // this.editor['setWidth'](this.getColWidth(this.col) - 2);
                        // this.editor['setHeight'](this.getRowHeight(this.row) - 2);			
                        // this.editor['setTop'](this.currCell.offsetTop + 2);				
                        // this.editor['setLeft'](this.currCell.offsetLeft + 2);
                    }
                }
                // if (this['onGetEditLookup']) {
                // 	globalEvents.editor = null;				
                // 	if (!cell)
                // 		cell = this.data.getCell(this.col, this.row)
                // 	if (this.editLookup){
                // 		document.body.appendChild(this.editLookup.container)
                // 		this.editLookup.parent = null;
                // 	}
                // 	let editLookup = this['onGetEditLookup'](this['__this'], cell);
                // 	if (editLookup) {
                // 		if (editLookup['__self'])
                // 			editLookup = editLookup['__self'];					
                // 		this.editLookup = editLookup;
                // 		// this.editLookup.parent = this;
                // 		document.body.appendChild(editLookup.container)
                // 		if (this.editLookup instanceof TButton){
                // 			this.editLookup['setTop'](clientToScreenY(this, this['top']) + this.getRowHeightTop(this.row));
                // 			this.editLookup['setLeft'](clientToScreenX(this, this['left']) +  this.getColLeft(this.col +1) - this.editLookup['width']);
                // 			this.editLookup['setHeight'](this.getRowHeight(this.row));
                // 		}
                // 		else{
                // 			this.editLookup['setTop'](clientToScreenY(this, this['top']) + this.getRowHeightTop(this.row + 1));
                // 			this.editLookup['setLeft'](clientToScreenX(this, this['left']) +  this.getColLeft(this.col));
                // 		}					
                // 		this.editLookup['setVisible'](true);
                // 		this.editLookup.bringToFront();
                // 	}
                // }
                if (this.onEditModeChanged) {
                    this.onEditModeChanged(this);
                }
                ;
                this.editor = editor;
                let self = this;
                setTimeout(() => {
                    if (editor) {
                        editor.style.zIndex = '9999';
                        editor.focus();
                        // if (typeof(TDateTimePicker) != 'undefined' && (editor instanceof TDateTimePicker)) {					
                        // 	editor['setVisible'](true)		
                        // 	editor.focus();	
                        // 	if (cell._value)
                        // 		editor.setDateTimeValue(new Date(cell._value))
                        // 	if (editor.kind == 'time')
                        // 		editor.showTimePicker()
                        // 	else
                        // 		editor.showDatePicker()	
                        // } 
                        // else{					
                        // 	if (editor instanceof TEdit)
                        // 		let enforcce = true;
                        // 	editor['setVisible'](true)		
                        // 	editor.focus();					
                        // 	if (editor instanceof TEdit && editor['dataType'] == 'dtLookup'){
                        // 		editor.input['value'] = self.edit.value || '';						
                        // 	}
                        // 	else if (editor.setText){
                        // 		if (editor['readOnly'] || (editor.input && editor.input.readOnly))
                        // 			editor.setText(cell._value, enforcce)
                        // 		else
                        // 			editor.setText(self.edit.value, enforcce)						
                        // 	} else if (editor.setValue){ 
                        // 		if (editor['readOnly'] || (editor.input && editor.input.readOnly))
                        // 			editor.setValue(cell._value, enforcce)
                        // 		else
                        // 			editor.setValue(self.edit.value, enforcce);
                        // 	}										
                        // 	if (editor['dataType'] == 'dtLookupCombo' || (typeof(TComboBox) != 'undefined' &&  editor instanceof TComboBox) || editor['listOfValue'])
                        // 		editor.showDropDownPanel();
                        // 	else if (editor instanceof TEdit && editor['dataType'] == 'dtLookup')
                        // 		editor.showLookupGrid()
                        // }
                    }
                    ;
                }, 10);
            }
            else
                this.edit.value = '';
        }
        ;
        _handleMouseDown(event) {
            if (!this.enabled)
                return true;
            let target = event.target;
            if (target && target.isSpliter)
                return true;
            let aCol = 0;
            let aRow = 0;
            if (target == this.editor) {
                return true;
                // } else if (self.skipContainerClick) {
                //     self.skipContainerClick = false
            }
            else {
                let rect = this.getBoundingClientRect();
                let x = getCursorPosX(event) - rect.left;
                let y = getCursorPosY(event) - rect.top;
                if (x > this._scrollBox.clientWidth || y > this._scrollBox.clientHeight)
                    return true;
                for (let row = 0; row < this._table.rows.length; row++) {
                    let tableCell = this.tableCells[row][0];
                    if (tableCell.offsetTop + tableCell.clientHeight >= y) {
                        let r = this.tableCells[row];
                        for (let col = 0; col < r.length; col++) {
                            tableCell = r[col];
                            if (tableCell && tableCell.offsetLeft + tableCell.clientWidth >= x && tableCell.offsetTop + tableCell.clientHeight >= y) {
                                let tableCellDiv = tableCell?.div;
                                aCol = this.getActualColIdx(col);
                                aRow = this.getActualRowIdx(row);
                                let cell = this.cells(aCol, aRow);
                                this.lastClickCell = cell;
                                let elms = tableCellDiv.querySelectorAll('button');
                                if (elms.length > 0) {
                                    let offsetX = x - tableCell.offsetLeft;
                                    for (let i = 0; i < elms.length; i++) {
                                        if (elms[i].offsetLeft + elms[i].clientWidth > offsetX) {
                                            this.setCurrCell(aCol, aRow, true);
                                            let btn;
                                            if (Array.isArray(cell._value))
                                                btn = cell._value[i];
                                            else
                                                btn = cell._value;
                                            if (this.onButtonClick) {
                                                this.onButtonClick(this, cell, btn);
                                            }
                                            if (this.onCellClick) {
                                                this.onCellClick(this, cell);
                                            }
                                        }
                                    }
                                    return true;
                                }
                                let column = this.columns.getColumn(aCol);
                                let gridRow = this.gridRows.getRow(aRow);
                                if (column && ((cell && cell._checkBox) || column._checkBox || column._radioButton)) {
                                    if (aRow >= this._fixedRow || (!cell.readOnly && cell._checkBox)) {
                                        this.toggleCellValue(column, cell);
                                        this._updateCell(tableCell, cell, column, gridRow);
                                        this.setCurrCell(aCol, aRow, true);
                                    }
                                    else if (this.options._sortOnClick && column._sortable) {
                                        if (aCol == this.sortingCol)
                                            this.sort(aCol, !this.sortingDescending);
                                        else
                                            this.sort(aCol);
                                    }
                                }
                                else if ((aCol == this._col) && (aRow == this._row)) {
                                    if (!this.editorMode) {
                                        let cell = this.data.cells(aCol, aRow);
                                        this.edit.value = cell._displayValue || cell._value || ''; //self.getValue(aCol, aRow);											
                                        this.showEditor(cell._displayValue || cell._value || '');
                                    }
                                }
                                else if (aRow < this._fixedRow) {
                                    application_1.application.globalEvents.abortEvent(event);
                                    if (this.editorMode)
                                        this.hideEditor();
                                    if (this.options._sortOnClick) {
                                        if (aCol == this.sortingCol)
                                            this.sort(aCol, !this.sortingDescending);
                                        else
                                            this.sort(aCol);
                                    }
                                }
                                else {
                                    this.setCurrCell(aCol, aRow, true);
                                }
                                if (cell && this.onCellClick)
                                    this.onCellClick(this, cell);
                                break;
                            }
                        }
                        if (aRow != undefined)
                            break;
                    }
                }
            }
            if (aRow == undefined && this.editorMode) {
                // self._updateCurrCellValue();
                this.hideEditor(true);
            }
            if (!this.editorMode) {
                this.edit.focus();
            }
            ;
            return true;
        }
        ;
        _updateCell(tableCell, cell, column, row) {
            let tableCellDiv = tableCell?.div;
            let _cell = cell;
            let _column = column;
            let _row = row;
            let _tableCell = tableCell;
            let withDispValue = false;
            let disp;
            // handle undefined data
            if (!tableCell.classList.contains("header")) {
                // let colOrRowType: ColRowType = (this.mode == "vertical")? this.cols(cell.col).type : this.rows(cell.row).type;
                let colOrRowType = this.cols(cell.col).type;
                switch (colOrRowType) {
                    case "string":
                        if (cell.value == undefined)
                            cell._value = "";
                        break;
                    case "checkBox":
                        if (cell.value == undefined || cell.value == "")
                            cell._value = false;
                        break;
                    case "datePicker":
                        if (cell.value == undefined || cell.value == "")
                            cell._value = moment_1.moment.unix(moment_1.moment.now() / 1000);
                        break;
                    case "dateTimePicker":
                        if (cell.value == undefined || cell.value == "")
                            cell._value = moment_1.moment.unix(moment_1.moment.now() / 1000);
                        break;
                    case "timePicker":
                        if (cell.value == undefined || cell.value == "")
                            cell._value = moment_1.moment.unix(moment_1.moment.now() / 1000);
                        break;
                    case "comboBox":
                        // let colOrRowComboItems = (this.mode == "vertical")? this.cols(cell.col).comboItems : this.rows(cell.row).comboItems;
                        let colOrRowComboItems = this.cols(cell.col).comboItems;
                        if (cell.value == undefined || cell.value == "")
                            cell._value = (colOrRowComboItems) ? colOrRowComboItems[0].value : undefined;
                        break;
                    case "number":
                        if (cell.value == undefined || cell.value == "")
                            cell._value = 0;
                        break;
                    case "integer":
                        if (cell.value == undefined || cell.value == "")
                            cell._value = 0;
                        break;
                }
            }
            if (tableCellDiv) {
                tableCell.style.display = '';
                if (cell._encrypted)
                    tableCellDiv.style.color = 'green';
                else
                    tableCellDiv.style.color = '';
                tableCellDiv.style.display = '';
                if (cell) {
                    _cell._tableCell = tableCellDiv;
                    let font = {
                        'bold': this.font.bold,
                        'color': this.font.color,
                        // 'italic': this.font.italic,
                        'name': this.font.name,
                        'size': this.font.size,
                        'style': this.font.style,
                        'transform': this.font.transform,
                        'weight': this.font.weight,
                        'shadow': this.font.shadow
                        // 'underline': this.font.underline
                    };
                    let value;
                    if (this.onDisplayCell) {
                        disp = {
                            'button': _cell._button,
                            'checkBox': _cell._checkBox,
                            'col': _cell._col,
                            'color': _cell._color,
                            'dataType': _cell._dataType,
                            'font': font,
                            'formula': _cell._formula,
                            'horizontalAlign': _cell._horizontalAlign,
                            'html': _cell._html,
                            'image': _cell._image,
                            'object': _cell._object,
                            'readOnly': _cell._readOnly,
                            'row': _cell._row,
                            'text': _cell._text,
                            'value': _cell._value,
                            'visible': _cell._visible
                        };
                        try {
                            this.onDisplayCell(this, disp);
                            if (disp.value != _cell._value) {
                                _cell._displayValue = disp['value'];
                                withDispValue = true;
                            }
                            value = disp['value'];
                        }
                        catch (e) {
                            value = '';
                        }
                    }
                    else if (column && _column._formula) {
                        if (this.formula) {
                            this.formulaCell = cell;
                            value = this.formula['parse'](column._formula)['result'];
                        }
                        else {
                            // loadLibrary('/libs/formula/1.11.1/formula-parser.min.js', () =>{
                            // 	if (!self.formula){
                            // 		self.formula = new window['formulaParser']['Parser']();
                            // 		self.formula['on']('callVariable', function(name, done){
                            // 			let rd = self.getObject(0, self.formulaCell._row);
                            // 			if (rd)
                            // 				done(rd[name])
                            // 		})
                            // 		self.enableUpdateTimer()
                            // 	}
                            // })
                        }
                    }
                    else
                        value = _cell._value;
                    let c = (_cell ? _cell._color : '') || (_column ? _column._color : '');
                    tableCell.classList.remove('bg-warning', 'bg-success', 'bg-info', 'bg-danger', 'bg-highlight');
                    if (c) {
                        if (['warning', 'success', 'info', 'danger', 'highlight'].indexOf(c) > -1)
                            tableCell.classList.add('bg-' + c);
                        else
                            tableCell.style.backgroundColor = c;
                    }
                    else
                        tableCellDiv.style.backgroundColor = '';
                    let align;
                    if (_cell._horizontalAlign != undefined)
                        align = _cell._horizontalAlign;
                    else if (_column && _column._horizontalAlign != undefined) {
                        align = _column._horizontalAlign;
                    }
                    if (align != undefined) {
                        switch (align) {
                            case 0:
                                tableCellDiv.style.textAlign = 'center';
                                break;
                            case 1:
                                tableCellDiv.style.textAlign = 'left';
                                break;
                            case 2:
                                tableCellDiv.style.textAlign = 'right';
                                break;
                        }
                    }
                    if (!_cell.visible)
                        tableCellDiv.style.display = 'none';
                    else
                        tableCellDiv.style.display = '';
                    // if (_cell._font) {
                    // 	let font = _cell._font;
                    // 	if (font.size != undefined)
                    // 		tableCell.style.fontSize = font.size + 'px'
                    // 	else
                    // 		tableCell.style.fontSize = '';
                    // 	if (font['color']) {
                    // 		let c = color[font['color']];
                    // 		if (c == undefined)
                    // 			c = font['color'];
                    // 		tableCell.style.color = c;
                    // 	} else
                    // 		tableCell.style.color = '';
                    // 	if (font.bold)
                    // 		tableCell.style.fontWeight = 'bold'
                    // 	else
                    // 		tableCell.style.fontWeight = '';
                    // 	if (font.italic)
                    // 		tableCell.style.fontStyle = 'italic'
                    // 	else
                    // 		tableCell.style.fontStyle = '';
                    // } else {
                    // 	tableCellDiv.style.fontSize = font['size'] + 'px';
                    // 	if (font['color']) {
                    // 		let c = color[font['color']];
                    // 		if (c == undefined)
                    // 			c = font['color'];
                    // 		tableCell.style.color = c;
                    // 	} else
                    // 		tableCell.style.color = '';
                    // 	tableCellDiv.style.fontWeight = font['bold'];
                    // 	tableCellDiv.style.fontStyle = font['italic'];
                    // }
                    let colOrRowType;
                    let colOrRowDataType;
                    if (_column && _row) {
                        // if (this.mode == "vertical") {
                        colOrRowType = _column._type;
                        colOrRowDataType = _column._dataType;
                        // }
                        // else {
                        // 	colOrRowType = _row._type;
                        // 	colOrRowDataType = _row._dataType;
                        // }
                    }
                    else if (_column) {
                        colOrRowType = _column._type;
                        colOrRowDataType = _column._dataType;
                    }
                    else {
                        colOrRowType = _row._type;
                        colOrRowDataType = _row._dataType;
                    }
                    if (colOrRowDataType == 'boolean') {
                        let item = new checkbox_1.Checkbox(undefined, {
                            checked: cell.value
                        });
                        tableCellDiv.appendChild(item);
                        // adjust style of check box
                        // tableCellDiv.style.display = "flex";
                        // tableCellDiv.style.justifyContent = "center";
                        // item.style.top = "50%";
                        // item.style.marginTop = "-7.5px";
                        // item.style.position = "absolute";
                    }
                    else if (colOrRowDataType == 'date') {
                        let item = new label_1.Label(undefined, {
                            caption: cell.value.format('YYYY-MM-DD')
                        });
                        tableCellDiv.appendChild(item);
                    }
                    else if (colOrRowDataType == 'dateTime') {
                        let item = new label_1.Label(undefined, {
                            caption: cell.value.format('YYYY-MM-DD HH:mm:ss')
                        });
                        tableCellDiv.appendChild(item);
                    }
                    else if (colOrRowDataType == 'time') {
                        let item = new label_1.Label(undefined, {
                            caption: cell.value.format('HH:mm:ss')
                        });
                        tableCellDiv.appendChild(item);
                    }
                    else if (colOrRowDataType == 'string') {
                        let item = new label_1.Label(undefined, {
                            caption: cell.value.toString()
                        });
                        tableCellDiv.appendChild(item);
                    }
                    else if (colOrRowDataType == "number") {
                        let item = new label_1.Label(undefined, {
                            caption: cell.value.toString()
                        });
                        tableCellDiv.appendChild(item);
                    }
                    else if (colOrRowDataType == "integer") {
                        let item = new label_1.Label(undefined, {
                            caption: cell.value.toString()
                        });
                        tableCellDiv.appendChild(item);
                    }
                    else {
                        if ((_column && _column._type == 'image') && _cell._file && _cell._file['url']) {
                            tableCellDiv.classList.add('image');
                            // addClass(tableCelDiv, 'image')
                            tableCellDiv.style.height = this._defaultRowHeight + 'px';
                            tableCellDiv.innerHTML = '<img src="' + withDispValue ? _cell._displayValue : _cell._file['url'] + '?size=t" style="max-height:100%;max-width=100%"/>';
                        }
                        else if (disp && disp.image) { //image
                            tableCellDiv.classList.add('image');
                            tableCellDiv.style.height = this._defaultRowHeight + 'px';
                            tableCellDiv.innerHTML = '<img src="' + withDispValue ? value : disp.value + '"/>';
                        }
                        else if (disp && disp.html) { //html
                            tableCellDiv.innerHTML = withDispValue ? value : application_1.application.xssSanitize(disp.value);
                        }
                        else if ((_cell && (_cell.image || _cell._dataType == 5)) || (_column && _column._dataType == 5)) { //image
                            tableCellDiv.classList.add('image');
                            tableCellDiv.style.height = this._defaultRowHeight + 'px';
                            tableCellDiv.innerHTML = '<img src="' + withDispValue ? value : _cell._value + '"/>';
                        }
                        else if ((_cell && (_cell.html || _cell._dataType == 6)) || (_column && _column._dataType == 6)) { //html
                            tableCellDiv.innerHTML = withDispValue ? value : application_1.application.xssSanitize(_cell._value);
                        }
                        else if (value && !Array.isArray(value) && !(value instanceof Date) && typeof (value) == 'object') {
                            if (Array.isArray(value)) {
                                let html = '';
                                for (let i = 0; i < value.length; i++)
                                    html += '<button>' + (value[i]['caption'] || '...') + '</button>';
                                tableCellDiv.innerHTML = html;
                            }
                            else
                                tableCellDiv.innerHTML = '<button>' + (value['caption'] || '...') + '</button>';
                        }
                        else if (_column && _column._button) {
                            tableCellDiv.innerHTML = '<button>' + (value || '...') + '</button>';
                        }
                        else if ((_cell && _cell._checkBox) || (_column && _column._checkBox)) {
                            if (value)
                                tableCellDiv.className = 'check_box_checked';
                            else
                                tableCellDiv.className = 'check_box_unchecked';
                            tableCellDiv.style.position = 'relative';
                            tableCellDiv.style.margin = 'auto';
                            tableCellDiv.style.top = (this._defaultRowHeight - 13) / 2 + 'px';
                            tableCellDiv.style.left = '1px';
                            tableCellDiv.style['height'] = '100%';
                            tableCellDiv.style['width'] = '13px';
                        }
                        else if (_column && _column._radioButton) {
                            if (value)
                                tableCellDiv.className = 'radio_button.checked';
                            else
                                tableCellDiv.className = 'radio_button.unchecked';
                            tableCellDiv.style.position = 'relative';
                            tableCellDiv.style.margin = 'auto';
                            tableCellDiv.style.top = (this._defaultRowHeight - 13) / 2 + 'px';
                            tableCellDiv.style.left = '1px';
                            tableCellDiv.style['height'] = '100%';
                            tableCellDiv.style['width'] = '13px';
                        }
                        else {
                            if (_cell._dispValue && tableCell.classList.contains('grid_fixed_cell')) {
                                tableCellDiv.textContent = _cell._dispValue;
                            }
                            else if (withDispValue) {
                                tableCellDiv.textContent = value;
                            }
                            else if (_cell.row < this._fixedRow) {
                                tableCellDiv.textContent = value;
                            }
                            else {
                                if (column && (_column._type == 'lookupDetail')) {
                                    let rd;
                                    if (_cell._record)
                                        rd = _cell._record;
                                    else {
                                        let record = this.getObject(0, _cell._row);
                                        if (record) {
                                            let rs = record[_column._lookupTable];
                                            if (rs) {
                                                rd = rs.first;
                                                _cell._field = _column._lookupField;
                                                let v1 = _column._lookupDetailValue;
                                                switch (_column._lookupDetailType) {
                                                    case 'date':
                                                        v1 = new Date(v1);
                                                        v1.setHours(0, 0, 0, 0);
                                                        break;
                                                    case 'numeric':
                                                        if (typeof (v1) == 'string')
                                                            v1 = parseFloat(v1);
                                                        break;
                                                }
                                                while (rd) {
                                                    let v2 = rd[_column._lookupField];
                                                    switch (_column._lookupDetailType) {
                                                        case 'date':
                                                            v2 = new Date(rd[_column._lookupDetailField]);
                                                            v2.setHours(0, 0, 0, 0);
                                                            break;
                                                        case 'numeric':
                                                            if (typeof (v2) == 'string')
                                                                v2 = parseFloat(v2);
                                                            break;
                                                    }
                                                    if (v1 == v2)
                                                        break;
                                                    else if (_column._lookupDetailType == 'date' && v1.getTime() == v2.getTime())
                                                        break;
                                                    rd = rs['next'];
                                                }
                                            }
                                        }
                                    }
                                    if (rd) {
                                        _cell._value = rd[_column._lookupField];
                                        _cell._record = rd;
                                        tableCellDiv.textContent = rd[_column._lookupField];
                                    }
                                }
                                else if (column && _column._type == 'listOfValue' && _column._listOfValue) {
                                    let lsv = this._listOfValue[_column._listOfValue];
                                    if (lsv != undefined)
                                        tableCellDiv.textContent = lsv[value] || value;
                                    else
                                        tableCellDiv.textContent = value;
                                }
                                else if (column && (_column._type == 'lookup' || _column._type == 'lookupCombo')) {
                                    // let context: any;
                                    // if (!_column._lookupContext)
                                    // 	context = this.context
                                    // else
                                    // 	context = this.parentForm[column._lookupContext];
                                    // if (context){
                                    // 	let rs = context[column._lookupTable]
                                    // 	if (rs && value){
                                    // 		let record = rs['getRecordByPrimaryKey'](value);		
                                    // 		if (record){
                                    // 			if (value && (column._displayUserName)){
                                    // 				let name = application.userNameList[value];
                                    // 				if (name != undefined){
                                    // 					tableCell.div['textContent'] = name || ''
                                    // 					cell._displayValue = name || ''
                                    // 				}
                                    // 				else{
                                    // 					application.getUserNameList([value], function(){									
                                    // 						let name = application.userNameList[value];
                                    // 						tableCell.div['textContent'] = name || ''
                                    // 						cell._displayValue = name || ''
                                    // 						tableCell = null;
                                    // 					})
                                    // 				}	
                                    // 			}
                                    // 			else{
                                    // 				let fields = column._lookupField.split(' ');
                                    // 				let value = '';
                                    // 				for (let i = 0; i < fields.length; i ++){
                                    // 					if (value)
                                    // 						value += ' ' + (record[fields[i]] || '')
                                    // 					else
                                    // 						value = record[fields[i]] || ''
                                    // 				}
                                    // 				tableCell.div['textContent'] =  value
                                    // 				cell._displayValue = value;
                                    // 				tableCell = null;
                                    // 			}
                                    // 		}
                                    // 	}
                                    // 	else{
                                    // 		tableCell.div['textContent'] =  '';
                                    // 		cell._displayValue = '';
                                    // 		tableCell = null;
                                    // 	}
                                    // }
                                }
                                else if (_column && _column._type == '{userAccount}') {
                                    // if (value){
                                    // 	let name = application.userNameList[value];
                                    // 	if (name != undefined)
                                    // 		tableCell.div['textContent'] = name || ''
                                    // 	else{
                                    // 		let self = this;
                                    // 		application.getUserNameList([value], function(){									
                                    // 			let name = application.userNameList[value];
                                    // 			tableCell.div['textContent'] = name || ''
                                    // 			self = null;
                                    // 		})
                                    // 	}
                                    // }
                                    // else
                                    // 	tableCell.div['textContent'] =  '';
                                }
                                // else if (cell && cell._dataType == 4){
                                // 	tableCell.div['textContent'] = formatDateTimeStr(value);
                                // }
                                // else if (cell && cell._dataType == 2)
                                // 	tableCell.div['textContent'] = formatDateStr(value);
                                // else if (column && (column._dataType == 4 || column._type == 'dateTime')){							
                                // 	tableCell.div['textContent'] = formatDateTimeStr(value);
                                // }
                                // else if (column && (column._dataType == 3 || column._type == 'time')){
                                // 	tableCell.div['textContent'] = formatTimeStr(value);
                                // }
                                // else if (column && (column._dataType == 2 || column._type == 'date')){
                                // 	tableCell.div['textContent'] = formatDateStr(value);
                                // }
                                // else if (column && column._format){
                                // 	tableCell.div['textContent'] = window['numeral'](value)['format'](column._format)	
                                // }
                                else {
                                    let type = typeof (value);
                                    if (type != 'undefined') {
                                        if (type == 'number')
                                            tableCellDiv.textContent = parseNumber(value.toPrecision(12)).toString();
                                        else {
                                            tableCellDiv.textContent = value;
                                        }
                                    }
                                    else
                                        tableCellDiv.textContent = '';
                                }
                            }
                        }
                    }
                }
                else {
                    if ((cell && _cell._checkBox) || (column && _column._checkBox)) {
                        tableCellDiv.className = 'check_box_unchecked';
                        tableCellDiv.style.position = 'relative';
                        tableCellDiv.style.top = '1px';
                        tableCellDiv.style.left = '1px';
                        tableCellDiv.style['height'] = '13px';
                        tableCellDiv.style['width'] = '13px';
                    }
                    else if (column && _column._radioButton) {
                        tableCellDiv.className = 'radio_button.unchecked';
                        tableCellDiv.style.position = 'relative';
                        tableCellDiv.style.top = '1px';
                        tableCellDiv.style.left = '1px';
                        tableCellDiv.style['height'] = '13px';
                        tableCellDiv.style['width'] = '13px';
                    }
                    else
                        tableCellDiv.textContent = '';
                }
            }
        }
        ;
        checkCellReadOnly(col, row) {
            if (!this._enabled || this._readOnly || this.options._rowSelect)
                return true;
            else {
                if (col == undefined)
                    col = this._col;
                if (row == undefined)
                    row = this._row;
                if ((col < this._fixedCol || row < this._fixedRow) && this.layout != 'card')
                    return true;
                let column = this.cols(col);
                if (column._readOnly)
                    return true;
                else {
                    let record = this.getObject(0, row);
                    if (record && record['_isReadOnly'])
                        return true;
                    let cell = this.data.cells(col, row);
                    if (cell)
                        return cell.readOnly || !cell.visible;
                    else
                        return false;
                }
                ;
            }
            ;
        }
        ;
        toggleCellValue(column, cell) {
            if (!this.checkCellReadOnly(cell.col, cell.row)) {
                cell._value = !cell._value;
                if (this._dataBindingContext) {
                    let record = this.getObject(0, cell._row);
                    let field = this.getObject(cell._col, 0);
                    if (!record && field) {
                        record = this._dataBindingContext['append']();
                        this.setObject(0, cell._row, record);
                    }
                    if (record && field) {
                        record[field] = cell._value;
                    }
                    this.enableUpdateTimer();
                }
                this.updateBindingData(cell, column);
                if (this.onCellChange)
                    this.onCellChange(this, cell, !cell._value, cell._value);
            }
        }
        _handleMouseMove(event) {
            if (application_1.application.globalEvents._leftMouseButtonDown) {
                // let cell = this.getMouseOverCell(event)
                // if (cell && cell != this.selectedCell){
                // 	this.selectedCell = cell;
                // 	this.selectCellRange(cell)
                // 	if (this['onCellSelect']) 
                // 		this['onCellSelect'](this['__this'], cell);
                // }				
            }
            if (this._colResizing) {
                // if (self._designMode)
                // 	application.postMessage('$WISONE_IDE_MODULE_CHANGED')
                let pos = getCursorPosX(event);
                this.setColWidth(this.resizeCol, this.origColWidth + (pos - this.mouseDownPosX), true);
                this.showData(100);
                this.highlightCurrCell();
                return true;
            }
            return true;
        }
        _handleMouseUp(event) {
            if (this._colResizing) {
                // this.skipContainerClick = true;
                this._colResizing = false;
                this._updateTableSplitter();
            }
            // self.handleDesignEvent = false;
            return true;
        }
        _handleColumnResizeStart(event) {
            if (this.editorMode) {
                this.hideEditor(true);
            }
            ;
            // globalEvents.activeControl = self;
            let pos = getCursorPosX(event);
            this.mouseDownPosX = pos;
            this.resizeCol = this.getActualColIdx(event.target.cellIndex);
            this.origColWidth = this.getColWidth(this.resizeCol);
            this._colResizing = true;
            // this.handleDesignEvent = true;
        }
        _updateTableSplitter() {
            let splitter;
            for (let i = this.tableSplitters.length - 1; i < this.visibleColCount; i++) {
                splitter = this.tableSplitters[i];
                if (splitter)
                    splitter.style.display = 'none';
            }
            ;
            for (let col = 0; col < this.visibleColCount; col++) {
                splitter = this.tableSplitters[col];
                if (!splitter) {
                    splitter = this.createElement('div', this);
                    this.tableSplitters[col] = splitter;
                    splitter.isSpliter = true;
                    splitter.owner = this;
                    splitter.cellIndex = col;
                    splitter.onmousedown = this._handleColumnResizeStart.bind(this);
                    this.appendChild(splitter);
                    splitter.style.zIndex = 5;
                    splitter.style.cursor = 'e-resize';
                    splitter.style.position = 'absolute';
                    splitter.style.top = '0px';
                    splitter.style.width = '6px';
                }
                ;
                let colIdx = this.getActualColIdx(col);
                let left = this.getColRight(colIdx);
                let height = 0;
                for (let row = 0; row < this._fixedRow; row++) {
                    height = height + this.getRowHeight(row) + 0.8;
                }
                splitter.style.left = left + 'px';
                if (this._fixedCol > 0 && col == this._fixedCol - 1)
                    splitter.style.height = '100%';
                else
                    splitter.style.height = height + 'px';
                splitter.style.display = '';
            }
        }
        ;
        _showDataInternalGrid() {
            if (!this._table)
                return;
            //load fixed cell value
            for (let r = 0; r < this._fixedRow; r++) {
                for (let c = 0; c < this._fixedCol; c++) {
                    let tableCell = this.getTableCell(c, r);
                    let column = null;
                    let row = null;
                    if (this.columns)
                        column = this.columns.getColumn(c);
                    if (this.gridRows)
                        row = this.gridRows.getRow(r);
                    if (tableCell) {
                        let cell = this.data.cells(c, r);
                        this._updateCell(tableCell, cell, column, row);
                    }
                }
            }
            //load fixed row value
            for (let r = 0; r < this._fixedRow; r++) {
                for (let c = this._fixedCol; c < this.visibleColCount; c++) {
                    let row = this.gridRows.getRow(r);
                    let tableCell = this.getTableCell(c, r);
                    if (tableCell) {
                        let cell = this.data.cells(this.getActualColIdx(c), r);
                        if (cell)
                            tableCell.cell = cell;
                        this._updateCell(tableCell, cell, undefined, row);
                    }
                }
            }
            //load fixed col value
            for (let r = this._fixedRow; r < this.visibleRowCount; r++) {
                for (let c = 0; c < this._fixedCol; c++) {
                    let column = this.columns.getColumn(c);
                    let tableCell = this.getTableCell(c, r);
                    if (tableCell) {
                        let cell = this.data.cells(c, this.getActualRowIdx(r));
                        if (cell)
                            tableCell.cell = cell;
                        this._updateCell(tableCell, cell, column);
                    }
                }
            }
            //get lookup values
            for (let c = this._fixedCol; c < this.visibleColCount; c++) {
                let colIdx = this.getActualColIdx(c);
                let _column = this.columns.getColumn(colIdx);
                if (_column && (_column._type == 'lookup' || _column._type == 'lookupCombo')) {
                    // if (!_column._lookupContext)
                    // 	let context = this.context
                    // else
                    // 	let context = this.parentForm[_column._lookupContext];
                    // if (context){								
                    // 	let rs = context[_column._lookupTable]
                    // 	if (rs && _column._lookupKeys){	
                    // 		rs['_fetchRecordsByKeyValue'](_column._lookupKeys, true)
                    // 		_column._lookupKeys = undefined;
                    // 	}
                    // }
                }
            }
            //load cell value
            for (let r = this._fixedRow; r < this.visibleRowCount; r++) {
                let rowIdx = this.getActualRowIdx(r);
                for (let c = this._fixedCol; c < this.visibleColCount; c++) {
                    let colIdx = this.getActualColIdx(c);
                    let column = this.columns.getColumn(colIdx);
                    let row = this.gridRows.getRow(rowIdx);
                    let tableCell = this.getTableCell(c, r);
                    if (tableCell) {
                        let cell = this.data.cells(colIdx, rowIdx);
                        tableCell.cell = cell;
                        this._updateCell(tableCell, cell, column, row);
                    }
                    ;
                }
                ;
            }
            ;
            //get and store the cell height
            if (this.options._autoRowHeight) {
                for (let r = 0; r < this.visibleRowCount; r++) {
                    if (this._table.rows[r].clientHeight > this._defaultRowHeight) {
                        for (let c = 0; c < this.visibleColCount; c++) {
                            let tableCell = this.getTableCell(c, r);
                            if (tableCell && tableCell.cell) {
                                let cell = tableCell.cell;
                                let row = this.getActualRowIdx(r);
                                if (!cell._height) {
                                    cell._height = tableCell.div.clientHeight + 3;
                                }
                                if (!this._rowHeights[row] || this._rowHeights[row] < cell._height) {
                                    this._rowHeights[row] = cell._height;
                                }
                            }
                        }
                    }
                }
            }
            ;
            //hide table columns larger than colCount
            let row = this._table.rows[0];
            if (row) {
                if (row.cells.length > (this._colCount - this._leftCol + this._fixedCol)) {
                    for (let r = 0; r < this._table.rows.length; r++) {
                        let row = this._table.rows[r];
                        for (let c = this._colCount - this._leftCol + this._fixedCol; c < row.cells.length; c++) {
                            row.cells[c].style.display = 'none';
                        }
                        ;
                    }
                    ;
                }
                ;
            }
            ;
            //hide table rows larger than rowCount
            if (this._table.rows.length > (this._rowCount - this._topRow + this._fixedRow)) {
                for (let c = this._rowCount - this._topRow + this._fixedRow; c < this._table.rows.length; c++) {
                    if (c > -1) {
                        this._table.rows[c].style.display = 'none';
                    }
                    ;
                }
                ;
            }
            ;
            this.highlightCurrCell();
        }
        ;
        showDataInternal() {
            this.showDataFlag = false;
            if (!this.showDataInternalFlag) {
                this.showDataInternalFlag = true;
                try {
                    if (this.layout == 'card') {
                        // this._updateCardView()
                    }
                    else
                        this._showDataInternalGrid();
                }
                finally {
                    this.showDataInternalFlag = false;
                }
                ;
            }
            ;
        }
        ;
        _updateTableInternal(updateRowHeightFlag, updateColWidthFlag) {
            if (!this._updateTableInternalFlag) {
                this._updateTableInternalFlag = true;
                try {
                    // this.setTopRow(this._topRow)
                    if (this.layout == 'card') {
                        // this._updateCardView();
                    }
                    else {
                        // if (this._cardPanel){
                        // 	this._cardPanel.free();
                        // 	this._cardPanel = null;
                        // }
                        if (updateRowHeightFlag) {
                            // this.updateRowHeightFlag = false;
                            this._updateTotalRowHeight();
                        }
                        ;
                        if (updateColWidthFlag) {
                            // this.updateColWidthFlag = false;
                            this._updateTotalColWidth();
                        }
                        ;
                        this.tableCells = [[]];
                        if (this._totalColWidth < parseFloat(this.width.toString()))
                            this.placeHolder.style.width = '100%';
                        else
                            this.placeHolder.style.width = this._totalColWidth + 'px';
                        this.placeHolder.style.height = this._totalRowHeight + 'px';
                        // this.tableContainer.style.width = this._scrollBox.clientWidth + 'px';				
                        // this.tableContainer.style.height = this._scrollBox.clientHeight + 'px';
                        this._updateTableRows();
                        this._updateTableCols();
                        this._updateTableMergedCells();
                        this._updateTableSplitter();
                    }
                }
                catch (err) {
                }
                finally {
                    this._updateTableInternalFlag = false;
                }
                ;
            }
            ;
        }
        ;
        enableUpdateTimer(updateRowHeightFlag, updateColWidthFlag) {
            updateRowHeightFlag = updateRowHeightFlag || false;
            updateColWidthFlag = updateColWidthFlag || false;
            // this.updateRowHeightFlag = this.updateRowHeightFlag || updateRowHeightFlag;
            // this.updateColWidthFlag = this.updateColWidthFlag || updateColWidthFlag;
            clearTimeout(this._updateTableTimer);
            // if (!this.updateTimer) {
            // this.updateTimerCounter = 0;
            // this.updateCounter = 0;
            this._updateTableTimer = setTimeout(() => {
                // if (this.updateTimerCounter == this.updateCounter) {					
                // clearInterval(this.updateTimer);
                if (this._scrollBox.clientWidth) {
                    this._updateTableTimer = undefined;
                    this._sorting = false;
                    if (updateRowHeightFlag)
                        this._rowHeights = [];
                    this._updateTableInternal(updateRowHeightFlag, updateColWidthFlag);
                    this.showDataInternal();
                }
                else {
                    this._updateTableTimer = setTimeout(() => {
                        this._sorting = false;
                        if (updateRowHeightFlag)
                            this._rowHeights = [];
                        this._updateTableInternal(updateRowHeightFlag, updateColWidthFlag);
                        this.showDataInternal();
                    }, 100);
                }
                // } else
                //     this.updateTimerCounter = this.updateCounter;
            }, 10);
            // }
            // else {
            // 	this.updateCounter++;
            // };
        }
        ;
    };
    DataGrid = __decorate([
        (0, base_1.customElements)('i-data-grid')
    ], DataGrid);
    exports.DataGrid = DataGrid;
    ;
});
define("@ijstech/data-grid", ["require", "exports", "@ijstech/data-grid/dataGrid.ts"], function (require, exports, dataGrid_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataGridCell = exports.DataGrid = void 0;
    Object.defineProperty(exports, "DataGrid", { enumerable: true, get: function () { return dataGrid_1.DataGrid; } });
    Object.defineProperty(exports, "DataGridCell", { enumerable: true, get: function () { return dataGrid_1.DataGridCell; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/markdown/styles/index.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule("i-markdown", {
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        color: `var(--custom-text-color, ${Theme.text.primary})`,
    });
});
define("@ijstech/markdown/plaintify.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TxtRenderer = void 0;
    ///<amd-module name='@ijstech/markdown/plaintify.ts'/> 
    function escape(html) {
        const escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        return html.replace(/[&<>"']/g, match => escapeMap[match]);
    }
    /*---------------------------------------------------------------------------------------------
      *  Copyright (c) 2019 Eric Buss
      *  Licensed under the MIT License.
      *  https://github.com/ejrbuss/markdown-to-txt/blob/cf689435d38ad1528b9b796d2da835b8c05d47c1/LICENSE
      *--------------------------------------------------------------------------------------------*/
    // https://github.com/ejrbuss/markdown-to-txt/blob/cf689435d38ad1528b9b796d2da835b8c05d47c1/src/markdown-to-txt.ts
    const block = (text) => text + "\n\n";
    const escapeBlock = (text) => escape(text) + "\n\n";
    const line = (text) => text + "\n";
    const inline = (text) => text;
    const newline = () => "\n";
    const empty = () => "";
    exports.TxtRenderer = {
        // Block elements
        code: escapeBlock,
        blockquote: block,
        html: empty,
        heading: block,
        hr: newline,
        list: (text) => block(text.trim()),
        listitem: line,
        checkbox: empty,
        paragraph: block,
        table: (header, body) => line(header + body),
        tablerow: (text) => line(text.trim()),
        tablecell: (text) => text + " ",
        // Inline elements
        strong: inline,
        em: inline,
        codespan: inline,
        br: newline,
        del: inline,
        link: (_0, _1, text) => text,
        image: (_0, _1, text) => text,
        text: inline,
        // etc.
        options: {},
    };
});
define("@ijstech/markdown/markdown.ts", ["require", "exports", "@ijstech/base", "@ijstech/markdown/plaintify.ts", "@ijstech/markdown/styles/index.css.ts"], function (require, exports, base_1, plaintify_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Markdown = exports.markdownToPlainText = void 0;
    const libs = [`${base_1.LibPath}lib/marked/marked.umd.js`];
    // const headingRegex = /(#{1,6})\s(.*?)(?=\||(#{1,6})|$)/gm;
    // const numberedListRegex = /(\d+)\.(\s{1,2})(.*?)(?=\||(\d+\.)|$)/gm;
    // const bulletListRegex = /([-+*])\s{1,2}(.*?)(?=\||\\n|([-+*])|$)/gm;
    async function markdownToPlainText(text) {
        return new Promise((resolve, reject) => {
            base_1.RequireJS.require(libs, async (marked) => {
                marked.use({
                    gfm: true,
                    renderer: plaintify_1.TxtRenderer
                });
                const plainText = await marked.parse(text);
                resolve(plainText);
            });
        });
    }
    exports.markdownToPlainText = markdownToPlainText;
    let Markdown = class Markdown extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this.gitbookProcess = true;
            this._theme = 'light';
        }
        get theme() {
            return this._theme;
        }
        set theme(value) {
            this._theme = value;
            if (this._theme === 'light')
                this.classList.remove('toastui-editor-dark');
            else
                this.classList.add('toastui-editor-dark');
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            this._space = value;
            if (!this.elm)
                return;
            if (!this._padding)
                this._padding = new base_1.SpaceValue(this.elm, value, 'padding');
            else
                this._padding.update(value);
        }
        getRenderer() {
            const renderer = {
                // image(href: string, title: string, text: string) {
                //     if (href === null) {
                //         return text;
                //     }
                //     var out = '<span><img style="width: 100%;" src="' + href + '" alt="' + text + '"';
                //     if (title) {
                //         out += ' title="' + title + '"';
                //     }
                //     out += '><span class="img-caption">' + text + '</span></span>';
                //     return out;
                // }
                link(href, title, text) {
                    return `<a target="_blank" href="${href}" ${title ? 'title="' + title + '"' : ''}>${text}</a>`;
                }
            };
            return renderer;
        }
        async getTokens(text) {
            if (!this.marked)
                this.marked = await this.loadLib();
            let tokens;
            try {
                tokens = this.marked.lexer(text, {
                    breaks: true
                });
            }
            catch (e) { }
            return tokens;
        }
        async toPlainText(text) {
            if (!this.marked)
                this.marked = await this.loadLib();
            this.marked.use({
                gfm: true,
                renderer: plaintify_1.TxtRenderer
            });
            const plainText = await this.marked.parse(text);
            return plainText;
        }
        async load(text) {
            if (!this.marked)
                this.marked = await this.loadLib();
            let renderer = this.getRenderer();
            this.marked.use({ renderer: new this.marked.Renderer() });
            this.marked.use({
                renderer
            });
            if (text) {
                const rows = text.split(/\n{2}|(?:\r\n){2}/);
                for (let i = 0; i < rows.length; i++) {
                    rows[i] = rows[i] ? await this.preParse(rows[i]) : '';
                    const regex = /```((\w+)?[\s\n])*\(/g;
                    const matches = regex.exec(rows[i]);
                    if (matches?.length) {
                        const group = matches[1];
                        if (group)
                            rows[i] = rows[i].replace(group, group.trim());
                    }
                }
                text = rows.join('\n\n');
                text = await this.marked.parse(text, {
                    breaks: true
                });
                text = await this.processText(text);
            }
            else {
                text = '';
            }
            ;
            if (!this.elm)
                this.elm = this.createElement('div', this);
            this.elm.innerHTML = text;
            if (!this._padding && this._space)
                this.padding = this._space;
            return this.elm.innerHTML;
        }
        async preParse(text) {
            const firstIndex = text.indexOf('|');
            const lastIndex = text.lastIndexOf('|');
            const tableMd = text.slice(firstIndex, lastIndex + 1);
            const tableMdRegex = /(?:^|\r?\n\r?\n)([^\r\n]*\|[^\r\n]*(\r?\n)?)+(?=\r?\n\r?\n|$)/gm; //Avoid using lookbehind
            if (!tableMdRegex.test(tableMd))
                return text;
            const breakRegex = /\|(\s)*:?(-+):?(\s)*\|/gm;
            if (!breakRegex.test(tableMd))
                return text;
            const splittedArr = [];
            let currentSegment = '';
            let isEscaped = false;
            for (let i = 0; i < tableMd.length; i++) {
                const char = tableMd[i];
                if (char === '\\' && !isEscaped) {
                    isEscaped = true;
                }
                else if (char === '|' && !isEscaped) {
                    splittedArr.push(currentSegment);
                    currentSegment = '';
                }
                else {
                    currentSegment += char;
                    isEscaped = false;
                }
            }
            splittedArr.push(currentSegment);
            for (let i = 0; i < splittedArr.length; i++) {
                let child = splittedArr[i].trim() || '';
                if (child) {
                    if (/^(\s)*:?-*:?(\s)*$/g.test(child))
                        continue;
                    child = await this.marked.parse(child, {
                        breaks: true
                    });
                    if (child !== '\n') {
                        splittedArr[i] = child.replace(/\n/g, '').replace(/\|/g, '&#124;');
                    }
                }
            }
            text = text.slice(0, firstIndex) + splittedArr.join('|');
            return text;
        }
        async beforeRender(text) {
            this.elm.innerHTML = text;
        }
        async processText(text) {
            if (this.gitbookProcess) {
                // List of sub items
                text = text.replace(/\*\*\*\*/g, '\n\t').replace(/\\/g, '');
            }
            return text;
        }
        async loadLib() {
            return new Promise((resolve, reject) => {
                base_1.RequireJS.require(libs, async (marked) => {
                    resolve(marked);
                });
            });
        }
        init() {
            super.init();
            this.elm = this.createElement('div', this);
            this.elm.classList.add('toastui-editor-contents');
            const theme = this.getAttribute('theme', true);
            if (theme)
                this.theme = theme;
            const padding = this.getAttribute('padding', true);
            if (padding) {
                this._padding = new base_1.SpaceValue(this.elm, padding, 'padding');
            }
        }
    };
    Markdown = __decorate([
        (0, base_1.customElements)("i-markdown", {
            icon: "spell-check",
            className: "Markdown",
            props: {
                theme: { type: 'string' }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    theme: {
                        type: 'string',
                        enum: ['light', 'dark'],
                        default: 'light'
                    }
                }
            }
        })
    ], Markdown);
    exports.Markdown = Markdown;
});
define("@ijstech/markdown", ["require", "exports", "@ijstech/markdown/markdown.ts"], function (require, exports, markdown_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.markdownToPlainText = exports.Markdown = void 0;
    Object.defineProperty(exports, "Markdown", { enumerable: true, get: function () { return markdown_1.Markdown; } });
    Object.defineProperty(exports, "markdownToPlainText", { enumerable: true, get: function () { return markdown_1.markdownToPlainText; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/markdown-editor/styles/index.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule("i-markdown-editor", {
        $nest: {
            ".ProseMirror .placeholder": {
                //make placeholder unfocusable
                userSelect: "none",
                pointerEvents: "none"
            },
            '.overlay': {
                width: '100%',
                height: '100%',
                position: 'absolute',
                top: 0,
                left: 0,
                zIndex: 999,
                display: 'none',
                backgroundColor: 'transparent',
                cursor: 'pointer'
            }
        },
    });
});
define("@ijstech/markdown-editor/markdown-editor.ts", ["require", "exports", "@ijstech/base", "@ijstech/markdown", "@ijstech/text", "@ijstech/types", "@ijstech/text", "@ijstech/application", "@ijstech/markdown-editor/styles/index.css.ts"], function (require, exports, base_1, markdown_1, text_1, types_1, text_2, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MarkdownEditor = void 0;
    const TOOLBAR_ITEMS_DEFAULT = [
        ['heading', 'bold', 'italic', 'strike'],
        ['hr', 'quote'],
        ['ul', 'ol', 'task', 'indent', 'outdent'],
        ['table', 'image', 'link'],
        ['code', 'codeblock']
    ];
    base_1.RequireJS.config({
        paths: {
            'tui-color-picker': `${base_1.LibPath}lib/tui-editor/tui-color-picker.min.js`
        }
    });
    // const libs = [`${LibPath}lib/tui-editor/toastui-editor-all.min.js`];
    const libPlugins = [
        `${base_1.LibPath}lib/tui-editor/toastui-editor-all.min.js`,
        `${base_1.LibPath}lib/tui-editor/toastui-editor-plugin-color-syntax.min.js`,
        `${base_1.LibPath}lib/tui-editor/toastui-editor-plugin-table-merged-cell.min.js`,
        `${base_1.LibPath}lib/tui-editor/toastui-editor-plugin-uml.min.js`,
    ];
    const libSyntaxHighlightPlugin = [`${base_1.LibPath}lib/tui-editor/toastui-editor-plugin-code-syntax-highlight-all.min.js`];
    const unSupportedLang = ['zh-TW', 'zh-CN', 'jp'];
    const editorCSS = [
        { name: 'toastui-editor', href: `${base_1.LibPath}lib/tui-editor/toastui-editor.css` },
        { name: 'toastui-plugins', href: `${base_1.LibPath}lib/tui-editor/toastui-plugins.min.css` },
    ];
    let MarkdownEditor = class MarkdownEditor extends text_1.Text {
        setFocus() {
            if (this.editorObj) {
                this.editorObj.getCurrentModeEditor().el.querySelector('.toastui-editor-contents')?.click();
                this.editorObj.getCurrentModeEditor().moveCursorToStart(true);
            }
        }
        get mode() {
            return this._mode;
        }
        set mode(value) {
            this._mode = value;
            if (this.viewer)
                return;
            if (this.editorObj) {
                this.editorObj.changeMode(value, false);
            }
        }
        get theme() {
            return this._theme;
        }
        set theme(value) {
            this._theme = value;
            if (!this.editor) {
                if (this.mdViewer) {
                    this.mdViewer.theme = value;
                }
                return;
            }
            this.renderEditor(true);
        }
        get previewStyle() {
            return this._previewStyle;
        }
        set previewStyle(value) {
            this._previewStyle = value;
            if (this.viewer)
                return;
            if (this.editorObj) {
                this.editorObj.changePreviewStyle(value);
            }
        }
        get viewer() {
            return this._viewer;
        }
        set viewer(value) {
            if (this._viewer === value)
                return;
            this._viewer = value;
            if (!this.editor)
                return;
            this.renderEditor(true);
        }
        set designMode(value) {
            this._designMode = value;
        }
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
            if (this.viewer) {
                this.mdViewer.load(value);
            }
            else if (!this.viewer && this.editorObj && typeof this.editorObj.setMarkdown === 'function') {
                this.editorObj.setMarkdown(value);
            }
            // const targetObj = this.viewer ? this.viewerObj : this.editorObj;
            // if (targetObj) {
            //     targetObj.setMarkdown(value);
            // }
        }
        async setValue(value) {
            this._value = value;
            if (this.viewer) {
                await this.mdViewer.load(value);
            }
            else if (!this.viewer && this.editorObj && typeof this.editorObj.setMarkdown === 'function') {
                this.editorObj.setMarkdown(value);
            }
        }
        get height() {
            return this._heightValue;
        }
        set height(value) {
            this._heightValue = (0, base_1.getSpacingValue)(value);
            if (this.viewer)
                return;
            if (this.editorObj) {
                this.editorObj.setHeight(this._heightValue);
            }
        }
        get toolbarItems() {
            return this._toolbarItems || TOOLBAR_ITEMS_DEFAULT;
        }
        set toolbarItems(items) {
            this._toolbarItems = items;
            const toolbar = this.querySelector('.toastui-editor-toolbar');
            if (toolbar && !this.toolbarItems?.length)
                toolbar.style.display = 'none';
            if (!this.editor)
                return;
            this.renderEditor(true);
        }
        get plugins() {
            return this._customPlugins || [];
        }
        set plugins(plugins) {
            this._customPlugins = plugins;
            if (!this.editor)
                return;
            this.renderEditor(true);
        }
        get widgetRules() {
            return this._widgetRules || [];
        }
        set widgetRules(rules) {
            this._widgetRules = rules;
            if (!this.editor)
                return;
            this.renderEditor(true);
        }
        get hideModeSwitch() {
            return this._hideModeSwitch ?? false;
        }
        set hideModeSwitch(value) {
            this._hideModeSwitch = value ?? false;
        }
        get autoFocus() {
            return this._autoFocus;
        }
        set autoFocus(value) {
            this._autoFocus = value ?? false;
        }
        get placeholder() {
            return this.getTranslatedText(this._placeholder || '');
        }
        set placeholder(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._placeholder = value;
            if (this.editorObj)
                this.renderEditor(true);
        }
        getTranslatedText(value) {
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (!this.elm)
                return;
            if (!this._padding)
                this._padding = new base_1.SpaceValue(this.elm, value, 'padding');
            else
                this._padding.update(value);
            const { top = 0, right = 0, bottom = 0, left = 0 } = value;
            const padding = `${this._padding.getSpacingValue(top)} ${this._padding.getSpacingValue(right)} ${this._padding.getSpacingValue(bottom)} ${this._padding.getSpacingValue(left)}`;
            const ProseMirrors = this.querySelectorAll('.ProseMirror');
            for (let elm of ProseMirrors) {
                elm.style.padding = padding;
            }
            this.elm.style.padding = '';
        }
        get border() {
            return this._border;
        }
        set border(value) {
            if (!this.elm)
                return;
            this._border = new base_1.Border(this.elm, value);
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        constructor(parent, options) {
            super(parent, options);
            this.editorPlugins = [];
            this._theme = 'light';
            this._mode = 'markdown';
            this._previewStyle = 'vertical';
            this._value = '';
            this._viewer = false;
            this._heightValue = '500px';
            this._toolbarItems = TOOLBAR_ITEMS_DEFAULT;
            this._customPlugins = [];
            this._widgetRules = [];
            this._hideModeSwitch = false;
            this._placeholder = '';
            this._autoFocus = false;
            this.isPaste = false;
        }
        // private async loadLib() {
        //     return new Promise((resolve, reject) => {
        //         RequireJS.require(libs, async (marked: any) => {
        //             resolve(marked);
        //         });
        //     });
        // }
        async loadPlugin(plugin) {
            return new Promise((resolve, reject) => {
                base_1.RequireJS.require(plugin, async (editor, colorSyntax, tableMergedCell, uml) => {
                    this.editor = editor;
                    resolve([colorSyntax, tableMergedCell, uml]);
                });
            });
        }
        async loadSyntaxHighlightPlugin(plugin) {
            return new Promise((resolve, reject) => {
                base_1.RequireJS.require(plugin, async (codeSyntaxHighlight) => {
                    resolve([codeSyntaxHighlight]);
                });
            });
        }
        async loadPlugins() {
            // for (const _plugin of libPlugins) {
            //     this.editorPlugins[_plugin.name] = await this.loadPlugin(_plugin.path);
            // }
            const plugins = await this.loadPlugin(libPlugins);
            let codeSyntaxHighlight = [];
            if (!unSupportedLang.some(v => v.toLowerCase() === navigator.language?.toLowerCase())) {
                codeSyntaxHighlight = await this.loadSyntaxHighlightPlugin(libSyntaxHighlightPlugin);
            }
            this.editorPlugins = plugins.concat(codeSyntaxHighlight);
        }
        addCSS(href, name) {
            const css = document.head.querySelector(`[name="${name}"]`);
            if (css)
                return;
            let link = document.createElement('link');
            link.setAttribute('type', 'text/css');
            link.setAttribute('rel', 'stylesheet');
            link.setAttribute('name', name);
            link.href = href;
            document.head.append(link);
        }
        async initEditor() {
            // this.editor = await this.loadLib();
            if (!this.viewer) {
                for (const item of editorCSS) {
                    this.addCSS(item.href, item.name);
                }
                await this.loadPlugins();
            }
            try {
                this.renderEditor();
            }
            catch { }
        }
        renderEditor(valueChanged) {
            // const editorPlugins = Object.values(this.editorPlugins);
            const editorPlugins = [...this.editorPlugins].filter(Boolean);
            let padding = this.getAttribute('padding', true);
            let font = this.getAttribute('font', true);
            let border = this.getAttribute('border', true);
            if (this.viewer) {
                if (this.editorObj) {
                    this.editorObj.destroy();
                }
                if (!this.elm) {
                    this.elm = this.createElement('div', this);
                }
                else {
                    this.elm.innerHTML = '';
                    this.elm.style.height = 'auto';
                }
                // this.viewerObj = this.editor.factory({
                //     el: this.elm,
                //     viewer: true,
                //     initialValue: this.value,
                //     theme: this.theme,
                //     plugins: [...editorPlugins, ...this.plugins],
                //     widgetRules: this.widgetRules,
                // });
                this.mdViewer = new markdown_1.Markdown();
                if (padding)
                    this.mdViewer.padding = padding;
                if (font)
                    this.mdViewer.font = font;
                this.mdViewer.theme = this.theme;
                this.elm.appendChild(this.mdViewer);
            }
            else {
                // if (this.viewerObj) {
                //     this.viewerObj.destroy();
                // }
                if (!this.elm) {
                    this.elm = this.createElement('div', this);
                }
                else {
                    this.elm.innerHTML = '';
                }
                this.overlayElm.style.display = this._designMode ? 'block' : 'none';
                const currentValue = valueChanged && this.editorObj ? this.editorObj.getMarkdown() : this.value;
                this.editorObj = new this.editor({
                    el: this.elm,
                    previewStyle: this.previewStyle,
                    height: this.height,
                    initialEditType: this.mode,
                    initialValue: currentValue,
                    theme: this.theme,
                    toolbarItems: this.toolbarItems,
                    plugins: [...editorPlugins, ...this.plugins],
                    widgetRules: this.widgetRules,
                    hideModeSwitch: this.hideModeSwitch,
                    minHeight: this.minHeight ?? '300px',
                    placeholder: this.placeholder,
                    autofocus: this._designMode ? false : this.autoFocus,
                    events: {
                        change: (event) => {
                            if (this._designMode)
                                return;
                            if (this.isPaste) {
                                this.isPaste = false;
                                this.editorObj.setMarkdown(this.editorObj.getMarkdown(), false);
                                return;
                            }
                            if (typeof this.onObserverChanged === 'function')
                                this.onObserverChanged(this, event);
                            if (typeof this.onChanged === 'function')
                                this.onChanged(this, event);
                        },
                        focus: (event, data) => {
                            if (this._designMode)
                                return;
                            if (this.onFocus)
                                this.onFocus(this, event);
                        },
                        blur: (event) => {
                            if (this.onBlur)
                                this.onBlur(this, event);
                        },
                        keydown: (target, event) => {
                            const isPaste = event.ctrlKey && event.key === "v";
                            this.isPaste = isPaste && this.editorObj && this._widgetRules?.length > 0;
                            if (this._designMode) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        },
                        keyup: (target, event) => {
                            if (this._designMode) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                });
                if (this.autoFocus) {
                    this.editorObj.getCurrentModeEditor().el.querySelector('.toastui-editor-contents')?.click();
                    this.editorObj.getCurrentModeEditor().moveCursorToStart(true);
                }
                if (this.theme === 'light')
                    this.elm.classList.remove('toastui-editor-dark');
                const toolbar = this.querySelector('.toastui-editor-toolbar');
                if (toolbar && !this.toolbarItems?.length)
                    toolbar.style.display = 'none';
                if (!this._padding && padding)
                    this.padding = padding;
            }
            this.elm.style.background = 'inherit';
            this.elm.style.fontSize = 'inherit';
            if (border) {
                this._border = new base_1.Border(this.elm, border);
                this.style.border = 'none';
                this.style.borderRadius = 'unset';
            }
        }
        getMarkdownValue() {
            if (this.editorObj && !this.viewer) {
                return this.editorObj.getMarkdown();
            }
            return '';
        }
        getEditorElm() {
            if (this.editorObj && !this.viewer) {
                return this.editorObj;
            }
            return null;
        }
        getViewerElm() {
            // if (this.viewerObj && this.viewer) {
            //     return this.viewerObj;
            // }
            if (this.mdViewer)
                return this.mdViewer;
            return null;
        }
        async init() {
            super.init();
            this.onChanged = this.getAttribute('onChanged', true) || this.onChanged;
            this.onFocus = this.getAttribute('onFocus', true) || this.onFocus;
            this.onBlur = this.getAttribute('onBlur', true) || this.onBlur;
            this.overlayElm = this.createElement('div', this);
            this.overlayElm.classList.add('overlay');
            const mode = this.getAttribute('mode', true, '');
            if (mode) {
                this._mode = mode;
            }
            const previewStyle = this.getAttribute('previewStyle', true, '');
            if (previewStyle) {
                this._previewStyle = previewStyle;
            }
            const value = this.getAttribute('value', true, '');
            if (value) {
                this._value = value;
            }
            const viewer = this.getAttribute('viewer', true, null);
            if (viewer !== null) {
                this.viewer = viewer;
            }
            const height = this.getAttribute('height', true, '');
            if (height) {
                this._heightValue = height;
            }
            const width = this.getAttribute('width', true, '');
            if (width) {
                this.width = width;
            }
            const theme = this.getAttribute('theme', true, '');
            if (theme) {
                this._theme = theme;
            }
            const toolbarItems = this.getAttribute('toolbarItems', true, '');
            if (toolbarItems) {
                this._toolbarItems = toolbarItems;
            }
            const plugins = this.getAttribute('plugins', true, '');
            if (plugins) {
                this._customPlugins = plugins;
            }
            const widgetRules = this.getAttribute('widgetRules', true, '');
            if (widgetRules) {
                this._widgetRules = widgetRules;
            }
            this._placeholder = this.getAttribute('placeholder', true, '');
            this._hideModeSwitch = this.getAttribute('hideModeSwitch', true, false);
            this.autoFocus = this.getAttribute('autoFocus', true, false);
            this.initEditor();
        }
    };
    MarkdownEditor = __decorate([
        (0, base_1.customElements)('i-markdown-editor', {
            icon: 'pen-square',
            group: types_1.GroupType.FIELDS,
            className: 'MarkdownEditor',
            props: {
                mode: { type: 'string', default: '' },
                theme: { type: 'string' },
                previewStyle: { type: 'string' },
                hideModeSwitch: { type: 'boolean', default: false },
                value: { type: 'string' },
                viewer: { type: 'boolean', default: false },
                toolbarItems: { type: 'array' },
                plugins: { type: 'array' },
                widgetRules: { type: 'array' },
                placeholder: { type: 'string', default: '' },
                ...text_2.textPropsConfig
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    value: {
                        type: 'string'
                    },
                    mode: {
                        type: 'string',
                        enum: ['wysiwyg', 'markdown']
                    },
                    previewStyle: {
                        type: 'string',
                        enum: ['tab', 'vertical']
                    },
                    hideModeSwitch: {
                        type: 'boolean',
                        format: 'boolean'
                    },
                    viewer: {
                        type: 'boolean',
                        format: 'boolean'
                    },
                    placeholder: {
                        type: 'string'
                    },
                    ...text_2.textDataSchema,
                }
            }
        })
    ], MarkdownEditor);
    exports.MarkdownEditor = MarkdownEditor;
});
define("@ijstech/markdown-editor", ["require", "exports", "@ijstech/markdown-editor/markdown-editor.ts"], function (require, exports, markdown_editor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MarkdownEditor = void 0;
    Object.defineProperty(exports, "MarkdownEditor", { enumerable: true, get: function () { return markdown_editor_1.MarkdownEditor; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/menu/style/menu.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modalStyle = exports.meunItemStyle = exports.menuStyle = void 0;
    let Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-context-menu', {
        display: 'none'
    });
    Styles.cssRule('i-menu', {
        display: 'block'
    });
    const fadeInRight = Styles.keyframes({
        "0%": {
            opacity: 0,
            transform: "translate3d(100%, 0, 0)",
        },
        "100%": {
            opacity: 1,
            transform: "translate3d(0, 0, 0)",
        },
    });
    exports.menuStyle = Styles.style({
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        color: Theme.text.primary,
        position: "relative",
        // overflow: 'hidden',
        $nest: {
            "*": {
                boxSizing: "border-box",
            },
            ".menu": {
                display: "block",
                margin: 0,
                padding: 0,
                listStyle: "none"
            },
            ".menu-horizontal": {
                display: "flex",
                flexWrap: 'nowrap'
            },
            ".menu-inline": {
                $nest: {
                    ".menu-item": {
                        paddingLeft: 'calc(1.5rem + var(--menu-item-level, 0) * 1rem)'
                    },
                    ".menu-item-arrow": {
                        marginTop: '-14px',
                        right: '6px',
                        padding: '8px',
                    },
                    ".menu-item-arrow-active": {
                        transform: 'rotate(180deg)',
                        transition: 'transform 0.25s',
                        fill: `${Theme.text.primary} !important`
                    },
                    "li": {
                        position: "relative",
                        $nest: {
                            "&:hover": {
                                $nest: {
                                    ".menu-item": {
                                        color: Theme.colors.primary.main,
                                    },
                                    ".menu-item-arrow-active": {
                                        fill: 'currentColor !important',
                                    },
                                },
                            },
                        },
                    },
                }
            }
        }
    });
    exports.meunItemStyle = Styles.style({
        position: 'relative',
        display: 'block',
        // color: Theme.text.secondary,
        $nest: {
            ".menu-item": {
                position: "relative",
                display: "inline-flex",
                padding: "0 1.5rem",
                border: 0,
                borderRadius: 5,
                cursor: "pointer",
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
                lineHeight: "36px",
                width: "100%",
                justifyContent: 'var(--custom-text-align, left)',
                alignItems: 'center'
            },
            "&:not(.hide-arrow-icon) .menu-item.has-children": {
                paddingRight: "2.25rem"
            },
            ".menu-item.menu-active, .menu-item.menu-selected, .menu-item:hover": {
                background: Theme.action.hoverBackground,
                color: Theme.action.hover,
            },
            '.menu-item.menu-active > .menu-item-arrow': {
                transform: 'rotate(180deg)',
                transition: 'transform 0.25s'
            },
            ".menu-item-arrow": {
                position: "absolute",
                top: "50%",
                right: 18,
                marginTop: -6,
                cursor: 'pointer',
            },
            ".menu-item-icon": {
                display: "inline-block",
                verticalAlign: 'middle',
                marginRight: "8px",
                textAlign: "center",
                fill: "currentColor",
                flexShrink: '0',
                $nest: {
                    "> i-image": {
                        display: 'flex'
                    }
                }
            },
            "i-link, a": {
                display: "block"
            },
            "i-link > a": {
                textDecoration: 'unset'
            },
            'i-link:hover *': {
                color: "unset"
            },
            'li': {
                listStyle: "none"
            },
            '&.hide-arrow-icon .menu-item-arrow': {
                display: 'none'
            },
        }
    });
    exports.modalStyle = Styles.style({
        $nest: {
            '.reverse-menu': {
                display: 'flex',
                flexDirection: 'column-reverse'
            },
            "> div": {
                transform: "unset",
                transition: "background 0.2s cubic-bezier(0.4, 0, 1, 1), color 0.2s cubic-bezier(0.4, 0, 1, 1)",
                overflow: "visible"
            },
            ".modal": {
                boxShadow: 'rgb(0 0 0 / 10%) 0px 0px 5px 0px, rgb(0 0 0 / 10%) 0px 0px 1px 0px',
                minWidth: 0,
                padding: 0,
                borderRadius: '5px'
            }
        }
    });
});
define("@ijstech/menu/menu.ts", ["require", "exports", "@ijstech/base", "@ijstech/link", "@ijstech/icon", "@ijstech/modal", "@ijstech/layout", "@ijstech/menu/style/menu.css.ts", "@ijstech/types", "@ijstech/style", "@ijstech/application"], function (require, exports, base_1, link_1, icon_1, modal_1, layout_1, menu_css_1, types_1, Styles, application_1) {
    "use strict";
    var MenuItem_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItem = exports.ContextMenu = exports.Menu = void 0;
    const Theme = Styles.Theme.ThemeVars;
    ;
    ;
    ;
    ;
    const menuPopupTimeout = 150;
    const DEFAULT_VALUES = {
        mode: 'horizontal'
    };
    let Menu = class Menu extends base_1.Control {
        constructor() {
            super(...arguments);
            this._oldWidth = 0;
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            for (let item of this._items) {
                item.updateLocale(i18n);
            }
        }
        add(options) {
            const newItem = new MenuItem(this, { ...(options || {}), linkTo: this, level: 0 });
            this.menuElm.appendChild(newItem);
            this._items.push(newItem);
            this._data.push(options || {});
            if (this._mode === 'horizontal')
                this.handleResize();
            return newItem;
        }
        ;
        delete(item) {
            const index = this.items.findIndex(menu => menu.isEqualNode(item));
            if (index !== -1) {
                this.menuElm.removeChild(item);
                this._items.splice(index, 1);
                this._data.splice(index, 1);
                item.remove();
                if (this._mode === 'horizontal')
                    this.handleResize();
            }
        }
        get mode() {
            return this._mode;
        }
        set mode(value) {
            if (this._mode === value)
                return;
            if (this._mode) {
                this.menuElm.classList.remove(`menu-${this._mode}`);
            }
            this._mode = value;
            this.menuElm.classList.add(`menu-${this._mode}`);
            this.handleUpdateMode(value);
        }
        get data() {
            return this._data;
        }
        set data(value) {
            this.clear();
            this._data = value;
            this.renderItem(value);
        }
        get items() {
            return this._items;
        }
        set items(items) {
            this.clear();
            this._items = items;
            this.menuElm.innerHTML = "";
            if (items && items.length) {
                this.updateItemOptions(items);
                this.menuElm.append(...items);
                if (this._mode === 'horizontal')
                    this.handleResize();
            }
        }
        get selectedItem() {
            return this._selectedItem;
        }
        set selectedItem(item) {
            if (item == null) {
                if (this._selectedItem) {
                    this._selectedItem.selected = false;
                }
                this._selectedItem = undefined;
            }
            else {
                this._selectedItem = item;
                this._selectedItem.selected = true;
            }
        }
        updateItemOptions(items, level = 0) {
            if (!items || !items?.length)
                return;
            for (let item of items) {
                item.linkTo = this;
                item.level = level;
                if (item.children?.length) {
                    let items = [];
                    for (let child of item.children) {
                        if (child instanceof MenuItem) {
                            items.push(child);
                        }
                    }
                    this.updateItemOptions(items, level + 1);
                    item.items = items;
                }
            }
        }
        get menuItems() {
            if (this.moreItem) {
                return [...this.items, ...(this.moreItem?.items || [])];
            }
            return this.items;
        }
        clear() {
            this._items = [];
            this.itemsWidth = [];
            this.menuElm.innerHTML = "";
            if (this.moreItem)
                this.moreItem.items = [];
        }
        async renderItem(items) {
            const _items = [];
            const menuItemElm = [];
            for (const item of items) {
                const menuItem = await MenuItem.create({ ...item, linkTo: this, level: 0 }, this);
                menuItemElm.push(menuItem);
                _items.push(menuItem);
            }
            this.menuElm.innerHTML = "";
            ``;
            this.menuElm.append(...menuItemElm);
            this._items = _items;
            if (this._mode === 'horizontal')
                this.handleResize();
            if (this.parentModule?.i18n)
                this.updateLocale(this.parentModule.i18n);
        }
        async handleUpdateMode(mode) {
            if (this._mode === 'horizontal') {
                if (!this.moreItem) {
                    this.moreItem = await MenuItem.create({ title: '\u22EF', linkTo: this, level: 0 });
                    this.moreItem.classList.add('more-menu-item', 'hide-arrow-icon');
                }
                window.addEventListener('resize', this.handleResize);
            }
            else {
                window.removeEventListener('resize', this.handleResize);
                if (this.moreItem && this.menuElm.contains(this.moreItem))
                    this.menuElm.removeChild(this.moreItem);
            }
            this.rerenderItems(this._items);
        }
        rerenderItems(items) {
            if (items?.length) {
                for (let item of items) {
                    if (item.items?.length) {
                        item.items = [...item.items];
                        this.rerenderItems(item.items);
                    }
                }
            }
        }
        onResize() {
            const newWidth = Math.ceil(window.innerWidth);
            let offsetWidth = Math.ceil(this.menuElm.offsetWidth);
            let scrollWidth = Math.ceil(this.menuElm.scrollWidth);
            if (this._oldWidth >= newWidth) {
                let i = this._items.length - 1;
                const tmpItems = [];
                while (scrollWidth > offsetWidth && i >= 0) {
                    if (!this.menuElm.contains(this.moreItem)) {
                        this.menuElm.appendChild(this.moreItem);
                    }
                    this.itemsWidth.push(this._items[i].offsetWidth);
                    tmpItems.push(this._items[i]);
                    this._items[i].level = 1;
                    this.menuElm.removeChild(this._items[i]);
                    this._items.splice(i, 1);
                    offsetWidth = Math.ceil(this.menuElm.offsetWidth);
                    scrollWidth = Math.ceil(this.menuElm.scrollWidth);
                    i--;
                }
                if (tmpItems.length) {
                    const moreItems = this.moreItem?.items || [];
                    this.moreItem.items = [...moreItems, ...tmpItems];
                }
            }
            else if (this._oldWidth <= newWidth && this.moreItem?.items?.length) {
                let i = this.moreItem.items.length - 1 || 0;
                let totalItemsWidth = this._items.reduce((prev, curr) => prev + Math.ceil(curr.offsetWidth), 0) + this.moreItem.offsetWidth + this.itemsWidth[0];
                let index = -1;
                while (totalItemsWidth <= offsetWidth && i >= 0) {
                    index = i;
                    const menuItem = this.moreItem.items[i];
                    this.menuElm.insertBefore(menuItem, this.moreItem);
                    this._items.push(menuItem);
                    menuItem.level = 0;
                    offsetWidth = Math.ceil(this.menuElm.offsetWidth);
                    totalItemsWidth += this.itemsWidth.shift() || 0;
                    i--;
                }
                if (index != -1) {
                    this.moreItem.items = this.moreItem.items.slice(0, index);
                }
                if (!this.moreItem.items.length && this.menuElm.contains(this.moreItem)) {
                    this.menuElm.removeChild(this.moreItem);
                }
            }
            this._oldWidth = newWidth;
        }
        handleResize() {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.onResize();
            }, 200);
        }
        init() {
            if (!this.initialized) {
                let menuItems = [];
                for (let i = 0; i < this.children.length; i++) {
                    const child = this.children[i];
                    if (child instanceof MenuItem) {
                        menuItems.push(child);
                    }
                    else {
                        child.remove();
                    }
                }
                super.init();
                this.classList.add(menu_css_1.menuStyle);
                this.itemsWidth = [];
                this.handleResize = this.handleResize.bind(this);
                this.onResize = this.onResize.bind(this);
                this.menuElm = this.createElement("ul", this);
                this.menuElm.classList.add("menu");
                this.mode = this.getAttribute('mode', true, DEFAULT_VALUES.mode);
                this.data = this.getAttribute('data', true, []);
                const items = this.getAttribute('items', true, []);
                if (menuItems?.length)
                    this.items = menuItems;
                else if (items?.length)
                    this.items = items;
            }
        }
        disconnectedCallback() {
            window.removeEventListener("resize", this.handleResize);
            super.disconnectedCallback();
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Menu = __decorate([
        (0, base_1.customElements)('i-menu', {
            icon: 'bars',
            group: types_1.GroupType.BASIC,
            className: 'Menu',
            props: {
                mode: {
                    type: 'string',
                    default: DEFAULT_VALUES.mode
                },
                data: { type: 'array', default: [] }
            },
            events: {
                onItemClick: [
                    { name: 'target', type: 'Menu', isControl: true },
                    { name: 'item', type: 'MenuItem', isControl: true }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    mode: {
                        type: 'string',
                        enum: ['horizontal', 'vertical', 'inline'],
                        default: DEFAULT_VALUES.mode
                    }
                }
            }
        })
    ], Menu);
    exports.Menu = Menu;
    let ContextMenu = class ContextMenu extends Menu {
        show(pos) {
            const { x, y } = pos;
            this.handleModalOpen(x, y);
        }
        hide() {
            clearTimeout(this.openTimeout);
            if (this.modal) {
                this.modal.visible = false;
            }
        }
        async renderItemModal(x, y) {
            const background = this.getAttribute('background', true);
            const font = this.getAttribute('font', true);
            const minWidth = this.getAttribute('minWidth', true);
            if (!this.modal) {
                this.modal = await modal_1.Modal.create({
                    showBackdrop: false,
                    height: 'auto',
                    width: 'auto',
                    popupPlacement: 'right',
                    font: font || { color: Theme.text.primary },
                    minWidth: minWidth || 'auto'
                });
                this.modal.classList.add(menu_css_1.modalStyle);
                this.modal.visible = false;
                this.getModalContainer().appendChild(this.modal);
                this.getModalContainer().style.position = 'fixed';
            }
            if (background?.color) {
                this.modal.background = background;
            }
            if (font) {
                this.modal.font = font;
            }
            this.getModalContainer().style.left = `${x}px`;
            this.getModalContainer().style.top = `${y}px`;
            this.getModalContainer().style.zIndex = `9999`;
            if (!this.itemPanel)
                this.itemPanel = await layout_1.Panel.create();
            this.itemPanel.innerHTML = "";
            if (this.items && this.items.length) {
                if (font) {
                    for (let item of this.items) {
                        item.font = font;
                    }
                }
                this.itemPanel.append(...this.items);
            }
            this.modal.item = this.itemPanel;
        }
        getModalContainer() {
            let span = document.getElementById("modal-context");
            if (!span) {
                span = this.createElement("span", document.body);
                span.id = "modal-context";
            }
            return span;
        }
        async handleModalOpen(x, y) {
            await this.renderItemModal(x, y);
            clearTimeout(this.openTimeout);
            this.openTimeout = setTimeout(() => {
                if (this.items && this.items.length)
                    this.modal.visible = true;
            }, menuPopupTimeout);
        }
    };
    ContextMenu = __decorate([
        (0, base_1.customElements)('i-context-menu')
    ], ContextMenu);
    exports.ContextMenu = ContextMenu;
    ;
    const DEFAULT_ITEM = {
        target: '_blank',
        textAlign: 'left'
    };
    let MenuItem = MenuItem_1 = class MenuItem extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this._level = 0;
            this._textAlign = DEFAULT_ITEM.textAlign;
        }
        add(options) {
            const newItem = new MenuItem_1(this, options);
            if (!this._items)
                this._items = [];
            this._items.push(newItem);
            newItem.level = this._level + 1;
            newItem.linkTo = this._linkTo;
            this.items = this._items;
            return newItem;
        }
        ;
        delete(item) {
            const index = this.items.findIndex(menu => menu.isEqualNode(item));
            if (index !== -1) {
                let mode = this.menuMode();
                if (mode === 'inline') {
                    this.subMenu.removeChild(item);
                }
                this._items.splice(index, 1);
                item.remove();
            }
        }
        ;
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.captionElm && this._caption?.startsWith('$'))
                this.captionElm.textContent = i18n.get(this._caption) || '';
        }
        get title() {
            return this._caption;
        }
        set title(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (this.captionElm) {
                if (value?.startsWith('$')) {
                    const translated = this.linkTo?.parentModule?.i18n?.get(value) ||
                        application_1.application.i18n?.get(value) ||
                        '';
                    this.captionElm.textContent = translated;
                }
                else
                    this.captionElm.textContent = value || '';
            }
        }
        set font(value) {
            if (!this.itemWrapperElm)
                return;
            this.itemWrapperElm.style.color = value.color || '';
            this.itemWrapperElm.style.fontSize = value.size || '';
            this.itemWrapperElm.style.fontFamily = value.name || '';
            this.itemWrapperElm.style.fontStyle = value.style || '';
            this.itemWrapperElm.style.textTransform = value.transform || 'none';
            this.itemWrapperElm.style.fontWeight = value.bold ? 'bold' : `${value.weight || ''}`;
            this.itemWrapperElm.style.textShadow = value.shadow || 'none';
        }
        get font() {
            if (!this.itemWrapperElm)
                return {};
            return {
                color: this.itemWrapperElm.style.color,
                name: this.itemWrapperElm.style.fontFamily,
                size: this.itemWrapperElm.style.fontSize,
                bold: this.itemWrapperElm.style.fontStyle.indexOf('bold') >= 0,
                style: this.itemWrapperElm.style.fontStyle,
                transform: this.itemWrapperElm.style.textTransform,
                weight: this.itemWrapperElm.style.fontWeight,
                shadow: this.itemWrapperElm.style.textShadow
            };
        }
        get link() {
            if (!this._link) {
                this._link = link_1.Link.create({
                    href: '#',
                    target: '_self',
                    font: this.font,
                    designMode: this.linkTo?.designMode
                }, this);
            }
            return this._link;
        }
        set link(value) {
            if (this._link) {
                this._link.prepend(this.itemWrapperElm);
                this._link.remove();
            }
            this._link = value;
            if (this._link) {
                this._link.designMode = this.linkTo?.designMode;
                this._link.append(this.itemWrapperElm);
                this.itemElm.appendChild(this._link);
            }
            else {
                this.itemElm.appendChild(this.itemWrapperElm);
            }
        }
        get icon() {
            if (!this._icon) {
                this._icon = icon_1.Icon.create({
                    width: 16,
                    height: 16
                }, this);
            }
            ;
            return this._icon;
        }
        set icon(elm) {
            if (this._icon)
                this.itemWrapperElm.removeChild(this._icon);
            this._icon = elm;
            if (this._icon) {
                this.icon.classList.add("menu-item-icon");
                this.itemWrapperElm.prepend(this._icon);
            }
        }
        get items() {
            return this._items;
        }
        set items(items) {
            this._items = items;
            for (let item of this._items) {
                item.remove();
                if (!item.linkTo)
                    item.linkTo = this._linkTo;
                if (item._level == 0)
                    item.level = (this._level || 0) + 1;
            }
            this.renderArrowIcon();
            this.renderSubMenuItem();
        }
        get textAlign() {
            return this._textAlign;
        }
        set textAlign(value) {
            this._textAlign = value;
            this.style.setProperty('--custom-text-align', value);
        }
        set level(value) {
            this.updateLevel(value);
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (!this.itemWrapperElm)
                return;
            if (!this._padding)
                this._padding = new base_1.SpaceValue(this.itemWrapperElm, value, 'padding');
            else
                this._padding.update(value);
        }
        set selected(value) {
            if (value) {
                this.setSelectedItem();
            }
            else {
                this.isSelected = false;
                if (this.subMenu) {
                    this.subMenu.style.display = 'none';
                }
            }
        }
        get isSelected() {
            return this.itemWrapperElm.classList.contains("menu-selected");
        }
        set isSelected(value) {
            if (!this.itemWrapperElm)
                return;
            const isInline = this.menuMode() === 'inline';
            if (value) {
                this.itemWrapperElm.classList.add("menu-selected");
                if (this.arrowIcon && isInline) {
                    this.arrowIcon.classList.add("menu-item-arrow-active");
                }
            }
            else {
                this.itemWrapperElm.classList.remove("menu-selected");
                if (this.arrowIcon && isInline) {
                    this.arrowIcon.classList.remove("menu-item-arrow-active");
                }
            }
        }
        updateLevel(level) {
            if (this._linkTo) {
                this._level = level;
                if (this.modal) {
                    this.modal.popupPlacement = this.getModalPlacement();
                    if (this._level > 0) {
                        this.modal.position = "absolute";
                        this.appendChild(this.modal);
                    }
                    else {
                        this.modal.position = "fixed";
                        this.getModalContainer().appendChild(this.modal);
                    }
                }
            }
        }
        menuMode() {
            let mode = DEFAULT_VALUES.mode;
            if (this._linkTo) {
                mode = this._linkTo.mode;
            }
            return mode;
        }
        async renderArrowIcon() {
            const isInline = this.menuMode() === 'inline';
            if (!this.arrowIcon) {
                this.arrowIcon = await icon_1.Icon.create({
                    name: "chevron-down",
                    fill: 'currentColor'
                });
                this.arrowIcon.classList.add("menu-item-arrow");
            }
            this.arrowIcon.width = isInline ? 30 : 12;
            this.arrowIcon.height = isInline ? 30 : 12;
            if (this._items && this._items.length) {
                if (!isInline && !this.itemWrapperElm.contains(this.arrowIcon)) {
                    this.itemWrapperElm.appendChild(this.arrowIcon);
                }
                else if (isInline && !this.itemElm.contains(this.arrowIcon)) {
                    this.itemElm.appendChild(this.arrowIcon);
                }
                this.itemWrapperElm.classList.add("has-children");
            }
            else {
                if (!isInline && this.itemWrapperElm.contains(this.arrowIcon)) {
                    this.itemWrapperElm.removeChild(this.arrowIcon);
                }
                else if (isInline && this.itemElm.contains(this.arrowIcon)) {
                    this.itemElm.removeChild(this.arrowIcon);
                }
                this.itemWrapperElm.classList.remove("has-children");
            }
        }
        renderSubMenuItem() {
            let mode = this.menuMode();
            if (mode === 'inline') {
                this.itemWrapperElm.style.setProperty('--menu-item-level', this._level.toString());
                if (!this._items.length && !this.subMenu)
                    return;
                this.itemElm.removeEventListener('mouseenter', this.handleModalOpen);
                this.itemElm.removeEventListener('mouseleave', this.handleModalClose);
                if (this.modal) {
                    this.modal.removeEventListener('mouseenter', this.handleModalOpen);
                    this.modal.removeEventListener('mouseleave', this.handleModalClose);
                    this.modal.remove();
                }
                if (!this.subMenu) {
                    this.subMenu = this.createElement('div', this);
                    this.subMenu.classList.add("sub-menu");
                    this.subMenu.style.display = 'none';
                }
                this.subMenu.append(...this.items);
            }
            else {
                if (this.items && this.items.length) {
                    this.itemElm.addEventListener('mouseenter', this.handleModalOpen);
                    this.itemElm.addEventListener('mouseleave', this.handleModalClose);
                }
                else {
                    this.itemElm.removeEventListener('mouseenter', this.handleModalOpen);
                    this.itemElm.removeEventListener('mouseleave', this.handleModalClose);
                }
                if (this.subMenu) {
                    this.subMenu.remove();
                }
                this.itemWrapperElm.style.removeProperty('--menu-item-level');
            }
        }
        async renderItemModal() {
            if (!this.modal) {
                const placement = this.getModalPlacement();
                this.modal = await modal_1.Modal.create({
                    showBackdrop: false,
                    height: 'auto',
                    width: 'auto',
                    popupPlacement: placement
                });
                this.modal.linkTo = this;
                this.modal.visible = false;
                this.modal.classList.add("menu-item-modal", menu_css_1.modalStyle);
                this.modal.addEventListener('mouseenter', this.handleModalOpen);
                this.modal.addEventListener('mouseleave', this.handleModalClose);
                if (this._level > 0) {
                    this.appendChild(this.modal);
                }
                else {
                    this.modal.position = "fixed";
                    this.getModalContainer().appendChild(this.modal);
                }
            }
            if (!this.itemPanel) {
                this.itemPanel = await layout_1.Panel.create();
                if (this.className.includes('more-menu-item')) {
                    this.itemPanel.classList.add('reverse-menu');
                }
            }
            this.itemPanel.innerHTML = "";
            if (this._items?.length) {
                this.itemPanel.append(...this._items);
            }
            this.modal.item = this.itemPanel;
        }
        getModalPlacement() {
            let mode = this.menuMode();
            let placement = "bottomLeft";
            switch (mode) {
                case "vertical":
                    placement = "right";
                    break;
                case "horizontal":
                    placement = this._level > 0 ? 'right' : 'bottomLeft';
            }
            return placement;
        }
        getModalContainer() {
            let span = document.getElementById("modal-container");
            if (!span) {
                span = this.createElement("span", document.body);
                span.id = "modal-container";
            }
            return span;
        }
        setSelectedItem() {
            if (this._linkTo) {
                let mode = this._linkTo.mode;
                this.isSelected = this.items && this.items.length ? !this.isSelected : true;
                if (this.subMenu) {
                    this.subMenu.style.display = this.isSelected ? 'block' : 'none';
                }
                this.handleSelectItem(this._linkTo.menuItems, mode);
            }
            else {
                this.isSelected = true;
            }
        }
        handleSelectItem(items, mode) {
            items.forEach(item => {
                const isCurrItem = item.isSameNode(this);
                if (isCurrItem)
                    return;
                const containsItem = item.contains(this);
                if (!isCurrItem)
                    item.isSelected = containsItem ? this.isSelected : false;
                if (mode === 'inline' && item.subMenu && !containsItem) {
                    item.subMenu.style.display = 'none';
                }
                if (item.items)
                    this.handleSelectItem(item.items, mode);
            });
        }
        _handleClick(event) {
            if (this._designMode)
                return false;
            if (this._linkTo) {
                this._linkTo.selectedItem = this;
            }
            else {
                this.setSelectedItem();
            }
            if (this._linkTo?.onItemClick && typeof this._linkTo.onItemClick === 'function')
                this._linkTo.onItemClick(this._linkTo, this);
            return super._handleClick(event, true);
        }
        async handleModalOpen(event) {
            if (this._designMode)
                return false;
            await this.renderItemModal();
            clearTimeout(this.closeTimeout);
            this.itemWrapperElm.classList.add("menu-active");
            this.openTimeout = setTimeout(() => {
                if (this._items && this._items.length)
                    this.modal.visible = true;
            }, menuPopupTimeout);
        }
        handleModalClose(event) {
            if (this._designMode)
                return false;
            clearTimeout(this.openTimeout);
            this.itemWrapperElm.classList.remove("menu-active");
            this.closeTimeout = setTimeout(() => {
                if (this.modal)
                    this.modal.visible = false;
            }, menuPopupTimeout);
        }
        init() {
            if (!this.initialized) {
                super.init();
                this.classList.add(menu_css_1.meunItemStyle);
                this.handleModalOpen = this.handleModalOpen.bind(this);
                this.handleModalClose = this.handleModalClose.bind(this);
                this.itemElm = this.createElement("li", this);
                this.itemWrapperElm = this.createElement("div", this.itemElm);
                this.itemWrapperElm.classList.add("menu-item");
                if (this._linkTo?.padding) {
                    const padding = this._linkTo.padding;
                    this._padding = new base_1.SpaceValue(this.itemWrapperElm, padding, 'padding');
                    this._linkTo.style.padding = '';
                }
                this.captionElm = this.createElement("span", this.itemWrapperElm);
                this.level = this.getAttribute('level', true, 0);
                this.title = this.getAttribute('title', true);
                const textAlign = this.getAttribute('textAlign', true);
                if (textAlign)
                    this.textAlign = textAlign;
                const link = this.getAttribute('link', true);
                if (link?.href) {
                    link.target = link.target || "_self";
                    this.link = new link_1.Link(this, { ...link, designMode: this.linkTo?.designMode });
                }
                const icon = this.getAttribute('icon', true);
                if (icon?.name || icon?.image?.url) {
                    icon.height = icon.height || '16px';
                    icon.width = icon.width || '16px';
                    this.icon = new icon_1.Icon(this, icon);
                }
                ;
                const _items = this.getAttribute('items', true, []);
                if (_items?.length) {
                    let menuItems = [];
                    for (const item of _items) {
                        const menuItem = new MenuItem_1(undefined, { ...item, linkTo: this._linkTo, level: this._level + 1 });
                        menuItems.push(menuItem);
                    }
                    this.items = menuItems;
                }
                const font = this.getAttribute('font', true);
                if (font)
                    this.font = font;
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    MenuItem = MenuItem_1 = __decorate([
        (0, base_1.customElements)('i-menu-item', {
            icon: 'bars',
            className: 'MenuItem',
            props: {
                title: { type: 'string', default: '' },
                link: {
                    type: 'object',
                    default: { target: DEFAULT_ITEM.target }
                },
                items: { type: 'array', default: [] },
                icon: { type: 'object', default: {} },
                textAlign: { type: 'string', default: DEFAULT_ITEM.textAlign }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    title: {
                        type: 'string'
                    },
                    icon: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string'
                            },
                            width: {
                                type: 'number'
                            },
                            height: {
                                type: 'number'
                            },
                            fill: {
                                type: 'string',
                                format: 'color'
                            },
                            image: {
                                type: 'object',
                                properties: {
                                    url: {
                                        type: 'string'
                                    }
                                }
                            }
                        }
                    },
                    link: {
                        type: 'object',
                        properties: {
                            href: {
                                type: 'string'
                            },
                            target: {
                                type: 'string',
                                enum: ['_blank', '_self', '_parent', '_top'],
                                default: DEFAULT_ITEM.target
                            }
                        }
                    },
                    textAlign: {
                        type: 'string',
                        enum: ['left', 'right', 'center'],
                        default: DEFAULT_ITEM.textAlign
                    }
                }
            }
        })
    ], MenuItem);
    exports.MenuItem = MenuItem;
});
define("@ijstech/menu", ["require", "exports", "@ijstech/menu/menu.ts"], function (require, exports, menu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItem = exports.ContextMenu = exports.Menu = void 0;
    Object.defineProperty(exports, "Menu", { enumerable: true, get: function () { return menu_1.Menu; } });
    Object.defineProperty(exports, "ContextMenu", { enumerable: true, get: function () { return menu_1.ContextMenu; } });
    Object.defineProperty(exports, "MenuItem", { enumerable: true, get: function () { return menu_1.MenuItem; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/tree-view/style/treeView.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-tree-view', {
        display: 'block',
        overflowY: 'auto',
        overflowX: 'hidden',
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        $nest: {
            '.i-tree-node_content': {
                display: 'flex',
                alignItems: 'center',
                paddingLeft: '1em',
                border: '1px solid transparent'
            },
            '> i-tree-node > .i-tree-node_content': {
                paddingLeft: 0
            },
            'i-tree-node': {
                display: 'block',
                position: 'relative'
            },
            '> i-tree-node:not(.has-children) .i-tree-node_icon:not(.custom-icon)': {
                display: 'none'
            },
            'i-tree-node.is-checked > .i-tree-node_children': {
                display: 'block'
            },
            'i-tree-node.is-checked > .i-tree-node_content > .i-tree-node_icon': {
                transform: 'rotate(90deg)'
            },
            'input[type="checkbox"]': {
                position: 'absolute',
                clip: 'rect(0, 0, 0, 0)',
            },
            '.i-tree-node_children': {
                display: 'none',
            },
            '.i-tree-node_label': {
                position: 'relative',
                display: 'inline-block',
                color: Theme.text.primary,
                cursor: 'pointer',
                fontSize: 'inherit',
            },
            '.i-tree-node_icon': {
                display: 'inline-block',
                transition: 'all ease 0.4s',
                $nest: {
                    'svg': {
                        width: 14,
                        height: 14
                    },
                    'i-image': {
                        display: 'flex'
                    },
                    '&:not(.custom-icon)': {
                        display: 'none'
                    }
                }
            },
            'input ~ .i-tree-node_icon:not(.custom-icon), input ~ .is-right > .i-tree-node_icon:not(.custom-icon)': {
                display: 'inline-block'
            },
            'input ~ .i-tree-node_label': {
                maxWidth: 'calc(100% - 15px)'
            },
            '.i-tree-node_icon + .i-tree-node_label': {
                paddingLeft: '0.3em'
            },
            '&.i-tree-view': {
                padding: 0,
                position: 'relative',
                $nest: {
                    '.is-checked:before': {
                        borderLeft: `1px solid ${Theme.divider}`,
                        height: 'calc(100% - 1em)',
                        top: '1em'
                    },
                    '.i-tree-node_children > .is-checked:before': {
                        height: 'calc(100% - 25px)',
                        top: 25
                    },
                    'i-tree-node.active > .i-tree-node_content': {
                        backgroundColor: Theme.action.selectedBackground,
                        // border: `1px solid ${Theme.colors.info.dark}`,
                        color: Theme.action.selected,
                        $nest: {
                            '> .i-tree-node_label': {
                                color: Theme.action.selected
                            }
                        }
                    },
                    '.i-tree-node_content:hover': {
                        backgroundColor: Theme.action.hoverBackground,
                        color: Theme.action.hover,
                        $nest: {
                            '> .is-right .button-group *': {
                                display: 'inline-flex'
                            },
                            '.hide-on-show': {
                                display: 'none !important'
                            }
                        }
                    },
                    'input[type="checkbox"]': {
                        margin: 0
                    },
                    '.i-tree-node_label': {
                        padding: '.2rem .3rem .2em 0',
                        maxWidth: 'calc(100% - 30px)',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis'
                    }
                }
            },
            '&.shown-line': {
                $nest: {
                    '> i-tree-node.has-children': {
                        marginLeft: '1em'
                    },
                    'input ~ .i-tree-node_label:before': {
                        background: Theme.colors.primary.main,
                        color: Theme.colors.primary.contrastText,
                        position: 'relative',
                        zIndex: '1',
                        float: 'left',
                        margin: '0 1em 0 -2em',
                        width: '1em',
                        height: '1em',
                        borderRadius: '0.2em',
                        content: "'+'",
                        textAlign: 'center',
                        lineHeight: '.9em',
                    },
                    'input:checked ~ .i-tree-node_label:before': {
                        content: "''",
                    },
                    'i-tree-node': {
                        padding: '0 0 1em 1em',
                        $nest: {
                            '&.active': {
                                $nest: {
                                    '> .i-tree-node_label': {
                                        color: '#55f',
                                    }
                                }
                            },
                        },
                    },
                    '.i-tree-node_children i-tree-node': {
                        padding: '.5em 0 0 .9em'
                    },
                    'i-tree-node:last-of-type:before': {
                        height: '1em',
                        bottom: 'auto',
                    },
                    ' i-tree-node:before': {
                        position: 'absolute',
                        top: '0',
                        bottom: '0',
                        left: '-.1em',
                        display: 'block',
                        width: '1px',
                        borderLeft: `1px solid ${Theme.divider}`,
                        content: "''",
                    },
                    '.i-tree-node_icon:not(.custom-icon)': {
                        display: 'none'
                    },
                    '.i-tree-node_content': {
                        paddingLeft: `0 !important`
                    },
                    'i-tree-node .i-tree-node_label:after': {
                        position: 'absolute',
                        top: '.25em',
                        left: '-1em',
                        display: 'block',
                        height: '0.5em',
                        width: '1em',
                        borderBottom: `1px solid ${Theme.divider}`,
                        borderLeft: `1px solid ${Theme.divider}`,
                        borderRadius: ' 0 0 0 0',
                        content: "''",
                    },
                    'i-tree-node input:checked ~ .i-tree-node_label:after': {
                        borderRadius: '0 .1em 0 0',
                        borderTop: `1px solid ${Theme.divider}`,
                        borderRight: `0.5px solid ${Theme.divider}`,
                        borderBottom: '0',
                        borderLeft: '0',
                        bottom: '0',
                        height: 'auto',
                        top: '.5em'
                    },
                    '.i-tree-node_label': {
                        overflow: 'unset'
                    }
                }
            },
            '.text-input': {
                border: 'none',
                outline: '0',
                height: '100%',
                width: '100%',
                $nest: {
                    '&:focus': {
                        borderBottom: `2px solid ${Theme.colors.primary.main}`
                    }
                }
            },
            '.button-group': {
                display: 'inline-flex',
                alignItems: 'center',
                position: 'relative',
                zIndex: 999,
                transition: '.3s all ease',
                gap: 5,
                cursor: 'pointer',
                marginLeft: 5,
                $nest: {
                    '*': {
                        display: 'none'
                    }
                }
            },
            '.is-right': {
                marginLeft: 'auto',
                width: 'auto'
            }
        }
    });
});
define("@ijstech/tree-view/treeView.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/button", "@ijstech/style", "@ijstech/types", "@ijstech/application", "@ijstech/tree-view/style/treeView.css.ts"], function (require, exports, base_1, icon_1, button_1, Styles, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeNode = exports.TreeView = void 0;
    const Theme = Styles.Theme.ThemeVars;
    const beforeExpandEvent = new Event('beforeExpand');
    const defaultIcon = {
        name: 'caret-right',
        fill: Theme.text.secondary,
        width: '0.75rem',
        height: '0.75rem'
    };
    let TreeView = class TreeView extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
                editable: false
            });
            this._items = [];
            this._alwaysExpanded = false;
            this._deleteNodeOnEmptyCaption = false;
        }
        get activeItem() {
            return this._activeItem;
        }
        set activeItem(value) {
            this._activeItem = value;
            const treeNodes = Array.from(this.querySelectorAll('i-tree-node'));
            treeNodes.forEach((treeNode) => (treeNode.active = false));
            if (value)
                value.active = true;
        }
        get alwaysExpanded() {
            return this._alwaysExpanded;
        }
        set alwaysExpanded(value) {
            this._alwaysExpanded = value;
        }
        get data() {
            return this._items.map(node => node.data);
        }
        set data(value) {
            // this._data = value
            this.clear();
            this.renderTree(value);
        }
        get items() {
            return this._items || [];
        }
        get editable() {
            return this._editable;
        }
        set editable(value) {
            this._editable = value;
        }
        get actionButtons() {
            return this._actionButtons ?? [];
        }
        set actionButtons(value) {
            this._actionButtons = value ?? [];
            const groups = Array.from(this.querySelectorAll('.button-group'));
            if (groups && groups.length) {
                groups.forEach(group => {
                    this.renderActions(group);
                });
            }
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            for (let node of this._items) {
                node.updateLocale(i18n);
            }
        }
        add(parentNode, caption) {
            const childData = { caption, children: [] };
            const childNode = new TreeNode(this, { ...childData });
            this.initNode(childNode);
            childNode.editable = this.editable;
            childNode.alwaysExpanded = this.alwaysExpanded;
            if (typeof this.onRenderNode === 'function')
                this.onRenderNode(this, childNode);
            // const name = caption || ''
            if (parentNode) {
                parentNode.appendNode(childNode);
                const parentContent = parentNode.querySelector('.i-tree-node_content');
                const childContent = childNode.querySelector('.i-tree-node_content');
                if (parentContent && childContent) {
                    const parentLeft = parentContent.style.paddingLeft || 0;
                    childContent.style.paddingLeft = parentLeft ? `calc(${parentLeft} + 1em)` : "1em";
                }
                // const paths = parentNode.filePath?.paths || []
                // childNode.filePath = { paths: [...paths, { name }] }
            }
            else {
                this.appendChild(childNode);
                // childNode.filePath = {  paths: [{ name }] }
            }
            return childNode;
        }
        appendNode(childNode) {
            this.initNode(childNode);
            childNode.editable = this.editable;
            childNode.alwaysExpanded = this.alwaysExpanded;
            if (typeof this.onRenderNode === 'function')
                this.onRenderNode(this, childNode);
            this.appendChild(childNode);
            if (childNode.children?.length) {
                for (let child of childNode.children) {
                    if (child instanceof TreeNode) {
                        childNode.appendNode(child);
                    }
                }
            }
        }
        delete(node) {
            // Real-time data
            node.remove();
        }
        clear() {
            this.clearInnerHTML();
            this._items = [];
        }
        _setActiveItem(node, event) {
            const prevNode = this.activeItem;
            this.activeItem = node;
            if (event && typeof this.onActiveChange === 'function') {
                this.onActiveChange(this, prevNode, event);
            }
            ;
        }
        handleMouseEnter(node) {
            const fn = this.onMouseEnterNode;
            if (fn && typeof fn === 'function')
                fn(this, node);
        }
        handleMouseLeave(node) {
            const fn = this.onMouseLeaveNode;
            if (fn && typeof fn === 'function')
                fn(this, node);
        }
        handleLazyLoad(node) {
            const fn = this.onLazyLoad;
            if (fn && typeof fn === 'function')
                fn(this, node);
        }
        initNode(node) {
            this.registerEvents(node);
            const groupElm = node.querySelector('.button-group');
            if (this.actionButtons)
                this.renderActions(groupElm);
        }
        registerEvents(node) {
            node.addEventListener('mouseenter', () => this.handleMouseEnter(node));
            node.addEventListener('mouseleave', () => this.handleMouseLeave(node));
            node.addEventListener('beforeExpand', (event) => this.handleLazyLoad(node));
            if (typeof this.onRenderNode === 'function')
                this.onRenderNode(this, node);
        }
        renderTreeNode(node, parent, paths = [], level) {
            const treeNode = new TreeNode(parent, node);
            treeNode.editable = this.editable;
            treeNode.alwaysExpanded = this.alwaysExpanded;
            this.initNode(treeNode);
            const treeContent = treeNode.querySelector('.i-tree-node_content');
            treeContent && (treeContent.style.paddingLeft = `${level}em`);
            const name = node.caption || '';
            if (node.children) {
                paths.push({ name });
                // treeNode.filePath = { paths: [...paths] }
                if (!node.isLazyLoad) {
                    for (const child of node.children) {
                        const childWrapper = treeNode.querySelector('.i-tree-node_children');
                        if (childWrapper) {
                            const childNode = this.renderTreeNode(child, parent, paths, level + 1);
                            childWrapper && childWrapper.appendChild(childNode);
                        }
                    }
                }
            }
            else {
                // treeNode.filePath = { paths: [...paths, { name }] }
            }
            return treeNode;
        }
        renderTree(value) {
            if (!value || !value.length)
                return;
            for (const node of value) {
                let treeNode = this.renderTreeNode(node, this, [], 0);
                this.appendChild(treeNode);
                const activedNodes = treeNode.querySelectorAll('.active');
                if (activedNodes.length) {
                    const activedNode = activedNodes[activedNodes.length - 1];
                    treeNode.expanded = true;
                    const treeNodes = Array.from(treeNode.querySelectorAll('i-tree-node.has-children'));
                    treeNodes.forEach(treeNode => {
                        if (treeNode.contains(activedNode))
                            treeNode.expanded = true;
                    });
                    this.activeItem = activedNode;
                }
                this._items.push(treeNode);
            }
        }
        renderActions(group) {
            if (!group)
                return;
            group.innerHTML = '';
            this.actionButtons.forEach((button) => {
                const buttonElm = new button_1.Button(undefined, button);
                if (this.onActionButtonClick && typeof this.onActionButtonClick === 'function')
                    buttonElm.onClick = (source, event) => {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        const node = buttonElm.closest('i-tree-node');
                        if (node && !this.activeItem?.isSameNode(node))
                            this.activeItem = node;
                        this.onActionButtonClick(this, buttonElm, event);
                    };
                group.appendChild(buttonElm);
            });
        }
        init() {
            if (!this.initialized) {
                let treeNodes = [];
                for (let i = 0; i < this.children.length; i++) {
                    const child = this.children[i];
                    if (child instanceof TreeNode) {
                        treeNodes.push(child);
                    }
                    else {
                        child.remove();
                    }
                }
                super.init();
                this.classList.add('i-tree-view');
                if (typeof this.options?.onRenderNode === 'function')
                    this.onRenderNode = this.options.onRenderNode;
                this.alwaysExpanded = this.getAttribute('alwaysExpanded', true, false);
                this.editable = this.getAttribute('editable', true, false);
                this.actionButtons = this.getAttribute('actionButtons', true);
                this.data = this.getAttribute('data', true);
                this._deleteNodeOnEmptyCaption = this.getAttribute('deleteNodeOnEmptyCaption', true);
                console.log('_deleteNodeOnEmptyCaption', this._deleteNodeOnEmptyCaption);
                const activeAttr = this.getAttribute('activeItem', true);
                activeAttr && (this.activeItem = activeAttr);
                if (treeNodes?.length) {
                    for (let node of treeNodes) {
                        this.appendNode(node);
                    }
                }
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    TreeView = __decorate([
        (0, base_1.customElements)("i-tree-view", {
            icon: 'stream',
            group: types_1.GroupType.BASIC,
            className: 'TreeView',
            props: {
                activeItem: { type: 'object' },
                data: { type: 'array' },
                editable: { type: 'boolean' },
                actionButtons: { type: 'array' },
                alwaysExpanded: { type: 'boolean' },
                deleteNodeOnEmptyCaption: { type: 'boolean' }
            },
            events: {
                onActiveChange: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'prevNode', type: 'TreeNode', isControl: true },
                    { name: 'event', type: 'Event' }
                ],
                onChange: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'node', type: 'TreeNode', isControl: true },
                    { name: 'oldValue', type: 'string' },
                    { name: 'newValue', type: 'string' }
                ],
                onRenderNode: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'node', type: 'TreeNode', isControl: true }
                ],
                onMouseEnterNode: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'node', type: 'TreeNode', isControl: true }
                ],
                onMouseLeaveNode: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'node', type: 'TreeNode', isControl: true }
                ],
                onLazyLoad: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'node', type: 'TreeNode', isControl: true }
                ],
                onActionButtonClick: [
                    { name: 'target', type: 'TreeView', isControl: true },
                    { name: 'actionButton', type: 'Button', isControl: true },
                    { name: 'event', type: 'Event' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    editable: {
                        type: 'boolean'
                    },
                    actionButtons: {
                        type: 'array'
                    },
                    alwaysExpanded: {
                        type: 'boolean'
                    },
                    deleteNodeOnEmptyCaption: {
                        type: 'boolean'
                    }
                }
            }
        })
    ], TreeView);
    exports.TreeView = TreeView;
    let TreeNode = class TreeNode extends base_1.Control {
        // public filePath: { paths: any[] }
        constructor(parent, options) {
            super(parent, options);
            this._editable = false;
            this._alwaysExpanded = false;
            options && (this.data = options);
            this.handleEdit = this.handleEdit.bind(this);
        }
        get data() {
            return this._data;
        }
        set data(value) {
            this._data = value;
        }
        get caption() {
            let value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.rootParent?.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            if (!this._captionElm)
                return;
            this._captionElm.textContent = this.caption;
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this._captionElm && this._caption?.startsWith('$'))
                this._captionElm.textContent = i18n.get(this._caption) || '';
        }
        get collapsible() {
            return this._collapsible;
        }
        set collapsible(value) {
            if (typeof value === 'boolean') {
                this._collapsible = value;
            }
            else {
                this._collapsible = true;
            }
        }
        get expanded() {
            return this._expanded;
        }
        set expanded(value) {
            if (typeof value === 'boolean') {
                this._expanded = value;
                if (this._expandElm)
                    this._expandElm.checked = value;
                if (this._expanded)
                    this.classList.add('is-checked');
                else
                    this.classList.remove('is-checked');
            }
            else {
                this._expanded = false;
                if (this._expandElm)
                    this._expandElm.checked = false;
                this.classList.remove('is-checked');
            }
        }
        get alwaysExpanded() {
            return this._alwaysExpanded;
        }
        set alwaysExpanded(value) {
            this._alwaysExpanded = value;
        }
        get active() {
            return this._active;
        }
        set active(value) {
            if (typeof value === 'boolean') {
                this._active = value;
                this.active
                    ? this.classList.add('active')
                    : this.classList.remove('active');
            }
            else {
                this._active = false;
                this.classList.remove('active');
            }
        }
        get isLazyLoad() {
            return this._isLazyLoad;
        }
        set isLazyLoad(value) {
            this._isLazyLoad = value;
        }
        get editable() {
            return this._editable;
        }
        set editable(value) {
            this._editable = value;
        }
        get rootParent() {
            return this.closest('i-tree-view');
        }
        get icon() {
            if (!this._iconElm) {
                this._iconElm = icon_1.Icon.create(defaultIcon);
            }
            ;
            return this._iconElm;
        }
        get rightIcon() {
            if (!this._iconRightElm)
                this._iconRightElm = icon_1.Icon.create(defaultIcon);
            return this._iconRightElm;
        }
        get height() {
            return (!isNaN(this._height) ? this._height : this.offsetHeight);
        }
        set height(value) {
            this._height = value;
            this._wrapperElm.style.height = typeof value === 'string' ? value : `${value}px`;
        }
        // Trigger when node caption is changed
        handleChange(target, oldValue, newValue) {
            // const paths = target.filePath?.paths;
            // if (paths) {
            //   paths[paths.length - 1] = { name: newValue }
            //   target.filePath = { paths }
            // }
            debugger;
            const fn = this.rootParent.onChange;
            if (fn && typeof fn === 'function')
                fn(this.rootParent, target, oldValue, newValue);
        }
        renderEditMode() {
            const captionInput = this.createElement('input');
            captionInput.value = this.caption;
            captionInput.classList.add('text-input');
            this._captionElm.innerHTML = '';
            this._captionElm.appendChild(captionInput);
            captionInput.focus();
            this.click();
            let isUpdating = false;
            let isValid = true;
            const updateCaption = () => {
                const newValue = captionInput.value;
                console.log('rootparent deleteNodeOnEmptyCaption', this.rootParent._deleteNodeOnEmptyCaption);
                console.log('empty string', captionInput.value.replace(/\s+/g, '') === '');
                if (this.rootParent._deleteNodeOnEmptyCaption && captionInput.value.replace(/\s+/g, '') === '') {
                    return this.remove();
                }
                if (newValue !== this.caption) {
                    const fn = this.rootParent.onBeforeChange;
                    if (fn && typeof fn === 'function')
                        isValid = fn(this.rootParent, this, this.caption, newValue);
                    if (isValid) {
                        this.handleChange(this, this.caption, newValue);
                        this.caption = newValue;
                    }
                }
                else {
                    this.caption = this._caption;
                }
            };
            captionInput.addEventListener('blur', (event) => {
                event.preventDefault();
                if (isUpdating)
                    return;
                if (!isValid) {
                    captionInput.value = this._caption;
                }
                updateCaption();
            });
            captionInput.addEventListener('keyup', (event) => {
                event.preventDefault();
                if (event.key === 'Enter' || event.keyCode === 13) {
                    isUpdating = true;
                    updateCaption();
                    isUpdating = false;
                }
            });
        }
        handleEdit(event) {
            event.stopImmediatePropagation();
            event.preventDefault();
            this.renderEditMode();
        }
        edit() {
            this.editable = true;
            this.renderEditMode();
        }
        appendNode(childNode) {
            if (!this._childNodeElm)
                this.initChildNodeElm();
            this._childNodeElm.appendChild(childNode);
            if (!this.data.children)
                this.data.children = [];
            this.data.children.push(childNode.data);
            return childNode;
        }
        initChildNodeElm() {
            this.classList.add('has-children');
            this._expandElm = this.createElement('input', this._wrapperElm);
            this._expandElm.type = 'checkbox';
            if (this.expanded)
                this._expandElm.checked = true;
            if (this._iconElm)
                this._wrapperElm.insertBefore(this._expandElm, this._iconElm);
            else
                this._wrapperElm.insertBefore(this._expandElm, this._captionElm);
            this._childNodeElm = this.createElement('div', this);
            this._childNodeElm.classList.add('i-tree-node_children');
        }
        ;
        _handleClick(event) {
            const target = event.target;
            if (this.collapsible && this._expandElm) {
                this._expandElm.checked = !this._expandElm.checked;
                if (this._expandElm.checked)
                    this.classList.add('is-checked');
                else if (!this.alwaysExpanded)
                    this.classList.remove('is-checked');
            }
            ;
            if (target.closest('i-icon') || target.nodeName === 'I-ICON') {
                return true;
            }
            const parent = this._parent || target.closest('i-tree-view');
            if (parent instanceof TreeView) {
                parent._setActiveItem(this, event);
                if (parent.onClick)
                    parent.onClick(parent, event);
            }
            if (this.isLazyLoad) {
                this.dispatchEvent(beforeExpandEvent);
            }
            return super._handleClick(event, true);
        }
        _handleDblClick(event) {
            const target = event.target;
            const parent = this._parent || target.closest('i-tree-view');
            if (this.editable) {
                this.handleEdit(event);
            }
            else if (parent instanceof TreeView) {
                if (parent.onDblClick)
                    parent.onDblClick(parent, event);
            }
            ;
            return super._handleClick(event, true);
        }
        _handleContextMenu(event) {
            const target = event.target;
            const parent = this._parent || target.closest('i-tree-view');
            if (parent instanceof TreeView)
                if (parent.onContextMenu)
                    parent.onContextMenu(parent, event);
            return super._handleClick(event, true);
        }
        init() {
            if (!this._captionElm) {
                this.classList.add('i-tree-node');
                this.data = this.options;
                let caption = this.getAttribute('caption', true, '');
                let icon = this.getAttribute('icon', true);
                let rightIcon = this.getAttribute('rightIcon', true);
                let collapsible = this.getAttribute('collapsible', true);
                let expanded = this.getAttribute('expanded', true);
                let active = this.getAttribute('active', true, false);
                let isLazyLoad = this.getAttribute('isLazyLoad', true, false);
                this.collapsible = collapsible;
                this.expanded = expanded;
                this.active = active;
                this.isLazyLoad = isLazyLoad;
                this._wrapperElm = this.createElement('div', this);
                this._wrapperElm.classList.add('i-tree-node_content');
                const iconData = { ...defaultIcon, ...(icon || {}) };
                iconData.height = iconData.height || '0.75rem';
                iconData.width = iconData.width || '0.75rem';
                iconData.name = iconData.name || "caret-right";
                this._iconElm = new icon_1.Icon(undefined, iconData);
                this._iconElm.classList.add('i-tree-node_icon');
                icon && this._iconElm.classList.add('custom-icon');
                this._wrapperElm.appendChild(this._iconElm);
                this._captionElm = this.createElement('label', this._wrapperElm);
                this._captionElm.classList.add('i-tree-node_label');
                this.caption = caption;
                const rightWrap = this.createElement('div', this._wrapperElm);
                rightWrap.classList.add('is-right');
                const actionGroup = this.createElement('div', rightWrap);
                actionGroup.classList.add('button-group');
                const rightIconData = { ...defaultIcon, ...(rightIcon || {}) };
                rightIconData.height = rightIconData.height || '0.75rem';
                rightIconData.width = rightIconData.width || '0.75rem';
                rightIconData.name = rightIcon?.name || '';
                this._iconRightElm = new icon_1.Icon(undefined, rightIconData);
                this._iconRightElm.classList.add('i-tree-node_icon', 'custom-icon');
                rightWrap.appendChild(this._iconRightElm);
                rightWrap.insertBefore(this._iconRightElm, actionGroup);
                if (this.data?.children?.length)
                    this.initChildNodeElm();
            }
            super.init();
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    TreeNode = __decorate([
        (0, base_1.customElements)('i-tree-node')
    ], TreeNode);
    exports.TreeNode = TreeNode;
});
define("@ijstech/tree-view", ["require", "exports", "@ijstech/tree-view/treeView.ts"], function (require, exports, treeView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TreeNode = exports.TreeView = void 0;
    Object.defineProperty(exports, "TreeView", { enumerable: true, get: function () { return treeView_1.TreeView; } });
    Object.defineProperty(exports, "TreeNode", { enumerable: true, get: function () { return treeView_1.TreeNode; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/popover/style/popover.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.popoverArrowStyle = exports.popoverMainContentStyle = exports.getAbsoluteWrapperStyle = exports.getNoBackdropStyle = exports.getOverlayStyle = void 0;
    let Theme = Styles.Theme.ThemeVars;
    const getOverlayStyle = () => {
        return Styles.style({
            backgroundColor: 'rgba(12, 18, 52, 0.7)',
            position: 'fixed',
            left: 0,
            top: 0,
            width: '100%',
            height: '100%',
            opacity: 0,
            visibility: 'hidden',
            zIndex: 1000,
            transition: 'visibility 0s linear .25s, opacity .25s',
            $nest: {
                '&.show': {
                    opacity: '1',
                    visibility: 'visible',
                    transition: 'visibility 0s linear, opacity .25s'
                }
            }
        });
    };
    exports.getOverlayStyle = getOverlayStyle;
    const getNoBackdropStyle = () => {
        return Styles.style({
            position: 'inherit',
            top: 0,
            left: 0,
            opacity: 0,
            visibility: 'hidden',
            transform: 'scale(0.8)',
            transition: 'visibility 0s linear .25s,opacity .25s 0s,transform .25s',
            zIndex: 1000,
            maxWidth: 'inherit',
            $nest: {
                '.popover': {
                    margin: '0'
                },
                '&.show': {
                    opacity: '1',
                    visibility: 'visible',
                    transform: 'scale(1)',
                    transition: 'visibility 0s linear 0s,opacity .25s 0s,transform .25s'
                }
            }
        });
    };
    exports.getNoBackdropStyle = getNoBackdropStyle;
    const getAbsoluteWrapperStyle = (left, top) => {
        return Styles.style({
            left: left,
            top: top,
            width: 'inherit',
            height: 'inherit'
        });
    };
    exports.getAbsoluteWrapperStyle = getAbsoluteWrapperStyle;
    exports.popoverMainContentStyle = Styles.style({
        fontFamily: 'Helvetica',
        fontSize: '14px',
        padding: '10px 10px 5px 10px',
        backgroundColor: Theme.background.modal,
        position: 'relative',
        borderRadius: '2px',
        width: 'inherit',
        maxWidth: '100%'
    });
    Styles.cssRule('i-popover', {
        position: 'absolute',
        left: '0',
        top: '0'
    });
    const arrowBackgroundColor = "var(--tooltips-arrow-background, var(--background-modal))";
    exports.popoverArrowStyle = Styles.style({
        position: 'relative',
        $nest: {
            '&.is-top::after': {
                content: "''",
                position: "absolute",
                top: "100%",
                left: "50%",
                zIndex: 888,
                marginLeft: "-5px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `${arrowBackgroundColor} transparent transparent transparent`,
            },
            '&.is-topLeft::after': {
                content: "''",
                position: "absolute",
                top: "100%",
                left: "0%",
                marginLeft: "12px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `${arrowBackgroundColor} transparent transparent transparent`,
            },
            '&.is-topRight::after': {
                content: "''",
                position: "absolute",
                top: "100%",
                right: "0%",
                marginRight: "12px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `${arrowBackgroundColor} transparent transparent transparent`,
            },
            '&.is-left::after': {
                content: "''",
                position: "absolute",
                top: "50%",
                left: "100%",
                marginTop: "-5px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent transparent transparent ${arrowBackgroundColor}`,
            },
            '&.is-right::after': {
                content: "''",
                position: "absolute",
                top: "50%",
                right: "100%",
                marginTop: "-5px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent ${arrowBackgroundColor} transparent transparent`,
            },
            '&.is-rightTop::after': {
                content: "''",
                position: "absolute",
                top: "0%",
                right: "100%",
                marginTop: "5px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent ${arrowBackgroundColor} transparent transparent`,
            },
            '&.is-bottom::after': {
                content: "''",
                position: "absolute",
                bottom: "100%",
                left: "50%",
                marginLeft: "-5px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
            },
            '&.is-bottomLeft::after': {
                content: "''",
                position: "absolute",
                bottom: "100%",
                left: "0%",
                marginLeft: "12px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
            },
            '&.is-bottomRight::after': {
                content: "''",
                position: "absolute",
                bottom: "100%",
                right: "0%",
                marginRight: "12px",
                borderWidth: "5px",
                borderStyle: "solid",
                borderColor: `transparent transparent ${arrowBackgroundColor} transparent`,
            }
        }
    });
});
define("@ijstech/popover/popover.ts", ["require", "exports", "@ijstech/base", "@ijstech/style", "@ijstech/popover/style/popover.css.ts", "@ijstech/types"], function (require, exports, base_1, Styles, popover_css_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Popover = void 0;
    const Theme = Styles.Theme.currentTheme;
    const showEvent = new Event('show');
    const DEFAULT_VALUES = {
        placement: 'center',
        closeOnScrollChildFixed: false,
        isArrowShown: false
    };
    let Popover = class Popover extends base_1.Container {
        constructor(parent, options) {
            super(parent, options, {
                placement: 'center'
            });
            this._visible = false;
            this.boundHandlePopoverMouseDown = this.handlePopoverMouseDown.bind(this);
            this.boundHandlePopoverMouseUp = this.handlePopoverMouseUp.bind(this);
        }
        get visible() {
            return this._visible;
        }
        set visible(value) {
            if (value) {
                this._visible = true;
                this.style.display = 'block';
                this.wrapperDiv.classList.add('show');
                this.dispatchEvent(showEvent);
                document.addEventListener('mousedown', this.boundHandlePopoverMouseDown);
                document.addEventListener('mouseup', this.boundHandlePopoverMouseUp);
            }
            else {
                this._visible = false;
                this.style.display = 'none';
                this.wrapperDiv.classList.remove('show');
                this.overlayDiv.classList.remove('show');
                this.onClose && this.onClose(this);
                document.removeEventListener('mousedown', this.boundHandlePopoverMouseDown);
                document.removeEventListener('mouseup', this.boundHandlePopoverMouseUp);
            }
        }
        get onOpen() {
            return this._onOpen;
        }
        set onOpen(callback) {
            this._onOpen = callback;
        }
        get placement() {
            return this._placement;
        }
        set placement(value) {
            if (this.popoverDiv) {
                this.popoverDiv.classList.remove(`is-${this._placement}`);
            }
            this._placement = value;
        }
        get item() {
            return this.popoverDiv.children[0];
        }
        set item(value) {
            if (value instanceof base_1.Control) {
                this.popoverDiv.innerHTML = '';
                value && this.popoverDiv.appendChild(value);
            }
        }
        get position() {
            return this._wrapperPositionAt;
        }
        set position(value) {
            this._wrapperPositionAt = value;
        }
        get isSmallScreen() {
            return screen.width <= 1024;
        }
        get parent() {
            return super.parent;
        }
        set parent(value) {
            if (super.parent) {
                super.parent.onmouseover = null;
                super.parent.onmouseleave = null;
            }
            super.parent = value;
            this.handleHoverEvent(value);
        }
        set linkTo(value) {
            if (super.linkTo) {
                super.linkTo.onmouseover = null;
                super.linkTo.onmouseleave = null;
            }
            this._linkTo = value;
            this.handleHoverEvent(value);
        }
        get linkTo() {
            return this._linkTo;
        }
        get isArrowShown() {
            return this._isArrowShown ?? false;
        }
        set isArrowShown(value) {
            this._isArrowShown = value ?? false;
            if (value) {
                this.popoverDiv.classList.add(popover_css_1.popoverArrowStyle);
            }
            else {
                this.popoverDiv.classList.remove(popover_css_1.popoverArrowStyle);
            }
        }
        handleHoverEvent(target) {
            if (target && this.trigger === 'hover') {
                if (this._designMode)
                    return;
                target.onmouseover = (event) => {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    this.visible = true;
                };
                target.onmouseleave = (event) => {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    this.visible = false;
                };
            }
        }
        _handleClick(event) {
            return true;
        }
        positionPopoverRelativeToParent(placement) {
            let parent = this._parent || this.linkTo || this.parentElement || document.body;
            let coords = this.calculatePopoverWrapperCoordinates(parent, placement);
            const wrapperPositionStyle = (0, popover_css_1.getAbsoluteWrapperStyle)(coords.left + "px", coords.top + "px");
            this.setTargetStyle(this.wrapperDiv, 'wrapperPosition', wrapperPositionStyle);
        }
        calculatePopoverWrapperCoordinates(parent, placement) {
            const parentCoords = parent.getBoundingClientRect();
            let left = 0;
            let top = 0;
            let max;
            const isOutside = parent.style.position === 'absolute' && !this.parent?.contains(this);
            switch (placement) {
                case "center":
                    left = (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
                    top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
                    break;
                case "top":
                case "topLeft":
                case "topRight":
                    if (parentCoords.top - this.popoverDiv.offsetHeight >= 0) {
                        top = -this.popoverDiv.offsetHeight;
                    }
                    else {
                        if (window.innerHeight < this.popoverDiv.offsetHeight + parentCoords.bottom) {
                            max = window.innerHeight - this.popoverDiv.offsetHeight - parentCoords.y;
                            top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
                            top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
                        }
                        else {
                            top = parentCoords.height;
                        }
                    }
                    break;
                case "bottom":
                case "bottomLeft":
                case "bottomRight":
                    if (window.innerHeight < this.popoverDiv.offsetHeight + parentCoords.bottom) {
                        if (parentCoords.y - this.popoverDiv.offsetHeight < 0) {
                            max = window.innerHeight - this.popoverDiv.offsetHeight - parentCoords.y;
                            top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
                            top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
                        }
                        else {
                            top = -this.popoverDiv.offsetHeight;
                        }
                    }
                    else {
                        top = isOutside ? parentCoords.top - this.popoverDiv.offsetHeight : parentCoords.height;
                    }
                    break;
                case "rightTop":
                    top = isOutside ? parentCoords.top - this.popoverDiv.offsetHeight : 0;
                    left = isOutside ? parentCoords.left + parentCoords.width : parentCoords.width;
                    if (left + this.popoverDiv.offsetWidth > document.documentElement.clientWidth) {
                        left = document.documentElement.clientWidth - this.popoverDiv.offsetWidth;
                    }
                    if (top + this.popoverDiv.offsetHeight > document.documentElement.clientHeight) {
                        top = document.documentElement.clientHeight - this.popoverDiv.offsetHeight;
                    }
                    break;
                case "left":
                    max = window.innerHeight - this.popoverDiv.offsetHeight - parentCoords.y;
                    if (isOutside) {
                        top = parentCoords.top + parentCoords.height / 2 - this.popoverDiv.offsetHeight / 2;
                        left = Math.max(parentCoords.left - this.popoverDiv.offsetWidth, 0);
                    }
                    else {
                        top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
                        top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
                        left = -this.wrapperDiv.offsetWidth - 8;
                    }
                    break;
            }
            if (placement === 'topRight' || placement === 'bottomRight') {
                if (parentCoords.right - this.wrapperDiv.offsetWidth >= 0) {
                    left = parentCoords.width - this.wrapperDiv.offsetWidth;
                }
                else {
                    left = -parentCoords.left;
                }
            }
            else if (['top', 'topLeft', 'bottom', 'bottomLeft'].includes(placement)) {
                if (window.innerWidth >= parentCoords.left + this.wrapperDiv.offsetWidth) {
                    left = 0;
                }
                else {
                    if (parentCoords.right - this.wrapperDiv.offsetWidth >= 0) {
                        left = Math.min(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
                    }
                    else {
                        left = Math.max(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
                    }
                }
            }
            return { top, left };
        }
        _handleOnShow(event) {
            if (this.placement && this.enabled) {
                this.positionPopoverRelativeToParent(this.placement);
                this.popoverDiv.classList.add(`is-${this.placement}`);
            }
            if (this.enabled && this._onOpen) {
                event.preventDefault();
                this._onOpen(this);
            }
        }
        handlePopoverMouseDown(event) {
            this.insideClick = true;
            this.setInsideClick(event);
        }
        handlePopoverMouseUp(event) {
            if (!this.insideClick)
                this.visible = false;
        }
        setInsideClick(event) {
            const target = event.target;
            this.insideClick = this.popoverDiv.contains(target);
        }
        setPropertyValue(name, value) {
            if (!isNaN(Number(value)))
                this.popoverDiv.style[name] = value + 'px';
            else
                this.popoverDiv.style[name] = value;
            this.style[name] = '';
        }
        refresh() {
            super.refresh(true);
            if (this.visible && this.placement) {
                this.positionPopoverRelativeToParent(this.placement);
            }
        }
        get background() {
            return this._background;
        }
        set background(value) {
            if (!this._background) {
                this._background = new base_1.Background(this.popoverDiv, value);
            }
            else {
                this._background.setBackgroundStyle(value);
            }
            this.style.setProperty("--tooltips-arrow-background", value.color || Theme.background.modal);
        }
        get width() {
            return (!isNaN(this._width) ? this._width : this.offsetWidth);
        }
        set width(value) {
            this._width = value;
            this.setPropertyValue('width', value);
        }
        get height() {
            return this._height;
        }
        set height(value) {
            this._height = value;
            this.setPropertyValue('height', value);
        }
        get border() {
            return this._border;
        }
        set border(value) {
            this._border = new base_1.Border(this.wrapperDiv, value);
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (!this._padding)
                this._padding = new base_1.SpaceValue(this.popoverDiv, value, 'padding');
            else
                this._padding.update(value);
        }
        get trigger() {
            return this._trigger;
        }
        set trigger(value) {
            this._trigger = value;
        }
        removeTargetStyle(target, propertyName) {
            let style = this.propertyClassMap[propertyName];
            if (style)
                target.classList.remove(style);
        }
        setTargetStyle(target, propertyName, value) {
            this.removeTargetStyle(target, propertyName);
            if (value) {
                this.propertyClassMap[propertyName] = value;
                target.classList.add(value);
            }
        }
        init() {
            if (!this.wrapperDiv) {
                if (this.options?.onClose)
                    this.onClose = this.options.onClose;
                this.placement = this.getAttribute('placement', true);
                this.trigger = this.getAttribute('trigger', true);
                this.wrapperDiv = this.createElement('div', this);
                this.popoverDiv = this.createElement('div', this.wrapperDiv);
                this.bodyDiv = this.createElement('div', this.popoverDiv);
                while (this.childNodes.length > 1) {
                    this.bodyDiv.appendChild(this.childNodes[0]);
                }
                this.overlayDiv = this.createElement('div', this);
                this.prepend(this.overlayDiv);
                const overlayStyle = (0, popover_css_1.getOverlayStyle)();
                this.overlayDiv.classList.add(overlayStyle);
                this.popoverDiv.classList.add(popover_css_1.popoverMainContentStyle);
                this.popoverDiv.classList.add('popover');
                this.addEventListener('show', this._handleOnShow.bind(this));
                window.addEventListener('keydown', event => {
                    if (!this.visible)
                        return;
                    if (event.key === 'Escape') {
                        this.visible = false;
                    }
                });
                const itemAttr = this.getAttribute('item', true);
                if (itemAttr)
                    this.item = itemAttr;
                super.init();
                const linkTo = this.getAttribute('linkTo', true);
                if (linkTo)
                    this.linkTo = linkTo;
                const maxWidth = this.getAttribute('maxWidth', true);
                if (maxWidth !== undefined)
                    this.setPropertyValue('maxWidth', this.maxWidth);
                const minHeight = this.getAttribute('minHeight', true);
                if (minHeight !== undefined)
                    this.setPropertyValue('minHeight', this.minHeight);
                const minWidth = this.getAttribute('minWidth', true);
                if (minWidth !== undefined)
                    this.setPropertyValue('minWidth', this.minWidth);
                const height = this.getAttribute('height', true);
                if (height !== undefined)
                    this.setPropertyValue('height', this.height);
                const maxHeight = this.getAttribute('maxHeight', true);
                if (maxHeight !== undefined)
                    this.setPropertyValue('maxHeight', this.maxHeight);
                let border = this.getAttribute('border', true);
                if (border) {
                    this._border = new base_1.Border(this.wrapperDiv, border);
                    this.style.border = 'none';
                }
                let padding = this.getAttribute('padding', true);
                if (padding) {
                    this._padding = new base_1.SpaceValue(this.popoverDiv, padding, 'padding');
                }
                const noBackdropStyle = (0, popover_css_1.getNoBackdropStyle)();
                this.setTargetStyle(this.wrapperDiv, 'showBackdrop', noBackdropStyle);
                this.isArrowShown = this.getAttribute('isArrowShown', true, DEFAULT_VALUES.isArrowShown);
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Popover = __decorate([
        (0, base_1.customElements)('i-popover', {
            icon: 'window-restore',
            group: types_1.GroupType.BASIC,
            className: 'Popover',
            props: {
                placement: {
                    type: 'string',
                    default: DEFAULT_VALUES.placement
                },
                closeOnScrollChildFixed: {
                    type: 'boolean',
                    default: DEFAULT_VALUES.closeOnScrollChildFixed
                }
            },
            events: {
                onOpen: [
                    { name: 'target', type: 'Control', isControl: true }
                ],
                onClose: [
                    { name: 'target', type: 'Control', isControl: true }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    placement: {
                        type: 'string',
                        enum: ['center', 'bottom', 'bottomLeft', 'bottomRight', 'top', 'topLeft', 'topRight', 'rightTop', 'left', 'right'],
                        default: DEFAULT_VALUES.placement,
                    },
                    closeOnScrollChildFixed: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.closeOnScrollChildFixed
                    }
                }
            }
        })
    ], Popover);
    exports.Popover = Popover;
});
define("@ijstech/popover", ["require", "exports", "@ijstech/popover/popover.ts"], function (require, exports, popover_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Popover = void 0;
    Object.defineProperty(exports, "Popover", { enumerable: true, get: function () { return popover_1.Popover; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/iframe/style/iframe.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Styles.cssRule("i-iframe", {
        position: 'relative',
        display: 'block',
        $nest: {
            '.overlay': {
                position: 'absolute',
                top: '0px',
                left: '0px',
                width: '100%',
                height: 'calc(100% - 3rem)',
                zIndex: 9999,
                display: 'none',
            },
            '@media screen and (max-width: 767px)': {
                $nest: {
                    '.overlay': {
                        display: 'block'
                    }
                }
            }
        }
    });
});
define("@ijstech/iframe/iframe.ts", ["require", "exports", "@ijstech/base", "@ijstech/types", "@ijstech/iframe/style/iframe.css.ts"], function (require, exports, base_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Iframe = void 0;
    let Iframe = class Iframe extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {
            // width: 800,
            // height: 600,
            });
            window.addEventListener('mousedown', () => {
                if (this.iframeElm)
                    this.iframeElm.style.pointerEvents = 'none';
            });
            window.addEventListener('mouseup', () => {
                if (this.iframeElm)
                    this.iframeElm.style.pointerEvents = 'auto';
            });
        }
        ;
        reload() {
            let iframe = this.iframeElm;
            return new Promise((resolve) => {
                if (iframe) {
                    iframe.src = this.url;
                    iframe.onload = function () {
                        resolve();
                        iframe && (iframe.onload = null);
                    };
                }
            });
        }
        ;
        clear() {
            if (this.iframeElm) {
                this.unload();
                this.iframeElm.onload = null;
                this.iframeElm.onerror = null;
                this.iframeElm.parentNode?.removeChild(this.iframeElm);
                this.iframeElm.remove();
                this.iframeElm = undefined;
            }
        }
        unload() {
            if (this.iframeElm) {
                this.iframeElm.src = '';
                if (this.iframeElm && this.iframeElm.contentWindow) {
                    // this.iframeElm.contentWindow.document.write('');
                    this.iframeElm.contentWindow.close();
                }
            }
        }
        postMessage(msg) {
            if (this.iframeElm && this.iframeElm.contentWindow) {
                this.iframeElm.contentWindow.postMessage(msg, '*');
            }
            ;
        }
        ;
        get url() {
            return this._url;
        }
        ;
        set url(value) {
            this._url = value;
            if (!this.iframeElm)
                this.iframeElm = this.createElement('iframe', this);
            if (this.allowFullscreen)
                this.iframeElm.allowFullscreen = true;
            if (value !== undefined) {
                this.iframeElm.src = value || '';
                this.iframeElm.width = '100%';
                this.iframeElm.height = '100%';
                this.iframeElm.setAttribute('frameBorder', '0');
            }
        }
        set designMode(value) {
            this._designMode = value;
            if (this.overlayElm) {
                this.overlayElm.style.height = value ? '100%' : '0px';
                this.overlayElm.style.display = value ? 'block' : 'none';
            }
        }
        init() {
            super.init();
            this.overlayElm = this.createElement("div", this);
            this.overlayElm.classList.add('overlay');
            this.overlayElm.style.height = this._designMode ? '100%' : '0px';
            this.overlayElm.style.display = this._designMode ? 'block' : 'none';
            this.allowFullscreen = this.getAttribute('allowFullscreen', true);
            const url = this.getAttribute('url', true);
            if (url !== undefined)
                this.url = url;
        }
        ;
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        ;
    };
    Iframe = __decorate([
        (0, base_1.customElements)('i-iframe', {
            icon: 'border-all',
            group: types_1.GroupType.BASIC,
            className: 'Iframe',
            props: {
                url: { type: 'string', default: '' },
                allowFullscreen: { type: 'boolean', default: false }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    url: {
                        type: 'string'
                    },
                    allowFullscreen: {
                        type: 'boolean',
                        default: false
                    }
                }
            }
        })
    ], Iframe);
    exports.Iframe = Iframe;
});
define("@ijstech/iframe", ["require", "exports", "@ijstech/iframe/iframe.ts"], function (require, exports, iframe_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Iframe = void 0;
    Object.defineProperty(exports, "Iframe", { enumerable: true, get: function () { return iframe_1.Iframe; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/pagination/style/pagination.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-pagination', {
        display: 'block',
        width: '100%',
        maxWidth: '100%',
        verticalAlign: 'baseline',
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        lineHeight: '25px',
        color: Theme.text.primary,
        '$nest': {
            ".pagination": {
                display: 'inline-flex',
                flexWrap: 'wrap',
                justifyContent: 'center',
            },
            ".pagination a": {
                color: Theme.text.primary,
                float: 'left',
                padding: '4px 8px',
                textAlign: 'center',
                textDecoration: 'none',
                transition: 'background-color .3s',
                border: '1px solid #ddd',
                minWidth: 36,
            },
            ".pagination a.active": {
                backgroundColor: '#4CAF50',
                color: 'white',
                border: '1px solid #4CAF50',
                cursor: 'default',
            },
            '.pagination a.disabled': {
                color: Theme.text.disabled,
                pointerEvents: 'none'
            },
        }
    });
});
define("@ijstech/pagination/pagination.ts", ["require", "exports", "@ijstech/base", "@ijstech/types", "@ijstech/pagination/style/pagination.css.ts"], function (require, exports, base_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pagination = void 0;
    const pagerCount = 7;
    const pagerCountMobile = 5;
    const defaultCurrentPage = 1;
    const pageSize = 10;
    const defaultTotalPage = 0;
    let Pagination = class Pagination extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, { pageSize });
            this._showPrevMore = false;
            this._showNextMore = false;
            this.pageItems = [];
            this.pagerCount = pagerCount;
            this.isClicked = false;
        }
        get totalPages() {
            return this._totalPages;
        }
        set totalPages(value) {
            if (this._totalPages === value)
                return;
            this._totalPages = value;
            this.onDisablePrevNext();
            this.renderPageItem(value);
        }
        get currentPage() {
            return this._curPage;
        }
        set currentPage(value) {
            const oldData = this._curPage;
            this._curPage = value || defaultCurrentPage;
            const index = value - 1;
            this.pageItems[index] && this.onActiveItem(this.pageItems[index]);
            if (typeof this.onPageChanged === 'function' && (oldData !== this._curPage)) {
                this.onPageChanged(this, oldData, !!this.isClicked);
                this.isClicked = false;
            }
        }
        get pageSize() {
            return this._pageSize || pageSize;
        }
        set pageSize(value) {
            this._pageSize = value;
        }
        onActiveItem(item) {
            if (this.activeItem) {
                this.activeItem.classList.remove('active');
            }
            if (item) {
                item.classList.add('active');
                this.activeItem = item;
            }
        }
        onDisablePrevNext() {
            if (this._prevElm)
                this.currentPage <= 1 ?
                    this._prevElm.classList.add('disabled') :
                    this._prevElm.classList.remove('disabled');
            if (this._nextElm)
                this.currentPage >= this.totalPages ?
                    this._nextElm.classList.add('disabled') :
                    this._nextElm.classList.remove('disabled');
        }
        _handleOnClickIndex(value, event) {
            if (!this.enabled)
                return;
            this.isClicked = true;
            this.currentPage = value;
            this.onActiveItem(event.target);
            this.onDisablePrevNext();
        }
        _handleOnClickMore(value, event) {
            let _curPage = this.currentPage + (value * (this.pagerCount - 2));
            if (_curPage > this.totalPages) {
                _curPage = this.totalPages;
            }
            else if (_curPage <= 0) {
                _curPage = 1;
            }
            this.isClicked = true;
            this.currentPage = _curPage;
            this.onDisablePrevNext();
            this.renderPageItem(this.totalPages);
        }
        _handleOnNext(event) {
            if (!this.enabled || this.currentPage >= this.totalPages)
                return;
            const nextPage = Number(this._curPage) <= 0 ? 1 : Number(this._curPage) + 1;
            this.isClicked = true;
            this.currentPage = nextPage;
            this.renderPageItem(this.totalPages);
            this.onDisablePrevNext();
        }
        _handleOnPrev(event) {
            if (!this.enabled || this.currentPage <= 1)
                return;
            const prevPage = Number(this._curPage) - 1;
            this.isClicked = true;
            this.currentPage = prevPage;
            this.renderPageItem(this.totalPages);
            this.onDisablePrevNext();
        }
        onMouseenter(direction, event) {
            if (!this.enabled)
                return;
            const target = event.target;
            target.innerHTML = direction === -1 ? '&laquo;' : '&raquo;';
        }
        renderEllipsis(step) {
            let item = this.createElement('a', this._paginationDiv);
            item.id = step === -1 ? 'prevMoreElm' : 'nextMoreElm';
            item.setAttribute('href', '#');
            item.innerHTML = "...";
            item.classList.add('paginate_button');
            item.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this._designMode)
                    return;
                this._handleOnClickMore(step, e);
            });
            item.addEventListener("mouseenter", (e) => {
                e.preventDefault();
                if (this._designMode)
                    return;
                this.onMouseenter(step, e);
            });
            item.addEventListener("mouseout", (e) => {
                e.preventDefault();
                if (this._designMode)
                    return;
                item.innerHTML = '...';
            });
        }
        renderPage(index) {
            let item = this.createElement('a', this._paginationDiv);
            this.pageItems.push(item);
            item.setAttribute('href', '#');
            item.innerHTML = `${index}`;
            item.classList.add('paginate_button');
            item.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this._designMode)
                    return;
                this._handleOnClickIndex(index, e);
            });
            if (index === this.currentPage)
                this.onActiveItem(item);
        }
        updatePagers() {
            const halfPagerCount = (this.pagerCount - 1) / 2;
            const currentPage = Number(this.currentPage);
            const pageCount = Number(this.totalPages);
            let showPrevMore = false;
            let showNextMore = false;
            if (pageCount > this.pagerCount) {
                if (currentPage > this.pagerCount - halfPagerCount) {
                    showPrevMore = true;
                }
                if (currentPage < pageCount - halfPagerCount) {
                    showNextMore = true;
                }
            }
            const array = [];
            if (showPrevMore && !showNextMore) {
                const startPage = pageCount - (this.pagerCount - 2);
                for (let i = startPage; i < pageCount; i++) {
                    array.push(i);
                }
            }
            else if (!showPrevMore && showNextMore) {
                for (let i = 2; i < this.pagerCount; i++) {
                    array.push(i);
                }
            }
            else if (showPrevMore && showNextMore) {
                const offset = Math.floor(this.pagerCount / 2) - 1;
                for (let i = currentPage - offset; i <= currentPage + offset; i++) {
                    array.push(i);
                }
            }
            else {
                for (let i = 2; i < pageCount; i++) {
                    array.push(i);
                }
            }
            this.pagers = array;
            this._showPrevMore = showPrevMore;
            this._showNextMore = showNextMore;
        }
        renderPageItem(size) {
            if (!this._paginationDiv)
                return;
            this.visible = size > 0;
            this._paginationDiv.innerHTML = '';
            if (this._prevElm) {
                this._paginationDiv.appendChild(this._prevElm);
            }
            this.pageItems = [];
            if (size > 0) {
                if (size > this.pagerCount) {
                    this.updatePagers();
                    this.renderPage(1);
                    this._showPrevMore && this.renderEllipsis(-1);
                    for (let i = 0; i < this.pagers.length; i++) {
                        this.renderPage(this.pagers[i]);
                    }
                    this._showNextMore && this.renderEllipsis(1);
                    this.renderPage(size);
                }
                else {
                    for (let i = 1; i <= size; i++) {
                        this.renderPage(i);
                    }
                }
            }
            else if (size < 0) {
                const _s = this.pageItems.length + size;
                for (let i = this.pageItems.length - 1; i >= _s; i--) {
                    this._paginationDiv.removeChild(this.pageItems[i]);
                    this.pageItems.pop();
                }
            }
            if (this._nextElm) {
                this._paginationDiv.append(this._nextElm);
            }
        }
        init() {
            this.pagerCount = window.innerWidth > 767 ? pagerCount : pagerCountMobile;
            if (!this._paginationDiv) {
                this.pageItems = [];
                this._paginationDiv = this.createElement('div', this);
                this._paginationDiv.classList.add('pagination', 'pagination-main');
                this._prevElm = this.createElement('a', this._paginationDiv);
                this._prevElm.setAttribute('href', '#');
                this._prevElm.innerHTML = '&laquo;';
                this._prevElm.classList.add('paginate_button', 'previous');
                this._prevElm.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this._designMode)
                        return;
                    this._handleOnPrev(e);
                });
                this.currentPage = +this.getAttribute("currentPage", true, defaultCurrentPage);
                this.totalPages = +this.getAttribute("totalPages", true, defaultTotalPage);
                this.pageSize = +this.getAttribute("pageSize", true, pageSize);
                this._nextElm = this.createElement('a', this._paginationDiv);
                this._nextElm.setAttribute('href', '#');
                this._nextElm.innerHTML = '&raquo;';
                this._nextElm.classList.add('paginate_button', 'next');
                this._nextElm.addEventListener("click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this._designMode)
                        return;
                    this._handleOnNext(e);
                });
                this.onDisablePrevNext();
            }
            super.init();
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Pagination = __decorate([
        (0, base_1.customElements)("i-pagination", {
            icon: 'ellipsis-h',
            group: types_1.GroupType.BASIC,
            className: 'Pagination',
            props: {
                totalPages: { type: 'number', default: defaultTotalPage },
                currentPage: { type: 'number', default: defaultCurrentPage },
                pageSize: { type: 'number', default: pageSize },
            },
            events: {
                onPageChanged: [
                    { name: 'target', type: 'Pagination', isControl: true },
                    { name: 'lastActivePage', type: 'number' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    totalPages: {
                        type: 'number',
                        default: defaultTotalPage
                    },
                    currentPage: {
                        type: 'number',
                        default: defaultCurrentPage
                    },
                    pageSize: {
                        type: 'number',
                        default: pageSize
                    }
                }
            }
        })
    ], Pagination);
    exports.Pagination = Pagination;
});
define("@ijstech/pagination", ["require", "exports", "@ijstech/pagination/pagination.ts"], function (require, exports, pagination_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pagination = void 0;
    Object.defineProperty(exports, "Pagination", { enumerable: true, get: function () { return pagination_1.Pagination; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/table/style/table.css.ts", ["require", "exports", "@ijstech/style", "@ijstech/base", "@ijstech/base"], function (require, exports, Styles, base_1, base_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTableMediaQueriesStyleClass = exports.getCustomStylesClass = exports.tableStyle = void 0;
    const Theme = Styles.Theme.ThemeVars;
    exports.tableStyle = Styles.style({
        fontFamily: Theme.typography.fontFamily,
        fontSize: Theme.typography.fontSize,
        color: Theme.text.primary,
        display: 'block',
        $nest: {
            '> .i-table-container': {
                overflowX: 'auto'
            },
            '.i-table-cell': {
                // padding: '1rem',
                overflowWrap: 'break-word',
                position: 'relative',
                // overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'normal'
            },
            '> .i-table-container > table': {
                width: '100%',
                textAlign: 'left',
                borderCollapse: 'separate',
                borderSpacing: 0
                // tableLayout: 'fixed'
            },
            '.i-table-header>tr>th': {
                fontWeight: 600,
                transition: 'background .3s ease',
                borderBottom: `1px solid ${Theme.divider}`
            },
            '.i-table-body>tr>td': {
                borderBottom: `1px solid ${Theme.divider}`,
                transition: 'background .3s ease'
            },
            'tr:hover td': {
                background: Theme.action.hoverBackground,
                color: Theme.action.hover
            },
            '&.i-table--bordered': {
                $nest: {
                    '> .i-table-container > table': {
                        borderTop: `1px solid ${Theme.divider}`,
                        borderLeft: `1px solid ${Theme.divider}`,
                        borderRadius: '2px'
                    },
                    '> .i-table-container > table .i-table-cell': {
                        borderRight: `1px solid ${Theme.divider} !important`,
                        borderBottom: `1px solid ${Theme.divider}`
                    }
                }
            },
            '.i-table-header i-table-column': {
                display: 'inline-flex',
                gap: 10,
                alignItems: 'center'
            },
            '.i-table-sort': {
                position: 'relative',
                display: 'inline-flex',
                flexDirection: 'column',
                alignItems: 'center',
                width: 20,
                $nest: {
                    '.sort-icon': {
                        display: 'block',
                        cursor: 'pointer'
                    },
                    '.sort-icon.sort-icon--active > svg': {
                        fill: Theme.colors.primary.main
                    },
                    '.sort-icon.sort-icon--desc': {
                        marginTop: -5
                    }
                }
            },
            '.i-table-pagi': {
                display: 'flex',
                width: '100%',
                $nest: {
                    '&.is--left': {
                        justifyContent: 'flex-start'
                    },
                    '&.is--right': {
                        justifyContent: 'flex-end'
                    },
                    '&.is--center': {
                        justifyContent: 'center'
                    }
                }
            },
            '.i-table-cell--expand': {
                cursor: 'pointer',
                $nest: {
                    'i-icon': {
                        display: 'inline-block'
                    },
                    'i-icon svg': {
                        fill: Theme.text.primary
                    }
                }
            },
            '.i-table-row--child > td': {
                borderRight: `1px solid ${Theme.divider}`
            },
            "@media (max-width: 767px)": {
                $nest: {
                    '.hidden-mobile': {
                        display: 'none !important'
                    },
                }
            },
            "@media (min-width: 768px)": {
                $nest: {
                    '.hidden-desktop': {
                        display: 'none !important'
                    },
                }
            },
        }
    });
    const getCustomStylesClass = (styles) => {
        let styleObj = {};
        const { padding, background, font, cursor, height } = styles || {};
        const { top = '1rem', right = '1rem', bottom = '1rem', left = '1rem' } = padding || {};
        styleObj.padding = `${(0, base_1.getSpacingValue)(top)} ${(0, base_1.getSpacingValue)(right)} ${(0, base_1.getSpacingValue)(bottom)} ${(0, base_1.getSpacingValue)(left)}`;
        if (font) {
            const { color = '', size = '', name = '', style = '', transform = 'none', bold, weight = '' } = font;
            styleObj.color = color;
            styleObj.fontSize = size;
            styleObj.fontFamily = name;
            styleObj.fontStyle = style;
            styleObj.textTransform = transform;
            styleObj.fontWeight = bold ? 'bold' : `${weight}`;
        }
        if (background)
            styleObj.background = (0, base_1.getBackground)(background)?.background || '';
        if (cursor)
            styleObj.cursor = cursor;
        if (height !== undefined && height !== null) {
            styleObj.height = (0, base_1.getSpacingValue)(height);
        }
        return Styles.style(styleObj);
    };
    exports.getCustomStylesClass = getCustomStylesClass;
    const getTableMediaQueriesStyleClass = (columns, mediaQueries) => {
        let styleObj = (0, base_1.getControlMediaQueriesStyle)(mediaQueries);
        for (let mediaQuery of mediaQueries) {
            let mediaQueryRule = (0, base_2.getMediaQueryRule)(mediaQuery);
            if (mediaQueryRule) {
                const ruleObj = styleObj['$nest'][mediaQueryRule];
                styleObj['$nest'][mediaQueryRule] = {
                    ...ruleObj,
                    $nest: {}
                };
                const { fieldNames, expandable } = mediaQuery.properties || {};
                if (fieldNames) {
                    for (let column of columns) {
                        const fieldName = column.fieldName || 'action';
                        if (!fieldNames.includes(column.fieldName)) {
                            styleObj['$nest'][mediaQueryRule]['$nest'][`[data-fieldname="${fieldName}"]`] = {
                                display: 'none'
                            };
                        }
                        else if (column.visible === false) {
                            styleObj['$nest'][mediaQueryRule]['$nest'][`[data-fieldname="${fieldName}"]`] = {
                                display: 'table-cell !important'
                            };
                            styleObj['$nest'][mediaQueryRule]['$nest'][`[data-fieldname="${fieldName}"]`] = {
                                display: 'table-cell !important',
                                $nest: {
                                    '> i-table-column': {
                                        display: 'table-cell !important'
                                    }
                                }
                            };
                        }
                    }
                }
                if (expandable) {
                    styleObj['$nest'][mediaQueryRule]['$nest']['.i-table-row--child'] = {
                        display: expandable.rowExpandable ? 'none' : 'none !important'
                    };
                }
            }
        }
        return Styles.style(styleObj);
    };
    exports.getTableMediaQueriesStyleClass = getTableMediaQueriesStyleClass;
});
define("@ijstech/table/tableCell.ts", ["require", "exports", "@ijstech/table/style/table.css.ts"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableCell = void 0;
    class TableCell {
        constructor(options) {
            this.rowSpan = options.rowSpan;
            this.columnSpan = options.columnSpan;
            this.value = options.value;
        }
        get rowSpan() {
            return this._rowSpan;
        }
        set rowSpan(value) {
            this._rowSpan = value;
        }
        get columnSpan() {
            return this._columnSpan;
        }
        set columnSpan(value) {
            this._columnSpan = value;
        }
        get value() {
            return this._value;
        }
        set value(data) {
            this._value = data;
        }
    }
    exports.TableCell = TableCell;
});
define("@ijstech/table/tableColumn.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/style", "@ijstech/application", "@ijstech/table/style/table.css.ts"], function (require, exports, base_3, icon_1, Styles, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableColumn = void 0;
    const Theme = Styles.Theme.ThemeVars;
    let TableColumn = class TableColumn extends base_3.Control {
        constructor(parent, options) {
            super(parent, options);
        }
        get data() {
            return this._data;
        }
        set data(value) {
            this._data = value;
            this.columnElm.textContent = `${value}`;
        }
        get rowData() {
            return this._rowData;
        }
        set rowData(value) {
            this._rowData = value;
        }
        get sortOrder() {
            return this._sortOrder;
        }
        set sortOrder(value) {
            this._sortOrder = value;
            if (value === 'asc') {
                this.ascElm && this.ascElm.classList.add('sort-icon--active');
                this.descElm && this.descElm.classList.remove('sort-icon--active');
            }
            else if (value === 'desc') {
                this.ascElm && this.ascElm.classList.remove('sort-icon--active');
                this.descElm && this.descElm.classList.add('sort-icon--active');
            }
            else {
                this.ascElm && this.ascElm.classList.remove('sort-icon--active');
                this.descElm && this.descElm.classList.remove('sort-icon--active');
            }
            if (value && typeof this.onSortChange === 'function')
                this.onSortChange(this, this.fieldName, value);
        }
        get textAlign() {
            return this._textAlign;
        }
        set textAlign(value) {
            this._textAlign = value || 'left';
            this.style.textAlign = value;
        }
        get caption() {
            let value = this._caption || '';
            if (value?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.application.i18n?.get(value) ||
                    '';
                return translated;
            }
            return value;
        }
        set caption(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._caption = value;
            this.columnElm && (this.columnElm.textContent = this.caption);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.columnElm && this._caption?.startsWith('$'))
                this.columnElm.textContent = i18n.get(this._caption) || '';
        }
        renderSort() {
            if (!this.sortable) {
                this.sortElm && (this.sortElm.style.display = 'none');
                return;
            }
            if (!this.sortElm) {
                this.sortElm = this.createElement('div', this);
                this.sortElm.classList.add('i-table-sort');
                this.ascElm = new icon_1.Icon(this, {
                    name: 'caret-up',
                    width: 14,
                    height: 14,
                    fill: Theme.text.primary
                });
                this.ascElm.classList.add('sort-icon', 'sort-icon--asc');
                this.ascElm.onClick = () => this.sortOrder = this.sortOrder === 'asc' ? 'none' : 'asc';
                this.descElm = new icon_1.Icon(this, {
                    name: 'caret-down',
                    width: 14,
                    height: 14,
                    fill: Theme.text.primary
                });
                this.descElm.classList.add('sort-icon', 'sort-icon--desc');
                this.descElm.onClick = () => this.sortOrder = this.sortOrder === 'desc' ? 'none' : 'desc';
                this.sortElm.appendChild(this.ascElm);
                this.sortElm.appendChild(this.descElm);
            }
            this.sortElm.style.display = 'block';
        }
        async appendNode(params) {
            if (!params)
                return;
            const { tdElm, rowData, rowIndex, cell } = params;
            this.rowData = rowData;
            if (!this.columnElm || !this.onRenderCell)
                return;
            let node = await this.onRenderCell(this, this.data, rowData, rowIndex, cell);
            if (!node)
                return;
            if (cell.rowSpan === 0 || cell.columnSpan === 0) {
                this.remove();
                tdElm.remove();
                return;
            }
            (cell.columnSpan > 1) && tdElm.setAttribute('colspan', cell.columnSpan + '');
            (cell.rowSpan > 1) && tdElm.setAttribute('rowspan', cell.rowSpan + '');
            if (typeof node === 'string' || typeof node === 'number') {
                this.columnElm.textContent = node + '';
            }
            else {
                this.columnElm.innerHTML = '';
                this.columnElm.appendChild(node);
            }
        }
        init() {
            if (!this.columnElm) {
                this._caption = this.options.title;
                this.fieldName = this.options.fieldName;
                if (this.options.key)
                    this.key = this.options.key;
                if (this.options.onRenderCell)
                    this.onRenderCell = this.options.onRenderCell.bind(this);
                if (this.options.textAlign)
                    this.textAlign = this.options.textAlign;
                this.setAttributeToProperty('grid');
                this.setAttributeToProperty('display');
                this.isHeader = this.options.header || false;
                this.visible = typeof this.options.visible === 'boolean' ? this.options.visible : true;
                this.columnElm = this.createElement('div', this);
                this.data = this.getAttribute('data', true);
                if (this.isHeader) {
                    this.columnElm.textContent = this.caption;
                    this.sortable = this.getAttribute('sortable', true, false);
                    if (this.options.onSortChange)
                        this.onSortChange = this.options.onSortChange;
                    if (this.options.sorter)
                        this.sorter = this.options.sorter;
                    this.renderSort();
                    const sortOrder = this.getAttribute('sortOrder', true);
                    if (sortOrder)
                        this.sortOrder = sortOrder;
                }
            }
        }
    };
    TableColumn = __decorate([
        (0, base_3.customElements)('i-table-column')
    ], TableColumn);
    exports.TableColumn = TableColumn;
});
define("@ijstech/table/utils.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterBy = exports.orderBy = exports.getValueByPath = exports.getSorter = exports.getColumnKey = exports.getColumnIndex = exports.paginate = void 0;
    const paginate = (array, pageSize, pageNumber) => {
        return array.slice((pageNumber - 1) * pageSize, pageNumber * pageSize);
    };
    exports.paginate = paginate;
    const getColumnIndex = (columns, key) => {
        const finded = columns.findIndex(column => column.fieldName === key);
        return finded;
    };
    exports.getColumnIndex = getColumnIndex;
    const getColumnKey = (columns, columnIdx) => {
        const column = columns[columnIdx];
        return column ? column.fieldName : '';
    };
    exports.getColumnKey = getColumnKey;
    const getSorter = (columns, key) => {
        const findedColumn = columns.find(column => column.fieldName === key);
        return findedColumn ? findedColumn.sorter : null;
    };
    exports.getSorter = getSorter;
    const getValueByPath = function (object, prop) {
        prop = prop || '';
        const paths = prop.split('.');
        let current = object;
        let result = null;
        for (let i = 0, j = paths.length; i < j; i++) {
            const path = paths[i];
            if (!current)
                break;
            if (i === j - 1) {
                result = current[path];
                break;
            }
            current = current[path];
        }
        return result;
    };
    exports.getValueByPath = getValueByPath;
    const orderBy = (list, sortConfig, columns) => {
        if (!sortConfig.length)
            return list;
        const sortFn = (a, b) => {
            let sorterCond;
            for (const config of sortConfig) {
                const { key, direction } = config;
                const sortDirection = direction === 'asc' ? 1 : -1;
                const sorter = (0, exports.getSorter)(columns, key);
                const value = sorter ? sorter(a, b) * sortDirection : (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0)) * sortDirection;
                sorterCond = sorterCond || value;
            }
            return sorterCond || 0;
        };
        return list.sort((a, b) => sortFn(a, b));
    };
    exports.orderBy = orderBy;
    const filterBy = (list, value, columnKey) => {
        let searchTerms = [];
        if (value) {
            if (Array.isArray(value) && value.length) {
                searchTerms = value.map(val => "^" + val + "$");
            }
            else {
                searchTerms.push("^" + value);
            }
        }
        const searchRegex = new RegExp(searchTerms.join('|'), 'g');
        const dataList = [...list];
        return dataList.filter(data => {
            return data[columnKey].match(searchRegex);
        });
    };
    exports.filterBy = filterBy;
});
define("@ijstech/table/tableRow.ts", ["require", "exports", "@ijstech/table/style/table.css.ts"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableRow = void 0;
    class TableRow {
        constructor(cells) {
            this.cells = cells;
        }
        get cells() {
            return this._cells;
        }
        set cells(value) {
            this._cells = value;
        }
    }
    exports.TableRow = TableRow;
});
define("@ijstech/table/table.ts", ["require", "exports", "@ijstech/base", "@ijstech/table/tableColumn.ts", "@ijstech/pagination", "@ijstech/table/utils.ts", "@ijstech/table/style/table.css.ts", "@ijstech/table/tableRow.ts", "@ijstech/table/tableCell.ts", "@ijstech/application"], function (require, exports, base_4, tableColumn_1, pagination_1, utils_1, table_css_1, tableRow_1, tableCell_1, application_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Table = void 0;
    // @customElements("i-table", {
    //   icon: 'table',
    //   group: GroupType.BASIC,
    //   className: 'Table',
    //   props: {
    //     heading: {
    //       type: 'boolean',
    //       default: true
    //     },
    //     data: {
    //       type: 'object'
    //     },
    //     columns: {
    //       type: 'array',
    //       default: []
    //     },
    //     pagination: {
    //       type: 'string',
    //       default: ''
    //     },
    //     expandable: {type: 'object'}
    //   },
    //   events: {},
    //   dataSchema: {
    //     type: 'object',
    //     properties: {
    //       heading: {
    //         type: 'boolean',
    //         format: 'boolean'
    //       },
    //       columns: {
    //         type: 'array',
    //         items: {
    //           type: 'object',
    //           properties: {
    //             fieldName: {
    //               type: 'string'
    //             },
    //             title: {
    //               type: 'string'
    //             },
    //             textAlign: {
    //               type: 'string',
    //               enum: ['left', 'right', 'center'],
    //               default: 'left'
    //             },
    //             sortable: {
    //               type: 'boolean',
    //               format: 'boolean'
    //             },
    //           }
    //         }
    //       }
    //     }
    //   }
    // })
    let Table = class Table extends base_4.Control {
        constructor(parent, options) {
            super(parent, options, {
                heading: true
            });
            this._rows = [];
            this.firstLoad = true;
            this._sortConfig = {};
            this._bodyStyle = '';
            this._headingStyle = '';
        }
        get data() {
            return this._data;
        }
        set data(value) {
            this._data = value;
            this.filteredData = value;
            if (this.pagination)
                this.pagination.totalPages = Math.ceil(value.length / this.pagination.pageSize);
            if (typeof this.renderBody === 'function')
                this.renderBody();
        }
        get filteredData() {
            return this.sortFn(this._filteredData);
        }
        set filteredData(value) {
            this._filteredData = value;
        }
        get hasData() {
            return this.filteredData && this.filteredData.length;
        }
        get sortConfig() {
            if (!this._sortConfig || !Object.keys(this._sortConfig).length)
                return [];
            const list = [];
            for (const col of this.columns) {
                const direction = this._sortConfig[col.fieldName];
                if (direction && direction !== 'none') {
                    list.push({ key: col.fieldName, direction });
                }
            }
            return list;
        }
        sortFn(list) {
            if (!list)
                return [];
            if (this.sortConfig.length) {
                return (0, utils_1.orderBy)([...list], this.sortConfig, this.columns);
            }
            return list;
        }
        get columns() {
            return this._columns || [];
        }
        set columns(value) {
            this._columns = value;
            this._heading && this.renderHeader();
            !this.firstLoad && typeof this.renderBody === 'function' && this.renderBody();
        }
        get rows() {
            return this._rows;
        }
        // set rows(value: TableRow[]) {
        //   this._rows = value;
        // }
        get pagination() {
            return this._pagination;
        }
        set pagination(value) {
            if (typeof value === 'string') {
                const elm = document.querySelector(`#${value}`);
                if (elm instanceof pagination_1.Pagination)
                    this._pagination = elm;
            }
            else if (value) {
                this._pagination = value;
                this.pagingElm.innerHTML = '';
                this.pagingElm.appendChild(this.pagination);
            }
            if (this._pagination) {
                this.pagingElm.style.display = 'flex';
                if (this.data)
                    this._pagination.totalPages = Math.ceil(this.data.length / this._pagination.pageSize);
                this._pagination.onPageChanged = this.onPageChanged.bind(this);
                this.renderBody();
            }
            else {
                this.pagingElm.style.display = 'none';
            }
        }
        get expandable() {
            return this._expandable;
        }
        set expandable(value) {
            this._expandable = value;
        }
        get hasExpandColumn() {
            return this.expandable && !!this.expandable.onRenderExpandIcon;
        }
        get columnLength() {
            return this.columns.length;
        }
        get mediaQueries() {
            return this._mediaQueries;
        }
        set mediaQueries(value) {
            this._mediaQueries = value;
            const style = (0, table_css_1.getTableMediaQueriesStyleClass)(this.columns, this._mediaQueries);
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        get headingStyles() {
            return this._headingStyles;
        }
        set headingStyles(value) {
            this._headingStyles = value;
            const newStyle = (0, table_css_1.getCustomStylesClass)(value);
            if (this._headingStyle) {
                const ths = this.querySelectorAll('th.i-table-cell');
                for (let th of ths) {
                    if (th.classList.contains(this._headingStyle)) {
                        th.classList.remove(this._headingStyle);
                        th.classList.add(newStyle);
                    }
                }
            }
            this._headingStyle = newStyle;
        }
        get bodyStyles() {
            return this._bodyStyles;
        }
        set bodyStyles(value) {
            this._bodyStyles = value;
            const newStyle = (0, table_css_1.getCustomStylesClass)(value);
            if (this._bodyStyle) {
                const tds = this.querySelectorAll('td.i-table-cell');
                for (let td of tds) {
                    if (td.classList.contains(this._bodyStyle)) {
                        td.classList.remove(this._bodyStyle);
                        td.classList.add(newStyle);
                    }
                }
            }
            this._bodyStyle = newStyle;
        }
        // private updateExpandColumn() {
        //   const expandIcon = this.expandable.onRenderExpandIcon;
        //   if (this.hasExpandColumn && expandIcon) {
        //     const trHeader = this.tHeadElm.querySelector('tr');
        //     const firstHeader = trHeader?.firstElementChild;
        //     if (firstHeader && firstHeader.classList.contains('i-table-cell--expand')) return;
        //     const thElm = this.createElement('th');
        //     thElm.classList.add('i-table-cell', 'i-table-cell--expand', 'text-center');
        //     if (firstHeader && firstHeader.parentNode)
        //       firstHeader.parentNode.insertBefore(thElm, firstHeader);
        //     const trBody = this.tBodyElm.querySelectorAll('tr');
        //     trBody.forEach(trElm => {
        //       const tdElm = this.createElement('td');
        //       tdElm.classList.add('i-table-cell', 'i-table-cell--expand', 'text-center');
        //       tdElm.appendChild(expandIcon(this, false));
        //       const tdFirst = trElm?.firstChild;
        //       if (tdFirst && tdFirst.parentNode)
        //         tdFirst.parentNode.insertBefore(tdElm, tdFirst);
        //     })
        //   } else {
        //     const expandedTd = this.querySelectorAll('.i-table-cell--expand');
        //     expandedTd.forEach(td => td.remove());
        //   }
        // }
        onPageChanged(source, value) {
            this.renderBody();
        }
        onSortChange(source, key, value) {
            this._sortConfig = this._sortConfig || {};
            this._sortConfig[key] = value;
            if (this.filteredData)
                this.renderBody();
            if (typeof this.onColumnSort === 'function')
                this.onColumnSort(this, key, value);
        }
        renderHeader() {
            this._headingStyle = (0, table_css_1.getCustomStylesClass)(this.headingStyles);
            this.tHeadElm.innerHTML = '';
            const rowElm = this.createElement('tr', this.tHeadElm);
            if (this.hasExpandColumn) {
                const thElm = this.createElement('th', rowElm);
                thElm.classList.add('i-table-cell', 'i-table-cell--expand', 'text-center', this._headingStyle);
            }
            if (!Array.isArray(this.columns))
                return;
            this.columns.forEach((column, colIndex) => {
                const thElm = this.createElement('th', rowElm);
                column.visible === false && (thElm.style.display = 'none');
                thElm.classList.add('i-table-cell', this._headingStyle);
                thElm.setAttribute('data-fieldname', column.fieldName || 'action');
                if (column.width)
                    thElm.style.width = typeof column.width === 'number' ? `${column.width}px` : column.width;
                column.textAlign && (thElm.style.textAlign = column.textAlign);
                const columnElm = new tableColumn_1.TableColumn(undefined, { ...column, header: true });
                columnElm.onSortChange = this.onSortChange.bind(this);
                thElm.appendChild(columnElm);
                rowElm.appendChild(thElm);
            });
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.tHeadElm) {
                const columns = this.tHeadElm.querySelectorAll('i-table-column');
                for (const column of columns) {
                    column.updateLocale(i18n);
                }
            }
        }
        _handleClick(event) {
            const target = event.target;
            if (target && this.hasData) {
                const rowElm = target.closest('.i-table-row');
                let colElm = target.closest('i-table-column');
                if (!colElm)
                    colElm = target.firstChild;
                const tdElm = target.closest('td');
                const rowData = colElm ? colElm.rowData : null;
                const rowIndex = rowElm?.getAttribute('data-index') || -1;
                const colIndex = tdElm?.getAttribute('data-index') || -1;
                if (typeof this.onCellClick === 'function' && rowIndex !== -1)
                    this.onCellClick(this, +rowIndex, +colIndex, rowData);
                if (this.expandable && rowElm) {
                    const expandTd = rowElm.querySelector('.i-table-cell--expand');
                    this.expandRow(rowElm, expandTd);
                }
            }
            return super._handleClick(event, true);
        }
        expandRow(rowElm, expandTd) {
            rowElm.classList.toggle('is--expanded');
            const expandElm = rowElm.nextElementSibling;
            if (expandElm) {
                const hidden = expandElm.style.display === 'none';
                if (expandTd && this.expandable.onRenderExpandIcon) {
                    expandTd.innerHTML = '';
                    expandTd.appendChild(this.expandable.onRenderExpandIcon(this, hidden));
                }
                expandElm.style.display = hidden ? 'table-row' : 'none';
            }
        }
        async renderRow(rowElm, rowData, rowIndex) {
            if (this.expandable) {
                const expandIcon = this.expandable.onRenderExpandIcon;
                if (expandIcon) {
                    const expandTd = this.createElement('td', rowElm);
                    expandTd.appendChild(expandIcon(this, false));
                    expandTd.classList.add('i-table-cell', 'i-table-cell--expand', 'text-center', this._bodyStyle);
                }
            }
            let row = [];
            for (let colIndex = 0; colIndex < this.columns.length; colIndex++) {
                const column = this.columns[colIndex];
                const columnData = rowData[column.fieldName];
                const cell = new tableCell_1.TableCell({
                    columnSpan: 1,
                    rowSpan: 1,
                    value: columnData ?? '--'
                });
                const tdElm = this.createElement('td', rowElm);
                column.visible === false && (tdElm.style.display = 'none');
                tdElm.classList.add('i-table-cell', this._bodyStyle);
                tdElm.setAttribute('data-index', colIndex.toString());
                tdElm.setAttribute('data-fieldname', column.fieldName || 'action');
                if (column.width)
                    tdElm.style.width = typeof column.width === 'number' ? `${column.width}px` : column.width;
                column.textAlign && (tdElm.style.textAlign = column.textAlign);
                const columnElm = new tableColumn_1.TableColumn(this, {
                    ...column,
                    data: columnData ?? '--'
                });
                tdElm.appendChild(columnElm);
                await columnElm.appendNode({ tdElm, rowData, rowIndex, cell });
                row.push(cell);
            }
            if (this._rows)
                this._rows[rowIndex] = new tableRow_1.TableRow(row);
        }
        renderBody() {
            if (!this.tBodyElm)
                return;
            this._bodyStyle = (0, table_css_1.getCustomStylesClass)(this.bodyStyles);
            this.tBodyElm.innerHTML = '';
            if (this.hasData) {
                const currentPage = this.pagination?.currentPage || 1;
                const pageSize = this.pagination?.pageSize || 10;
                const dataList = this.pagination ? (0, utils_1.paginate)(this.filteredData, pageSize, currentPage) : this.filteredData;
                dataList.forEach(async (row, rowIndex) => {
                    const rowElm = this.createElement('tr', this.tBodyElm);
                    rowElm.classList.add('i-table-row');
                    const orderClass = (rowIndex + 1) % 2 === 0 ? 'even' : 'odd';
                    rowElm.classList.add(orderClass);
                    // TODO: get index from rows
                    const rIndex = rowIndex + ((currentPage - 1) * pageSize);
                    rowElm.setAttribute('data-index', rIndex.toString());
                    this.renderRow(rowElm, row, rowIndex);
                    if (this.expandable && this.expandable.onRenderExpandedRow) {
                        const childElm = this.createElement('tr', this.tBodyElm);
                        childElm.classList.add('i-table-row--child');
                        childElm.style.display = 'none';
                        const tdChild = this.createElement('td', childElm);
                        tdChild.setAttribute('colspan', `${this.columnLength + (this.hasExpandColumn ? 1 : 0)}`);
                        const expandElm = await this.expandable.onRenderExpandedRow(row);
                        if (typeof expandElm === 'string')
                            tdChild.innerHTML = expandElm;
                        else
                            tdChild.appendChild(expandElm);
                        const hideExpanded = this.expandable.rowExpandable === false;
                        if (hideExpanded)
                            childElm.classList.add('hidden-desktop');
                    }
                });
            }
            else {
                const rowElm = this.createElement('tr', this.tBodyElm);
                const tdElm = this.createElement('td', rowElm);
                tdElm.setAttribute('colspan', `${this.columnLength + (this.hasExpandColumn ? 1 : 0)}`);
                tdElm.classList.add('i-table-cell', 'text-center', this._bodyStyle);
                if (typeof this.onRenderEmptyTable === 'function') {
                    this.onRenderEmptyTable(this);
                }
                else {
                    const label = this.createElement('span');
                    label.textContent = application_2.default.i18n.get('no_data');
                    tdElm.appendChild(label);
                }
            }
            this.firstLoad = false;
        }
        createTable() {
            const tableID = 'TTable_' + Date.now();
            this._tableID = tableID;
            this.tableElm = this.createElement('table', this.wrapperElm);
            this.tableElm.id = tableID;
            this.tableElm.style.width = '100%';
            if (this._heading) {
                this.tHeadElm = this.createElement('thead', this.tableElm);
                this.tHeadElm.classList.add('i-table-header');
            }
            this.tBodyElm = this.createElement('tbody', this.tableElm);
            this.tBodyElm.classList.add('i-table-body');
        }
        filter(predicate) {
            const dataList = [...this.data];
            this.filteredData = dataList.filter(predicate);
            this.renderBody();
        }
        init() {
            if (!this.tableElm) {
                this.classList.add('i-table', table_css_1.tableStyle);
                if (this.options?.onRenderEmptyTable)
                    this.onRenderEmptyTable = this.options.onRenderEmptyTable;
                if (this.options?.onColumnSort)
                    this.onColumnSort = this.options.onColumnSort;
                if (this.options?.onCellClick)
                    this.onCellClick = this.options.onCellClick;
                this.headingStyles = this.getAttribute('headingStyles', true);
                this.bodyStyles = this.getAttribute('bodyStyles', true);
                this.wrapperElm = this.createElement('div', this);
                this.wrapperElm.classList.add('i-table-container');
                this._heading = this.getAttribute('heading', true, false);
                this.createTable();
                this.expandable = this.getAttribute('expandable', true);
                const columnsAttr = this.getAttribute('columns', true);
                columnsAttr && (this.columns = columnsAttr);
                this.pagingElm = this.createElement('div', this.wrapperElm);
                this.pagingElm.classList.add('i-table-pagi');
                this.pagingElm.style.display = 'none';
                const paginationAttr = this.getAttribute('pagination');
                paginationAttr && (this.pagination = paginationAttr);
                const dataAttr = this.getAttribute('data', true);
                dataAttr && (this.data = dataAttr);
                const mediaQueries = this.getAttribute('mediaQueries', true);
                if (mediaQueries)
                    this.mediaQueries = mediaQueries;
                super.init();
            }
        }
        connectedCallback() {
            super.connectedCallback();
            if (!this.pagination) {
                const pagination = this.getAttribute('pagination');
                pagination && (this.pagination = pagination);
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_4.observable)('data', true)
    ], Table.prototype, "_data", void 0);
    Table = __decorate([
        (0, base_4.customElements)("i-table")
    ], Table);
    exports.Table = Table;
});
define("@ijstech/table", ["require", "exports", "@ijstech/table/table.ts", "@ijstech/table/tableColumn.ts", "@ijstech/table/tableRow.ts", "@ijstech/table/tableCell.ts"], function (require, exports, table_1, tableColumn_2, tableRow_2, tableCell_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableCell = exports.TableRow = exports.TableColumn = exports.Table = void 0;
    Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return table_1.Table; } });
    Object.defineProperty(exports, "TableColumn", { enumerable: true, get: function () { return tableColumn_2.TableColumn; } });
    Object.defineProperty(exports, "TableRow", { enumerable: true, get: function () { return tableRow_2.TableRow; } });
    Object.defineProperty(exports, "TableCell", { enumerable: true, get: function () { return tableCell_2.TableCell; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/carousel/style/carousel.css.ts", ["require", "exports", "@ijstech/style", "@ijstech/base"], function (require, exports, Styles, base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCarouselMediaQueriesStyleClass = exports.sliderStyle = void 0;
    const Theme = Styles.Theme.ThemeVars;
    exports.sliderStyle = Styles.style({
        display: 'flex',
        flexDirection: 'column',
        position: 'relative',
        width: '100%',
        overflow: 'hidden',
        margin: 0,
        padding: 0,
        $nest: {
            ".hidden": {
                display: 'none !important'
            },
            "> div": {
                flexGrow: 1
            },
            "i-carousel-item": {
                height: '100%'
            },
            ".wrapper-slider": {
                display: 'flex',
                alignItems: 'center',
            },
            ".wrapper-slider-list": {
                display: 'block',
                width: '100%',
                height: '100%',
                overflow: 'hidden',
            },
            ".slider-arrow": {
                width: 28,
                height: 28,
                fill: Theme.colors.primary.main,
                cursor: 'pointer',
            },
            ".slider-arrow-hidden": {
                visibility: 'hidden',
            },
            ".slider-list": {
                display: 'flex',
                position: 'relative',
                transition: 'transform 500ms ease',
                height: '100%',
                touchAction: 'none'
            },
            ".slider-list > *": {
                flexShrink: '0',
            },
            ".dots-pagination": {
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                padding: 0,
                marginBlock: '1rem',
                listStyle: 'none',
                gap: '0.4rem',
                position: 'absolute',
                bottom: '0px',
                left: '50%',
                transform: 'translateX(-50%)',
                $nest: {
                    ".--dot": {
                        display: 'flex',
                        cursor: 'pointer'
                    },
                    ".--dot > span": {
                        display: 'inline-block',
                        minWidth: '0.8rem',
                        minHeight: '0.8rem',
                        backgroundColor: 'transparent',
                        border: `2px solid ${Theme.colors.primary.main}`,
                        borderRadius: '50%',
                        transition: 'background-color 0.35s ease-in-out',
                        textAlign: 'center',
                        fontSize: '.75rem',
                        width: 'auto',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis'
                    },
                    ".--active > span": {
                        backgroundColor: Theme.colors.primary.main,
                    },
                }
            },
        }
    });
    const getCarouselMediaQueriesStyleClass = (mediaQueries) => {
        let styleObj = (0, base_1.getControlMediaQueriesStyle)(mediaQueries);
        for (let mediaQuery of mediaQueries) {
            let mediaQueryRule = (0, base_1.getMediaQueryRule)(mediaQuery);
            if (mediaQueryRule) {
                styleObj['$nest'][mediaQueryRule] = styleObj['$nest'][mediaQueryRule] || {};
                const ruleObj = styleObj['$nest'][mediaQueryRule];
                const nestObj = styleObj['$nest'][mediaQueryRule]['$nest'] || {};
                styleObj['$nest'][mediaQueryRule] = {
                    ...ruleObj,
                    $nest: {
                        ...nestObj,
                        '.dots-pagination': {}
                    }
                };
                const { indicators } = mediaQuery.properties || {};
                if (indicators !== undefined && indicators !== null) {
                    styleObj['$nest'][mediaQueryRule]['$nest']['.dots-pagination']['display'] = indicators ? `flex !important` : 'none !important';
                }
            }
        }
        return Styles.style(styleObj);
    };
    exports.getCarouselMediaQueriesStyleClass = getCarouselMediaQueriesStyleClass;
});
define("@ijstech/carousel/carousel.ts", ["require", "exports", "@ijstech/base", "@ijstech/icon", "@ijstech/carousel/style/carousel.css.ts", "@ijstech/types"], function (require, exports, base_2, icon_1, carousel_css_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CarouselSlider = void 0;
    ;
    const DEFAULT_VALUES = {
        slidesToShow: 1,
        transitionSpeed: 500,
        autoplay: false,
        autoplaySpeed: 3000,
        activeSlide: 0,
        type: 'dot',
        indicators: true,
        swipe: false
    };
    let CarouselSlider = class CarouselSlider extends base_2.Control {
        constructor(parent, options) {
            super(parent, options, { activeSlide: DEFAULT_VALUES.activeSlide });
            this._type = DEFAULT_VALUES.type;
            this._items = [];
            this._slider = [];
            this.pos1 = { x: 0, y: 0 };
            this.pos2 = { x: 0, y: 0 };
            this.threshold = 30;
            this.isHorizontalSwiping = false;
            this.dragStartHandler = this.dragStartHandler.bind(this);
            this.dragHandler = this.dragHandler.bind(this);
            this.dragEndHandler = this.dragEndHandler.bind(this);
        }
        get slidesToShow() {
            return this._slidesToShow;
        }
        set slidesToShow(value) {
            this._slidesToShow = value;
            this.renderItems(this.items);
            if (this.isArrow) {
                this.renderArrows();
            }
            else {
                this.renderDotPagination();
            }
        }
        get transitionSpeed() {
            return this._transitionSpeed;
        }
        set transitionSpeed(value) {
            this._transitionSpeed = value;
            this.sliderListElm.style.transitionDuration = value + "ms";
        }
        get autoplay() {
            return this._autoplay;
        }
        set autoplay(value) {
            this._autoplay = value;
            this.setAutoplay();
        }
        get autoplaySpeed() {
            return this._autoplaySpeed;
        }
        set autoplaySpeed(value) {
            this._autoplaySpeed = value;
            this.setAutoplay();
        }
        get activeSlide() {
            return this._activeSlide || DEFAULT_VALUES.activeSlide;
        }
        set activeSlide(value) {
            if (this.isArrow) {
                this.updateSliderByArrows(value);
                return;
            }
            const validValue = value >= 0 && value < this.dotsElm.length ? value : 0;
            this._activeSlide = validValue;
            const currentActive = this.dotPagination.querySelector('li.--active');
            const dot = this.dotsElm[this._activeSlide];
            currentActive && currentActive.classList.remove('--active');
            dot && dot.classList.add('--active');
            if (this._slider && this._slider.length) {
                const min = this.slidesToShow * validValue;
                const max = this.slidesToShow * (validValue + 1);
                for (let i = 0; i < this._slider.length; i++) {
                    if (i >= min && i < max)
                        this._slider[i].classList.add('is-actived');
                    else
                        this._slider[i].classList.remove('is-actived');
                }
            }
            const fixedWidth = this.slidesToShow === 1 && this._slider && this._slider[0]?.offsetWidth && this._slider[0].offsetWidth !== this.offsetWidth;
            const tx = fixedWidth ? -this._slider[0].offsetWidth * this._activeSlide : -this.offsetWidth * this._activeSlide;
            this.sliderListElm.style.transform = `translateX(${tx}px)`;
        }
        get items() {
            return this._items;
        }
        set items(nodes) {
            this.renderItems(nodes);
            if (this.isArrow) {
                this.renderArrows();
            }
            else {
                this.renderDotPagination();
            }
            this.setAutoplay();
        }
        add(control) {
            const options = { name: '', controls: [control] };
            this.items.push(options);
            const carouselItem = new CarouselItem(this, options);
            carouselItem.width = (100 / this.slidesToShow) + "%";
            this._slider.push(carouselItem);
            this.sliderListElm.appendChild(carouselItem);
            if (this.isArrow) {
                this.renderArrows();
            }
            else {
                this.renderDotPagination();
            }
            return control;
        }
        get type() {
            return this._type;
        }
        set type(value) {
            this._type = value;
            this.updateWrapperClass();
            if (this.isArrow) {
                this.renderArrows();
            }
            else {
                this.renderDotPagination();
            }
            if (this.arrowPrev)
                this.arrowPrev.visible = this.isArrow;
            if (this.arrowNext)
                this.arrowNext.visible = this.isArrow;
        }
        get swipe() {
            return this._swipe;
        }
        set swipe(value) {
            this._swipe = value;
            // if (this._swipe) {
            //   this.sliderListElm.onmousedown = this.dragStartHandler;
            //   this.sliderListElm.addEventListener('touchstart', this.dragStartHandler);
            //   this.sliderListElm.addEventListener('touchend', this.dragEndHandler);
            //   this.sliderListElm.addEventListener('touchmove', this.dragHandler);
            // } else {
            //   this.sliderListElm.onmousedown = null;
            //   this.sliderListElm.removeEventListener('touchstart', this.dragStartHandler);
            //   this.sliderListElm.removeEventListener('touchend', this.dragEndHandler);
            //   this.sliderListElm.removeEventListener('touchmove', this.dragHandler);
            // }
        }
        get mediaQueries() {
            return this._mediaQueries;
        }
        set mediaQueries(value) {
            this._mediaQueries = value;
            let style = (0, carousel_css_1.getCarouselMediaQueriesStyleClass)(this._mediaQueries);
            this._mediaStyle && this.classList.remove(this._mediaStyle);
            this._mediaStyle = style;
            this.classList.add(style);
        }
        _handleMouseDown(event, stopPropagation) {
            const result = super._handleMouseDown(event, stopPropagation);
            if (result !== undefined) {
                const target = event.target;
                const sliderList = target.closest('.slider-list');
                if (sliderList && this.swipe) {
                    this.dragStartHandler(event);
                    return true;
                }
            }
            return false;
        }
        _handleMouseMove(event, stopPropagation) {
            const result = super._handleMouseMove(event, stopPropagation);
            if (result !== undefined) {
                const target = event.target;
                const sliderList = target.closest('.slider-list');
                if (sliderList && this.swipe) {
                    this.dragHandler(event);
                    return this.isHorizontalSwiping;
                }
            }
            return false;
        }
        _handleMouseUp(event, stopPropagation) {
            const result = super._handleMouseUp(event, stopPropagation);
            if (result !== undefined) {
                const target = event.target;
                const sliderList = target.closest('.slider-list');
                if (sliderList && this.swipe) {
                    this.dragEndHandler(event);
                    return true;
                }
            }
            return false;
        }
        get indicators() {
            return this._indicators;
        }
        set indicators(value) {
            this._indicators = value;
            if (this.dotPagination) {
                value ? this.dotPagination.classList.remove('hidden') : this.dotPagination.classList.add('hidden');
            }
        }
        get isArrow() {
            return this.type === 'arrow';
        }
        // disconnectedCallback(): void {
        //   this.sliderListElm.onmousedown = null;
        //   this.sliderListElm.removeEventListener('touchstart', this.dragStartHandler);
        //   this.sliderListElm.removeEventListener('touchend', this.dragEndHandler);
        //   this.sliderListElm.removeEventListener('touchmove', this.dragHandler);
        //   super.disconnectedCallback();
        // }
        updateArrows(prev, next) {
            if (this.arrowPrev && this.arrowNext) {
                if (prev) {
                    this.arrowPrev.classList.remove('slider-arrow-hidden');
                }
                else {
                    this.arrowPrev.classList.add('slider-arrow-hidden');
                }
                if (next) {
                    this.arrowNext.classList.remove('slider-arrow-hidden');
                }
                else {
                    this.arrowNext.classList.add('slider-arrow-hidden');
                }
            }
        }
        updateSliderByArrows(value) {
            if (!this._slider)
                return;
            const lastIdx = value + this.slidesToShow;
            const validValue = value >= 0 && lastIdx <= this._slider.length ? value : 0;
            this.updateArrows(validValue > 0, lastIdx < this._slider.length);
            this._activeSlide = validValue;
            const fixedWidth = this.slidesToShow === 1 && this._slider && this._slider[0]?.offsetWidth && this._slider[0].offsetWidth !== (this.offsetWidth - 50);
            const itemWidth = this._slider && this._slider[0] ? this._slider[0].offsetWidth : (this.offsetWidth - 50) / this.slidesToShow;
            const tx = fixedWidth ? -this._slider[0].offsetWidth * this._activeSlide : -itemWidth * this._activeSlide;
            this.sliderListElm.style.transform = `translateX(${tx}px)`;
            if (this._slider && this._slider.length) {
                const min = validValue;
                const max = this.slidesToShow + validValue;
                for (let i = 0; i < this._slider.length; i++) {
                    if (i >= min && i < max)
                        this._slider[i].classList.add('is-actived');
                    else
                        this._slider[i].classList.remove('is-actived');
                }
            }
        }
        updateWrapperClass() {
            if (!this.wrapperSliderElm)
                return;
            if (this.isArrow) {
                this.wrapperSliderElm.classList.add('wrapper-slider');
            }
            else {
                this.wrapperSliderElm.classList.remove('wrapper-slider');
            }
        }
        renderItems(items) {
            if (!this.sliderListElm)
                return;
            this._items = items;
            this.sliderListElm.innerHTML = '';
            if (!items)
                return;
            let list = [];
            const min = this.slidesToShow * this.activeSlide;
            const max = this.slidesToShow * (this.activeSlide + 1);
            for (let index = 0; index < items.length; index++) {
                const itemData = items[index];
                const carouselItem = new CarouselItem(this, itemData);
                if (itemData.width)
                    carouselItem.width = itemData.width;
                else
                    carouselItem.width = (100 / this.slidesToShow) + "%";
                if (index >= min && index < max)
                    carouselItem.classList.add('is-actived');
                list.push(carouselItem);
                this._slider = list;
                this.sliderListElm.appendChild(carouselItem);
            }
        }
        renderDotPagination() {
            if (!this.dotPagination)
                return;
            this.dotPagination.innerHTML = '';
            this.dotsElm = [];
            if (this.isArrow) {
                this.dotPagination.classList.add('hidden');
                return;
            }
            const isShownIndicators = this.indicators && this.items?.length > 1;
            isShownIndicators ? this.dotPagination.classList.remove('hidden') : this.dotPagination.classList.add('hidden');
            if (this.items?.length) {
                const childLength = this.items.length;
                const totalDots = this.slidesToShow > 0 ? Math.ceil(childLength / this.slidesToShow) : childLength;
                for (let i = 0; i < totalDots; i++) {
                    const dotElm = this.createElement('li', this.dotPagination);
                    dotElm.classList.add('--dot');
                    if (this.activeSlide === i)
                        dotElm.classList.add('--active');
                    this.createElement('span', dotElm);
                    dotElm.addEventListener('click', () => {
                        if (this._designMode)
                            return;
                        this.onDotClick(i);
                        this.setAutoplay();
                    });
                    this.dotsElm.push(dotElm);
                }
            }
        }
        renderArrows() {
            if (!this.arrowPrev || !this.arrowNext)
                return;
            if (this.dotPagination) {
                this.dotPagination.innerHTML = '';
                this.dotPagination.classList.add('hidden');
                this.dotsElm = [];
            }
            if (this.hasChildNodes() && this.sliderListElm.childNodes.length) {
                const childLength = this.sliderListElm.childNodes.length;
                const isArrowShown = childLength > this.slidesToShow && this.isArrow;
                this.updateArrows(isArrowShown, isArrowShown);
            }
            else {
                this.updateArrows(false, false);
            }
        }
        onDotClick(index) {
            this.activeSlide = index;
            if (typeof this.onSlideChange === 'function')
                this.onSlideChange(index);
        }
        setAutoplay() {
            if (this.timer) {
                clearInterval(this.timer);
            }
            if (this.autoplay) {
                if (!this.isArrow && this.dotsElm.length > 1) {
                    this.timer = setInterval(() => {
                        const index = this.activeSlide + 1 >= this.dotsElm.length ? 0 : this.activeSlide + 1;
                        this.onDotClick(index);
                    }, this.autoplaySpeed);
                }
                else if (this.isArrow) {
                    this.timer = setInterval(() => {
                        if (this._slider && this._slider.length > this.slidesToShow) {
                            let idx = 0;
                            if (this._slider) {
                                idx = this.activeSlide + this.slidesToShow >= this._slider.length ? 0 : this.activeSlide + 1;
                            }
                            this.updateSliderByArrows(idx);
                        }
                    }, this.autoplaySpeed);
                }
            }
        }
        prev() {
            const index = this.activeSlide - 1 < 0 ? this.activeSlide : this.activeSlide - 1;
            this.activeSlide = index;
            this.setAutoplay();
            if (typeof this.onSlideChange === 'function')
                this.onSlideChange(index);
        }
        next() {
            let index;
            if (!this.isArrow) {
                const total = this.slidesToShow > 0 ? Math.ceil(this._slider.length / this.slidesToShow) : this._slider.length;
                index = this.activeSlide + 1 >= total ? this.activeSlide : this.activeSlide + 1;
            }
            else {
                index = this.activeSlide + this.slidesToShow >= this._slider.length ? this.activeSlide : this.activeSlide + 1;
            }
            this.activeSlide = index;
            this.setAutoplay();
            if (typeof this.onSlideChange === 'function')
                this.onSlideChange(index);
        }
        refresh() {
            super.refresh();
            if (this._slider && this._slider.length) {
                if (this.isArrow) {
                    this.updateSliderByArrows(this.activeSlide);
                    return;
                }
                const fixedWidth = this.slidesToShow === 1 && this._slider[0] && this._slider[0].offsetWidth && this._slider[0].offsetWidth !== this.offsetWidth;
                const tx = fixedWidth ? -this._slider[0].offsetWidth * this._activeSlide : -this.offsetWidth * this._activeSlide;
                this.sliderListElm.style.transform = `translateX(${tx}px)`;
            }
        }
        dragStartHandler(event) {
            if (event instanceof TouchEvent) {
                this.pos1 = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
                this.pos2 = {
                    x: 0,
                    y: 0
                };
            }
            else {
                event.preventDefault();
                this.pos1 = {
                    x: event.clientX,
                    y: event.clientY
                };
                this.pos2 = {
                    x: 0,
                    y: 0
                };
            }
            this.isSwiping = false;
            this.isHorizontalSwiping = false;
            if (typeof this.onSwipeStart === 'function')
                this.onSwipeStart();
        }
        dragHandler(event) {
            if (event instanceof TouchEvent) {
                this.pos2.x = this.pos1.x - event.touches[0].clientX;
                this.pos2.y = this.pos1.y - event.touches[0].clientY;
            }
            else {
                this.pos2.x = this.pos1.x - event.clientX;
                this.pos2.y = this.pos1.y - event.clientY;
            }
            this.isSwiping = Math.abs(this.pos2.x) > this.threshold;
            this.isHorizontalSwiping = this.isSwiping && Math.abs(this.pos2.x) > Math.abs(this.pos2.y);
        }
        dragEndHandler(event) {
            if (this.isHorizontalSwiping) {
                if (this.pos2.x < -this.threshold) {
                    this.prev();
                }
                else if (this.pos2.x > this.threshold) {
                    this.next();
                }
                else {
                    this.refresh();
                }
            }
            if (typeof this.onSwipeEnd === 'function')
                this.onSwipeEnd(this.isSwiping);
        }
        init() {
            const children = [];
            this.childNodes.forEach(node => {
                if (node instanceof base_2.Control) {
                    children.push(node);
                }
                else {
                    node.remove();
                }
            });
            super.init();
            this.classList.add(carousel_css_1.sliderStyle);
            this.type = this.getAttribute('type', true, DEFAULT_VALUES.type);
            this.indicators = this.getAttribute('indicators', true, DEFAULT_VALUES.indicators);
            this.wrapperSliderElm = this.createElement('div', this);
            this.updateWrapperClass();
            const wrapper = this.createElement('div', this.wrapperSliderElm);
            wrapper.classList.add('wrapper-slider-list');
            this.slidesToShow = this.getAttribute('slidesToShow', true, DEFAULT_VALUES.slidesToShow);
            this.sliderListElm = this.createElement('div', wrapper);
            this.sliderListElm.classList.add('slider-list');
            this.transitionSpeed = this.getAttribute('transitionSpeed', true, DEFAULT_VALUES.transitionSpeed);
            this.arrowPrev = new icon_1.Icon(undefined, { name: 'angle-left', visible: this.isArrow });
            this.arrowNext = new icon_1.Icon(undefined, { name: 'angle-right', visible: this.isArrow });
            this.arrowPrev.classList.add('slider-arrow');
            this.arrowNext.classList.add('slider-arrow');
            this.arrowPrev.onClick = () => {
                if (this._designMode)
                    return;
                this.prev();
            };
            this.arrowNext.onClick = () => {
                if (this._designMode)
                    return;
                this.next();
            };
            this.wrapperSliderElm.prepend(this.arrowPrev);
            this.wrapperSliderElm.append(this.arrowNext);
            this.renderArrows();
            this.dotPagination = this.createElement('ul', this);
            this.dotPagination.classList.add('dots-pagination');
            this.renderDotPagination();
            this.autoplaySpeed = this.getAttribute('autoplaySpeed', true, DEFAULT_VALUES.autoplaySpeed);
            this.autoplay = this.getAttribute('autoplay', true);
            if (children?.length) {
                children.forEach(child => {
                    this.add(child);
                });
            }
            else {
                this.items = this.getAttribute('items', true, []);
            }
            this.activeSlide = this.getAttribute('activeSlide', true, DEFAULT_VALUES.activeSlide);
            this.swipe = this.getAttribute('swipe', true, DEFAULT_VALUES.swipe);
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    CarouselSlider = __decorate([
        (0, base_2.customElements)('i-carousel-slider', {
            icon: 'sliders-h',
            group: types_1.GroupType.BASIC,
            className: 'CarouselSlider',
            props: {
                slidesToShow: { type: 'number', default: DEFAULT_VALUES.slidesToShow },
                transitionSpeed: { type: 'number', default: DEFAULT_VALUES.transitionSpeed },
                autoplay: { type: 'boolean', default: DEFAULT_VALUES.autoplay },
                autoplaySpeed: { type: 'number', default: DEFAULT_VALUES.autoplaySpeed },
                activeSlide: { type: 'number', default: DEFAULT_VALUES.activeSlide },
                type: { type: 'string', default: DEFAULT_VALUES.type },
                indicators: { type: 'boolean', default: DEFAULT_VALUES.indicators },
                swipe: { type: 'boolean', default: DEFAULT_VALUES.swipe },
                items: { type: 'array', default: [] },
            },
            events: {
                onSwipeStart: [],
                onSwipeEnd: [
                    { name: 'isSwiping', type: 'boolean' }
                ],
                onSlideChange: [
                    { name: 'index', type: 'number' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['dot', 'arrow'],
                        default: DEFAULT_VALUES.type
                    },
                    slidesToShow: {
                        type: 'number',
                        default: DEFAULT_VALUES.slidesToShow
                    },
                    transitionSpeed: {
                        type: 'number',
                        default: DEFAULT_VALUES.transitionSpeed
                    },
                    autoplay: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.autoplay
                    },
                    autoplaySpeed: {
                        type: 'number',
                        default: DEFAULT_VALUES.autoplaySpeed
                    },
                    activeSlide: {
                        type: 'number',
                        default: DEFAULT_VALUES.activeSlide
                    },
                    indicators: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.indicators
                    },
                    swipe: {
                        type: 'boolean',
                        default: DEFAULT_VALUES.swipe
                    }
                }
            }
        })
    ], CarouselSlider);
    exports.CarouselSlider = CarouselSlider;
    let CarouselItem = class CarouselItem extends base_2.Container {
        constructor(parent, options) {
            super(parent, options);
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._name = value;
        }
        addChildControl(control) {
            this.appendChild(control);
        }
        removeChildControl(control) {
            if (this.contains(control))
                this.removeChild(control);
        }
        init() {
            this.name = this.options.name;
            this._controls = this.options.controls || [];
            super.init();
            this._controls.forEach(child => {
                this.addChildControl(child);
            });
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    CarouselItem = __decorate([
        (0, base_2.customElements)('i-carousel-item')
    ], CarouselItem);
});
define("@ijstech/carousel", ["require", "exports", "@ijstech/carousel/carousel.ts"], function (require, exports, carousel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CarouselSlider = void 0;
    Object.defineProperty(exports, "CarouselSlider", { enumerable: true, get: function () { return carousel_1.CarouselSlider; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/video/style/video.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Styles.cssRule("i-video", {
        position: 'relative',
        $nest: {
            '.video-js  .vjs-big-play-button': {
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)'
            },
            '.overlay': {
                position: 'absolute',
                top: '0px',
                left: '0px',
                width: '100%',
                height: 'calc(100% - 3rem)',
                zIndex: 9999,
                display: 'none',
            },
            '@media screen and (max-width: 767px)': {
                $nest: {
                    '.overlay': {
                        display: 'block'
                    }
                }
            }
        }
    });
});
define("@ijstech/video/video.ts", ["require", "exports", "@ijstech/base", "@ijstech/types", "@ijstech/video/style/video.css.ts"], function (require, exports, base_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Video = void 0;
    const reqs = ['video-js'];
    function loadCss() {
        const cssId = 'videoCss';
        if (!document.getElementById(cssId)) {
            const head = document.getElementsByTagName('head')[0];
            const link = document.createElement('link');
            link.id = cssId;
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = `${base_1.LibPath}lib/video-js/video-js.css`;
            link.media = 'all';
            head.appendChild(link);
        }
    }
    let Video = class Video extends base_1.Container {
        constructor() {
            super(...arguments);
            this._isPlayed = false;
        }
        get url() {
            return this._url;
        }
        set url(value) {
            this._url = value;
            if (!this.sourceElm)
                this.sourceElm = this.createElement('source', this.videoElm);
            this.sourceElm.src = value;
            if (this.player) {
                if (value) {
                    this.sourceElm.type = "application/x-mpegURL";
                    this.player.src({
                        src: value,
                        type: 'application/x-mpegURL'
                    });
                }
                else {
                    this.player.reset();
                }
            }
            else {
                const videoEl = this.videoElm;
                if (videoEl?.load)
                    videoEl.load();
            }
        }
        get border() {
            return this._border;
        }
        set border(value) {
            const video = this.videoElm?.querySelector('video');
            if (!video)
                return;
            this._border = new base_1.Border(video, value);
        }
        set designMode(value) {
            this._designMode = value;
            if (this.overlayElm) {
                this.overlayElm.style.height = value ? '100%' : 'calc(100% - 3rem)';
                this.overlayElm.style.display = value ? 'block' : 'none';
            }
        }
        getPlayer() {
            if (this.player)
                return this.player;
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => {
                    if (this.player) {
                        clearInterval(interval);
                        resolve(this.player);
                    }
                }, 100);
            });
        }
        getVideoTypeFromExtension(url) {
            if (!url)
                return null;
            let videoType;
            let ext = url.split('.').pop();
            switch (ext) {
                case 'mp4':
                    videoType = 'video/mp4';
                    break;
                case 'webm':
                    videoType = 'video/webm';
                    break;
                case 'ogg':
                    videoType = 'video/ogg';
                    break;
                default:
                    videoType = 'video/mp4';
                    break;
            }
            return videoType;
        }
        init() {
            if (!this.initialized) {
                super.init();
                loadCss();
                this.overlayElm = this.createElement("div", this);
                this.overlayElm.classList.add('overlay');
                this.overlayElm.style.height = this._designMode ? '100%' : 'calc(100% - 3rem)';
                this.overlayElm.style.display = this._designMode ? 'block' : 'none';
                const self = this;
                const isStreaming = this.getAttribute('isStreaming', true);
                if (isStreaming) {
                    let id = `video-${new Date().getTime()}`;
                    this.videoElm = this.createElement("video-js", this);
                    this.videoElm.id = id;
                    this.videoElm.setAttribute("controls", "true");
                    this.videoElm.setAttribute("preload", "auto");
                    this.videoElm.classList.add('vjs-default-skin');
                    this.overlayElm.addEventListener('click', (event) => {
                        if (this._designMode)
                            return;
                        event.preventDefault();
                        event.stopPropagation();
                        if (this.player.paused()) {
                            this.player.play();
                        }
                        else {
                            this.player.pause();
                        }
                    });
                    const src = this.getAttribute('url', true);
                    const border = this.getAttribute('border', true);
                    base_1.RequireJS.config({
                        baseUrl: `${base_1.LibPath}lib/video-js`,
                        paths: {
                            'video-js': 'video-js'
                        }
                    });
                    base_1.RequireJS.require(reqs, function (videojs) {
                        self.player = videojs(id, {
                            playsinline: true,
                            autoplay: false,
                            controls: true,
                            fluid: true,
                            responsive: true,
                            inactivityTimeout: 500,
                            preload: "auto",
                            techOrder: ["html5"],
                            plugins: {},
                            height: '100%',
                            width: '100%'
                        });
                        if (src) {
                            self.sourceElm = self.createElement("source", self.videoElm);
                            self.sourceElm.type = "application/x-mpegURL";
                            self.sourceElm.src = src;
                            self.player.src({
                                src,
                                type: 'application/x-mpegURL'
                            });
                        }
                        const video = self.videoElm.querySelector('video');
                        if (video) {
                            self.videoElm.insertBefore(self.overlayElm, video);
                            if (border)
                                self._border = new base_1.Border(video, border);
                        }
                    });
                }
                else {
                    this.videoElm = this.createElement("video", this);
                    this.videoElm.setAttribute("controls", "true");
                    this.videoElm.setAttribute("width", "100%");
                    this.insertBefore(this.overlayElm, this.videoElm);
                    this.overlayElm.addEventListener('click', (event) => {
                        if (this._designMode)
                            return;
                        event.preventDefault();
                        event.stopPropagation();
                        if (this._isPlayed) {
                            const video = this.videoElm;
                            if (video.paused) {
                                video.play();
                            }
                            else {
                                video.pause();
                            }
                        }
                    });
                    this.videoElm.addEventListener('canplay', () => {
                        this._isPlayed = true;
                    });
                    this.sourceElm = this.createElement("source", this.videoElm);
                    this.url = this.getAttribute('url', true);
                    let videoType = this.getVideoTypeFromExtension(this.url);
                    if (videoType) {
                        this.sourceElm.type = videoType;
                    }
                }
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    Video = __decorate([
        (0, base_1.customElements)("i-video", {
            icon: 'play-circle',
            group: types_1.GroupType.BASIC,
            className: 'Video',
            props: {
                url: { type: 'string', default: '' },
                isStreaming: { type: 'boolean', default: false }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    url: { type: 'string' },
                    isStreaming: { type: 'boolean', default: false }
                }
            }
        })
    ], Video);
    exports.Video = Video;
});
define("@ijstech/video", ["require", "exports", "@ijstech/video/video.ts"], function (require, exports, video_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Video = void 0;
    Object.defineProperty(exports, "Video", { enumerable: true, get: function () { return video_1.Video; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/schema-designer/uiSchema.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/label", "@ijstech/input", "@ijstech/combo-box", "@ijstech/checkbox", "@ijstech/button", "@ijstech/icon", "@ijstech/style"], function (require, exports, base_1, layout_1, label_1, input_1, combo_box_1, checkbox_1, button_1, icon_1, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaDesignerUI = void 0;
    const Theme = Styles.Theme.ThemeVars;
    const dataUITypes = [
        { label: 'VerticalLayout', value: 'VerticalLayout' },
        { label: 'HorizontalLayout', value: 'HorizontalLayout' },
        { label: 'Group', value: 'Group' },
        { label: 'Categorization', value: 'Categorization' },
        { label: 'Category', value: 'Category' },
        { label: 'Control', value: 'Control' }
    ];
    let SchemaDesignerUI = class SchemaDesignerUI extends base_1.Container {
        constructor(parent, options) {
            super(parent, options);
        }
        init() {
            super.init();
            this.initUI();
            this.createUISchema(this.pnlUISchemaBuilder);
            this.updateJsonUISchema();
        }
        refresh() {
            super.refresh();
        }
        getUISchema() {
            return this.uiSchema;
        }
        updateJsonUISchema() {
            this.uiSchema = this.pnlUISchemaBuilder.firstChild.getData();
            this.txtUISchema.value = JSON.stringify(this.uiSchema, null, 4);
        }
        async getUISchemaMap(_schema, _options) {
            let data = _schema || this.schema;
            data = { ...data };
            const { _scope, _name, _scopeArr, _isRule, _getScope } = _options || {};
            if (_scopeArr) {
                const scopes = _scopeArr.split('/');
                scopes.splice(0, 1);
                for (const item of scopes) {
                    data = data[item];
                }
                data = data.items;
            }
            let mapSchema = [];
            const props = data.properties;
            for (const prop in props) {
                const { type, items, oneOf } = props[prop];
                const scope = `${_scope || '#'}/properties/${prop}`;
                const name = _name ? `${_name}/${prop}` : prop;
                const isArrItems = type === 'array' && items.type === 'object';
                if (_isRule) {
                    if (type !== 'object' && type !== 'array' && !this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`)) {
                        mapSchema.push({ label: name, value: scope, type: type });
                    }
                }
                else {
                    if (_getScope && scope === _getScope) {
                        return [{ label: name, value: scope, type: type, hasItems: isArrItems, isOneOf: oneOf?.lenght, isEnum: props[prop].enum?.length }];
                    }
                    if (!this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`)) {
                        mapSchema.push({ label: name, value: scope, type: type, hasItems: isArrItems, isOneOf: oneOf?.lenght, isEnum: props[prop].enum?.length });
                    }
                    else {
                        continue;
                    }
                }
                if (type === 'object') {
                    mapSchema.push(...(await this.getUISchemaMap(props[prop], { _scope: scope, _name: name, _isRule })));
                }
                else if (isArrItems) {
                    mapSchema.push(...(await this.getUISchemaMap(items, { _scope: scope, _name: name, _isRule })));
                }
            }
            return mapSchema;
        }
        getScopeByFields(fields) {
            let _fields = [];
            for (const fld of fields) {
                if (_fields[_fields.length - 1] !== this.uuid && fld === 'items') {
                    continue;
                }
                _fields.push(fld);
            }
            return _fields;
        }
        async updateActionsItems() {
            const arrCbb = this.pnlUISchemaBuilder.querySelectorAll('[cbb-property]');
            const items = await this.getUISchemaMap(this.schema);
            for (const cbb of arrCbb) {
                const scopeArr = cbb.getAttribute('cbb-property-array');
                if (scopeArr) {
                    cbb.items = await this.getUISchemaMap(this.schema, { _scopeArr: scopeArr });
                }
                else {
                    cbb.items = items;
                }
            }
            // const arrBtnAdd = this.pnlUISchemaBuilder.querySelectorAll('[add-element]');
            // const status = !!items.length;
            // for (const btn of arrBtnAdd) {
            //     (btn as Button).enabled = status;
            //     if (status) {
            //         (btn as Button).tooltip.content = '';
            //     } else {
            //         (btn as Button).tooltip.content = 'There is no properties';
            //     }
            // }
        }
        async updateActionsRules() {
            const arrCbb = this.pnlUISchemaBuilder.querySelectorAll('[cbb-rule]');
            const items = await this.getUISchemaMap(this.schema, { _isRule: true });
            for (const cbb of arrCbb) {
                cbb.items = items;
            }
        }
        async updateUISchemaItemsByRename(fields, newFields) {
            const _fields = this.getScopeByFields(fields);
            const _newFields = this.getScopeByFields(newFields);
            const regexUUID = new RegExp(this.uuid, 'g');
            const scope = `#/${_fields.join('/').replace(regexUUID, 'properties')}`;
            const newScope = `#/${_newFields.join('/').replace(regexUUID, 'properties')}`;
            const picked = this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`);
            const childPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-element*='${scope}/']`);
            const rulePicked = this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`);
            const ruleChildPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-rule*='${scope}/']`);
            const arrPicked = this.pnlUISchemaBuilder.querySelector(`[cbb-property-array='${scope}']`);
            const arrChildPicked = this.pnlUISchemaBuilder.querySelectorAll(`[full-scope-element*='${scope}']`);
            const items = await this.getUISchemaMap(this.schema);
            const ruleItems = await this.getUISchemaMap(this.schema, { _isRule: true });
            const regexLabel = new RegExp(`${this.uuid}/`, 'g');
            const label = `${_fields.join('/').replace(regexLabel, '')}`;
            const newLabel = `${_newFields.join('/').replace(regexLabel, '')}`;
            if (picked) {
                picked.setAttribute('scope-element', newScope);
                picked.options['scope-element'] = newScope;
                picked.items = items;
                picked.selectedItem = { label: newLabel, value: newScope };
            }
            for (const _picked of childPicked) {
                const childScope = _picked.getAttribute('scope-element') || '';
                const newChildScope = childScope.replace(scope, newScope);
                const currentLabel = _picked.selectedItem.label || '';
                const _newLb = currentLabel.replace(label, newLabel);
                _picked.setAttribute('scope-element', newChildScope);
                _picked.options['scope-element'] = newChildScope;
                _picked.items = items;
                _picked.selectedItem = { label: _newLb, value: newChildScope };
            }
            if (arrPicked) {
                arrPicked.setAttribute('cbb-property-array', newScope);
                arrPicked.options['cbb-property-array'] = newScope;
            }
            for (const _itemPick of arrChildPicked) {
                const fullScope = _itemPick.getAttribute('full-scope-element') || '';
                if (fullScope === scope) {
                    _itemPick.setAttribute('full-scope-element', newScope);
                    _itemPick.options['full-scope-element'] = newScope;
                    const scopeLength = (_itemPick.getAttribute('scope-element') || '').split('/').length - 1;
                    const arrNewScope = newScope.split('/');
                    arrNewScope.splice(0, arrNewScope.length - scopeLength);
                    const list = await this.getUISchemaMap(this.schema, { _scopeArr: _itemPick.getAttribute('cbb-property-array') || '' });
                    _itemPick.items = list;
                    _itemPick.setAttribute('scope-element', `#/${arrNewScope.join('/')}`);
                    _itemPick.options['scope-element'] = `#/${arrNewScope.join('/')}`;
                    _itemPick.clear();
                    _itemPick.selectedItem = { label: list.find(v => v.value === `#/${arrNewScope.join('/')}`)?.label || '', value: `#/${arrNewScope.join('/')}` };
                }
                else if (fullScope.includes(`${scope}/`)) {
                    _itemPick.setAttribute('full-scope-element', fullScope.replace(scope, newScope));
                    _itemPick.options['full-scope-element'] = fullScope.replace(scope, newScope);
                }
            }
            if (rulePicked) {
                rulePicked.setAttribute('scope-rule', newScope);
                rulePicked.options['scope-rule'] = newScope;
                rulePicked.items = ruleItems;
                rulePicked.selectedItem = { label: newLabel, value: newScope };
            }
            for (const _rulePicked of ruleChildPicked) {
                const childScope = _rulePicked.getAttribute('scope-rule') || '';
                const newChildScope = childScope.replace(scope, newScope);
                const currentLabel = _rulePicked.selectedItem.label || '';
                const _newLb = currentLabel.replace(label, newLabel);
                _rulePicked.setAttribute('scope-rule', newChildScope);
                _rulePicked.options['scope-rule'] = newChildScope;
                _rulePicked.items = ruleItems;
                _rulePicked.selectedItem = { label: _newLb, value: newChildScope };
            }
            await this.updateActionsItems();
            await this.updateActionsRules();
            this.updateJsonUISchema();
        }
        async updateUISchemaByType(fields, isOption) {
            const _fields = this.getScopeByFields(fields);
            const regexUUID = new RegExp(this.uuid, 'g');
            const scope = `#/${_fields.join('/').replace(regexUUID, 'properties')}`;
            if (isOption) {
                const picked = this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`);
                if (picked) {
                    const parentPicked = picked.closest('[item-element]');
                    parentPicked?.resetOptions();
                }
            }
            const rulePicked = this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`);
            if (rulePicked) {
                const ruleItems = await this.getUISchemaMap(this.schema, { _isRule: true });
                const currentItem = ruleItems.find(v => v.value === scope);
                if (currentItem) {
                    rulePicked.selectedItem = currentItem;
                    const parentPicked = rulePicked.closest('[item-element]');
                    parentPicked?.initRule();
                }
            }
            this.updateActionsItems();
            this.updateActionsRules();
            this.updateJsonUISchema();
        }
        deleteUISchema(fields, onlyChild) {
            const _fields = this.getScopeByFields(fields);
            const regexUUID = new RegExp(this.uuid, 'g');
            const scope = `#/${_fields.join('/').replace(regexUUID, 'properties')}`;
            const picked = this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`);
            if (!onlyChild) {
                if (picked) {
                    picked.closest('[item-element]')?.deleteElement();
                }
                else {
                    const fullPicked = this.pnlUISchemaBuilder.querySelector(`[full-scope-element='${scope}']`);
                    fullPicked?.closest('[item-element]')?.deleteElement();
                }
            }
            else {
                picked?.closest('[item-element]')?.resetOptions();
            }
            const childPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-element*='${scope}/']`);
            const childPickedArr = this.pnlUISchemaBuilder.querySelectorAll(`[cbb-property-array='${scope}']`);
            for (const _picked of childPicked) {
                _picked.closest('[item-element]')?.deleteElement();
            }
            for (const _picked of childPickedArr) {
                _picked.closest('[item-element]')?.deleteElement();
            }
            const rulePicked = this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`);
            if (rulePicked) {
                rulePicked.closest('[item-element]')?.resetRule();
            }
            const ruleChildPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-rule*='${scope}/']`);
            for (const _rulePicked of ruleChildPicked) {
                _rulePicked.closest('[item-element]')?.resetRule();
            }
            this.updateActionsRules();
        }
        createUISchema(parent, parentType, isChildren, scopeArr) {
            const pnlUISchema = new layout_1.Panel();
            pnlUISchema.setAttribute('item-element', 'true');
            parent.append(pnlUISchema);
            const pnlUIElements = new layout_1.Panel(undefined, {
                padding: { top: 10, bottom: 10, left: 10, right: 10 }
            });
            const btnAddElement = new button_1.Button(undefined, {
                caption: 'Add Element',
                padding: { top: 6, bottom: 6, left: 16, right: 16 },
                margin: { top: 8 },
                maxWidth: 150,
                visible: !isChildren
            });
            // btnAddElement.enabled = !!this.getUISchemaMap(this.schema).length;
            btnAddElement.prepend(new icon_1.Icon(undefined, {
                name: 'plus',
                width: '1em',
                height: '1em',
                fill: Theme.colors.primary.contrastText,
            }));
            btnAddElement.onClick = () => {
                this.createUISchema(pnlUIElements, currentLayout, true);
                this.updateJsonUISchema();
            };
            btnAddElement.setAttribute('add-element', 'true');
            let currentLayout = 'VerticalLayout';
            // Rule
            let useRule = false;
            let effect = 'HIDE';
            let ruleScope = undefined;
            let cbbRuleScope;
            let ruleNegative = false;
            let ruleConst = undefined;
            let ruleMinimum = undefined;
            let ruleMaximum = undefined;
            let listEnum = [];
            const listEffect = [
                { label: 'HIDE', value: 'HIDE' },
                { label: 'SHOW', value: 'SHOW' },
                { label: 'DISABLE', value: 'DISABLE' },
                { label: 'ENABLE', value: 'ENABLE' }
            ];
            const pnlRule = new layout_1.Panel(undefined, {
                margin: { top: 10 },
                visible: false
            });
            if (isChildren) {
                const ckbRule = new checkbox_1.Checkbox(pnlRule, {
                    caption: 'Rule',
                    checked: false
                });
                ckbRule.onChanged = () => {
                    const checked = ckbRule.checked;
                    if (checked === useRule)
                        return;
                    if (checked) {
                        createRuleSchemaUI();
                    }
                    else {
                        deleteRuleSchemaUI();
                    }
                    pnlRuleForm.visible = checked;
                    useRule = checked;
                    this.updateJsonUISchema();
                };
                const pnlRuleForm = new layout_1.Panel(pnlRule, { visible: false });
                pnlRuleForm.classList.add('cs-ui--schema');
                const createRuleSchemaUI = async () => {
                    pnlRuleForm.clearInnerHTML();
                    const pnlFormGroup = new layout_1.Panel(pnlRuleForm, {
                        width: 'calc(50% - 5px)'
                    });
                    pnlFormGroup.classList.add('form-group');
                    new label_1.Label(pnlFormGroup, { caption: 'Effect' });
                    const pnlFormControl = new layout_1.Panel(pnlFormGroup);
                    pnlFormControl.classList.add('form-control');
                    const cbbEffect = new combo_box_1.ComboBox(pnlFormControl, {
                        items: listEffect,
                        selectedItem: listEffect[0],
                        icon: { name: 'caret-down', width: '16px', height: '16px' }
                    });
                    cbbEffect.onChanged = () => {
                        effect = cbbEffect.selectedItem.value;
                        this.updateJsonUISchema();
                    };
                    cbbRuleScope = new combo_box_1.ComboBox(undefined, {
                        items: await this.getUISchemaMap(this.schema, { _isRule: true }),
                        icon: { name: 'caret-down', width: '16px', height: '16px' }
                    });
                    const initRule = (ignoreValue) => {
                        const selectedItem = cbbRuleScope?.selectedItem;
                        if (!ignoreValue && ruleScope === selectedItem.value)
                            return;
                        createRuleFormSchemaUI(selectedItem);
                        ruleScope = selectedItem.value;
                        iconRemoveRuleScope.visible = true;
                        cbbRuleScope.setAttribute('scope-rule', ruleScope);
                        cbbRuleScope.options['scope-rule'] = ruleScope;
                        this.updateJsonUISchema();
                        this.updateActionsRules();
                    };
                    pnlUISchema.initRule = () => initRule(true);
                    cbbRuleScope.setAttribute('cbb-rule', 'true');
                    cbbRuleScope.onChanged = () => initRule();
                    const iconRemoveRuleScope = new icon_1.Icon(undefined, {
                        name: 'times-circle',
                        visible: false,
                        width: 12,
                        height: 12,
                        fill: Theme.colors.secondary.main,
                        tooltip: {
                            content: 'Remove this property',
                            trigger: 'hover',
                        }
                    });
                    iconRemoveRuleScope.onClick = () => {
                        iconRemoveRuleScope.visible = false;
                        resetRule();
                        this.updateJsonUISchema();
                    };
                    const pnlRuleFormGroup = new layout_1.Panel(pnlRuleForm, {
                        width: 'calc(50% - 5px)'
                    });
                    pnlRuleFormGroup.classList.add('form-group');
                    new label_1.Label(pnlRuleFormGroup, { caption: 'Scope' });
                    const pnlRuleFormControl = new layout_1.Panel(pnlRuleFormGroup);
                    pnlRuleFormControl.classList.add('form-control');
                    const hStackRule = new layout_1.HStack(pnlRuleFormControl, {
                        gap: 4,
                        verticalAlignment: 'center'
                    });
                    hStackRule.appendChild(cbbRuleScope);
                    hStackRule.appendChild(iconRemoveRuleScope);
                    const pnlRuleSchema = new layout_1.Panel(pnlRuleForm, { width: '100%' });
                    pnlRuleSchema.classList.add('cs-ui--schema');
                    const createRuleFormSchemaUI = (item) => {
                        pnlRuleSchema.clearInnerHTML();
                        const inputType = item.type === 'string' ? 'text' : 'number';
                        let controlConst = [];
                        let iconRemoveConst = [];
                        ruleConst = undefined;
                        ruleNegative = false;
                        ruleScope = undefined;
                        ruleMinimum = undefined;
                        ruleMaximum = undefined;
                        listEnum = [];
                        if (item.type === 'boolean') {
                            controlConst = new combo_box_1.ComboBox(undefined, {
                                items: [
                                    { label: 'true', value: 'true' },
                                    { label: 'false', value: 'false' }
                                ],
                                icon: { name: 'caret-down', width: '16px', height: '16px' }
                            });
                            controlConst.onChanged = () => {
                                iconRemoveConst.visible = true;
                                ruleConst = controlConst.selectedItem.value === 'true' ? true : false;
                                this.updateJsonUISchema();
                            };
                            iconRemoveConst = new icon_1.Icon(undefined, {
                                name: 'times-circle',
                                visible: false,
                                width: 12,
                                height: 12,
                                fill: Theme.colors.secondary.main,
                                tooltip: {
                                    content: 'Remove this property',
                                    trigger: 'hover',
                                }
                            });
                            iconRemoveConst.onClick = () => {
                                controlConst.clear();
                                ruleConst = undefined;
                                iconRemoveConst.visible = false;
                                this.updateJsonUISchema();
                            };
                        }
                        const pnlFormGroup = new layout_1.Panel(pnlRuleSchema, { width: 'calc(50% - 5px)' });
                        pnlFormGroup.classList.add('form-group');
                        new label_1.Label(pnlFormGroup, { caption: 'Const' });
                        const pnlFormControl = new layout_1.Panel(pnlFormGroup);
                        pnlFormControl.classList.add('form-control');
                        if (item.type === 'boolean') {
                            const hStack = new layout_1.HStack(pnlFormControl, {
                                gap: 4,
                                verticalAlignment: 'center'
                            });
                            hStack.appendChild(controlConst);
                            hStack.appendChild(iconRemoveConst);
                        }
                        else {
                            const inputConst = new input_1.Input(pnlFormControl, { inputType });
                            inputConst.onChanged = () => {
                                const val = inputConst.value;
                                if (inputType === 'text') {
                                    ruleConst = val;
                                }
                                else {
                                    ruleConst = (val === '' || isNaN(val)) ? '' : Number(val);
                                }
                                this.updateJsonUISchema();
                            };
                        }
                        if (['number', 'integer'].includes(item.type)) {
                            const pnlFormGroupMin = new layout_1.Panel(pnlRuleSchema, { width: 'calc(50% - 5px)' });
                            new label_1.Label(pnlFormGroupMin, { caption: 'Minimum' });
                            const pnlFormControlMin = new layout_1.Panel(pnlFormGroupMin);
                            pnlFormControlMin.classList.add('form-control');
                            const inputMin = new input_1.Input(pnlFormControlMin, { inputType });
                            inputMin.onChanged = () => {
                                ruleMinimum = inputMin.value;
                                this.updateJsonUISchema();
                            };
                            const pnlFormGroupMax = new layout_1.Panel(pnlRuleSchema, { width: 'calc(50% - 5px)' });
                            new label_1.Label(pnlFormGroupMax, { caption: 'Exclusive Maximum' });
                            const pnlFormControlMax = new layout_1.Panel(pnlFormGroupMax);
                            pnlFormControlMax.classList.add('form-control');
                            const inputMax = new input_1.Input(pnlFormControlMax, { inputType });
                            inputMax.onChanged = () => {
                                ruleMaximum = inputMax.value;
                                this.updateJsonUISchema();
                            };
                        }
                        const pnlFormGroupNegative = new layout_1.Panel(pnlRuleSchema, { width: 'calc(50% - 5px)', display: 'flex' });
                        const pnlFormControlNegative = new layout_1.Panel(pnlFormGroupNegative, { margin: { top: 'auto' } });
                        pnlFormControlNegative.classList.add('form-control');
                        const ckbNegative = new checkbox_1.Checkbox(pnlFormControlNegative, {
                            caption: 'Negative',
                            checked: false
                        });
                        ckbNegative.onChanged = () => {
                            ruleNegative = ckbNegative.checked;
                            this.updateJsonUISchema();
                        };
                        if (['string', 'number', 'integer'].includes(item.type)) {
                            const hStackEnum = new layout_1.HStack(undefined, {
                                gap: 8,
                                verticalAlignment: 'center',
                                wrap: 'wrap'
                            });
                            const btnAdd = new button_1.Button(undefined, {
                                caption: 'Add',
                                enabled: false,
                                padding: { top: 6, bottom: 6, left: 16, right: 16 },
                            });
                            const inputEnum = new input_1.Input(undefined, {
                                inputType: inputType,
                            });
                            inputEnum.classList.add('cs-width--input');
                            inputEnum.onChanged = () => {
                                const val = inputEnum.value;
                                if (item.type === 'string') {
                                    btnAdd.enabled = val && !listEnum.some(v => v.toString().toLowerCase() === val.toString().toLowerCase());
                                }
                                else {
                                    btnAdd.enabled = val !== '' && !isNaN(Number(val)) && !listEnum.some(v => v === Number(val));
                                }
                            };
                            btnAdd.onClick = () => {
                                const val = inputEnum.value;
                                if (((inputType === 'number' && !isNaN(val)) || inputType === 'text' && val) && !listEnum.some(v => v.toString().toLowerCase() === val.toString().toLowerCase())) {
                                    listEnum.push(inputType === 'number' ? Number(val) : val);
                                    inputEnum.value = '';
                                    btnAdd.enabled = false;
                                    const pnlEnum = new layout_1.Panel(hStackEnum, {
                                        position: 'relative',
                                        display: 'flex',
                                        padding: { top: 8, bottom: 8, left: 16, right: 16 },
                                        border: { radius: 8 },
                                        background: { color: Theme.action.selected }
                                    });
                                    const iconTimesEnum = new icon_1.Icon(pnlEnum, {
                                        name: 'times',
                                        width: 14,
                                        height: 14,
                                        fill: Theme.colors.secondary.main,
                                        position: 'absolute',
                                        right: 2,
                                        top: 2
                                    });
                                    iconTimesEnum.onClick = () => {
                                        const idx = listEnum.findIndex(v => v.toString().toLowerCase() === val.toString().toLowerCase());
                                        listEnum.splice(idx, 1);
                                        iconRemove.visible = !!listEnum.length;
                                        hStackEnum.removeChild(pnlEnum);
                                        this.updateJsonUISchema();
                                    };
                                    const lbVal = new label_1.Label(pnlEnum, {
                                        caption: val,
                                        font: { size: '12px' },
                                        minWidth: 20,
                                        padding: { top: 0, bottom: 0, left: 0, right: 0 }
                                    });
                                    lbVal.classList.add('cs-enum--value');
                                    iconRemove.visible = true;
                                    this.updateJsonUISchema();
                                }
                            };
                            let iconRemove = [];
                            iconRemove = new icon_1.Icon(undefined, {
                                name: 'times-circle',
                                visible: false,
                                width: 12,
                                height: 12,
                                position: 'absolute',
                                top: 5,
                                right: 5,
                                fill: Theme.colors.secondary.main,
                                tooltip: {
                                    content: 'Remove this property',
                                    trigger: 'hover',
                                }
                            });
                            iconRemove.onClick = () => {
                                hStackEnum.clearInnerHTML();
                                listEnum.splice(0, listEnum.length);
                                iconRemove.visible = false;
                                this.updateJsonUISchema();
                            };
                            const pnlFormGroupEnum = new layout_1.Panel(pnlRuleSchema, { width: 'calc(50% - 5px)' });
                            pnlFormGroupEnum.classList.add('form-group', 'cs-box--enum');
                            pnlFormGroupEnum.appendChild(iconRemove);
                            const lbEnum = new label_1.Label(pnlFormGroupEnum, { caption: 'Enum' });
                            lbEnum.classList.add('form-label');
                            const pnlFormControlEnum = new layout_1.Panel(pnlFormGroupEnum);
                            pnlFormControlEnum.classList.add('form-control');
                            pnlFormControlEnum.appendChild(hStackEnum);
                            const hStackInputEnum = new layout_1.HStack(pnlFormControlEnum, {
                                gap: 8,
                                wrap: 'wrap',
                                verticalAlignment: 'center'
                            });
                            hStackInputEnum.appendChild(inputEnum);
                            hStackInputEnum.appendChild(btnAdd);
                        }
                    };
                };
                const deleteRuleSchemaUI = () => {
                    ruleConst = undefined;
                    effect = 'HIDE';
                    ruleScope = undefined;
                    ruleNegative = false;
                    ruleMinimum = undefined;
                    ruleMaximum = undefined;
                    listEnum = [];
                    pnlRuleForm.clearInnerHTML();
                };
                const resetRule = () => {
                    deleteRuleSchemaUI();
                    createRuleSchemaUI();
                    this.updateActionsRules();
                    this.updateJsonUISchema();
                };
                pnlUISchema.resetRule = () => resetRule();
            }
            const getRule = () => {
                let condition = {
                    scope: ruleScope ? cbbRuleScope.selectedItem?.value : '',
                    schema: {}
                };
                let _schema = {};
                if (ruleConst !== undefined && ruleConst !== '') {
                    _schema.const = ruleConst;
                }
                if (ruleMinimum !== '' && !isNaN(Number(ruleMinimum))) {
                    _schema.minimum = Number(ruleMinimum);
                }
                if (ruleMaximum !== '' && !isNaN(Number(ruleMaximum))) {
                    _schema.exclusiveMaximum = Number(ruleMaximum);
                }
                if (listEnum.length) {
                    _schema.enum = listEnum;
                }
                if (ruleNegative) {
                    condition.schema.not = _schema;
                }
                else {
                    condition.schema = _schema;
                }
                return {
                    effect,
                    condition
                };
            };
            // Options - array only
            let useOptions = false;
            let isItemsArray = false;
            let optionReadonly = false;
            let optionRadio = false;
            let currentOptions = 'DEFAULT';
            let currentOptionsLayout = 'VerticalLayout';
            let formOptionsDetail;
            const pnlArrayOption = new layout_1.Panel(undefined, {
                margin: { top: 10 },
                visible: false
            });
            const createOptionsUI = (_scopeArr, _isItemsArray, _showRadio) => {
                isItemsArray = _isItemsArray;
                useOptions = false;
                optionReadonly = false;
                optionRadio = false;
                const pnlOptions = new layout_1.Panel();
                pnlArrayOption.clearInnerHTML();
                pnlArrayOption.appendChild(pnlOptions);
                currentOptions = 'DEFAULT';
                const checkboxOptions = new checkbox_1.Checkbox(pnlOptions, {
                    caption: 'Options',
                    checked: false
                });
                checkboxOptions.onChanged = () => {
                    if (checkboxOptions.checked) {
                        pnlOptions.appendChild(pnlFormOptions);
                        useOptions = true;
                    }
                    else {
                        pnlOptions.removeChild(pnlFormOptions);
                        useOptions = false;
                    }
                    this.updateJsonUISchema();
                };
                const pnlFormOptions = new layout_1.Panel();
                pnlFormOptions.classList.add('cs-ui--schema');
                if (!isItemsArray) {
                    const pnlFormGroupReadOnly = new layout_1.Panel(pnlFormOptions, { margin: { top: 5 } });
                    pnlFormOptions.classList.add('form-group');
                    const pnlFormControlReadOnly = new layout_1.Panel(pnlFormGroupReadOnly);
                    pnlFormControlReadOnly.classList.add('form-control');
                    const ckbReadOnly = new checkbox_1.Checkbox(pnlFormControlReadOnly, {
                        caption: 'Read Only',
                        checked: false
                    });
                    ckbReadOnly.onChanged = () => {
                        optionReadonly = ckbReadOnly.checked;
                        this.updateJsonUISchema();
                    };
                    if (_showRadio) {
                        const pnlFormGroupRadio = new layout_1.Panel(pnlFormOptions, { margin: { top: 5 } });
                        pnlFormOptions.classList.add('form-group');
                        const pnlFormControlRadio = new layout_1.Panel(pnlFormGroupRadio);
                        pnlFormControlRadio.classList.add('form-control');
                        const ckbRadio = new checkbox_1.Checkbox(pnlFormControlRadio, {
                            caption: 'Radio',
                            checked: false
                        });
                        ckbRadio.onChanged = () => {
                            optionRadio = ckbRadio.checked;
                            this.updateJsonUISchema();
                        };
                    }
                    return;
                }
                const listOptions = [
                    { label: 'DEFAULT', value: 'DEFAULT' },
                    { label: 'GENERATED', value: 'GENERATED' },
                    { label: 'REGISTERED', value: 'REGISTERED' },
                    { label: 'INLINED', value: 'INLINED' }
                ];
                const pnlSelectOpt = new layout_1.Panel(pnlFormOptions, { width: '100%' });
                const pnlFormGroupOpt = new layout_1.Panel(pnlSelectOpt);
                pnlFormGroupOpt.classList.add('form-group');
                const lbOpt = new label_1.Label(pnlFormGroupOpt, { caption: 'Options' });
                lbOpt.classList.add('form-label');
                const pnlFormControlOpt = new layout_1.Panel(pnlFormGroupOpt);
                pnlFormControlOpt.classList.add('form-control');
                const cbbOpt = new combo_box_1.ComboBox(pnlFormControlOpt, {
                    items: listOptions,
                    selectedItem: listOptions[0],
                    icon: { name: 'caret-down', width: '16px', height: '16px' }
                });
                cbbOpt.onChanged = () => {
                    const value = cbbOpt.selectedItem.value;
                    if (value === currentOptions)
                        return;
                    if (value === 'INLINED') {
                        pnlSelectOpt.width = 'calc(50% - 5px)';
                        pnlFormOptions.appendChild(pnlType);
                        pnlFormOptions.appendChild(pnlDetail);
                    }
                    else if (currentOptions === 'INLINED') {
                        pnlSelectOpt.width = '100%';
                        pnlFormDetail.clearInnerHTML();
                        pnlFormOptions.removeChild(pnlType);
                        pnlFormOptions.removeChild(pnlDetail);
                    }
                    currentOptions = value;
                    this.updateJsonUISchema();
                };
                const listItems = dataUITypes.filter(v => ['VerticalLayout', 'HorizontalLayout'].includes(v.value));
                currentOptionsLayout = 'VerticalLayout';
                const pnlType = new layout_1.Panel(undefined, { width: 'calc(50% - 5px)' });
                const pnlFormGroupType = new layout_1.Panel(pnlType);
                pnlFormGroupType.classList.add('form-group');
                const lbType = new label_1.Label(pnlFormGroupType, { caption: 'Type' });
                lbType.classList.add('form-label');
                const pnlFormControlType = new layout_1.Panel(pnlFormGroupType);
                pnlFormControlType.classList.add('form-control');
                const cbbType = new combo_box_1.ComboBox(pnlFormControlType, {
                    items: listItems,
                    selectedItem: listItems[0],
                    icon: { name: 'caret-down', width: '16px', height: '16px' }
                });
                cbbType.onChanged = () => {
                    const value = cbbType.selectedItem.value;
                    if (value === currentOptionsLayout)
                        return;
                    currentOptionsLayout = value;
                    this.updateJsonUISchema();
                };
                const btnAddElement = new button_1.Button(undefined, {
                    caption: 'Add Element',
                    padding: { top: 6, bottom: 6, left: 16, right: 16 },
                    margin: { top: 8 },
                    maxWidth: 150
                });
                // btnAddElement.enabled = !!this.getUISchemaMap(this.schema).length;
                btnAddElement.prepend(new icon_1.Icon(undefined, {
                    name: 'plus',
                    width: '1em',
                    height: '1em',
                    fill: Theme.colors.primary.contrastText,
                }));
                const pnlFormDetail = new layout_1.Panel(undefined, {
                    padding: { top: 10, bottom: 10, left: 10, right: 10 }
                });
                formOptionsDetail = pnlFormDetail;
                btnAddElement.onClick = () => {
                    let scopeArr = _scopeArr;
                    if (scopeArr) {
                        scopeArr = pnlProperty.querySelector('[cbb-property]')?.selectedItem?.value || '';
                    }
                    this.createUISchema(pnlFormDetail, currentOptionsLayout, true, scopeArr);
                    this.updateJsonUISchema();
                };
                const pnlDetail = new layout_1.Panel(undefined, { width: '100%' });
                pnlDetail.appendChild(btnAddElement);
                pnlDetail.appendChild(pnlFormDetail);
            };
            const deleteOptionsUI = () => {
                useOptions = false;
                formOptionsDetail = null;
                pnlArrayOption.clearInnerHTML();
            };
            const getOptionsUI = () => {
                if (!useOptions)
                    return undefined;
                if (!isItemsArray) {
                    let options = {};
                    if (optionReadonly) {
                        options.readonly = optionReadonly;
                    }
                    if (optionRadio) {
                        options.format = 'radio';
                    }
                    return options;
                }
                if (currentOptions !== 'INLINED') {
                    return {
                        detail: currentOptions
                    };
                }
                let elements = [];
                const arrElm = formOptionsDetail?.childNodes || [];
                for (const subElm of arrElm) {
                    elements.push(subElm.getData());
                }
                return {
                    detail: {
                        type: currentOptionsLayout,
                        elements
                    }
                };
            };
            let typeOptions = [];
            if (isChildren) {
                if (parentType === 'Categorization') {
                    typeOptions = dataUITypes.filter(v => v.value === 'Category');
                    currentLayout = 'Category';
                }
                else {
                    typeOptions = dataUITypes.filter(v => v.value !== 'Categorization' && v.value !== 'Category');
                }
            }
            else {
                typeOptions = dataUITypes.filter(v => v.value !== 'Control' && v.value !== 'Category');
            }
            const pnlCbb = new layout_1.Panel(undefined, {
                width: currentLayout === 'Category' ? 'calc(50% - 5px)' : '100%',
                minWidth: 100
            });
            pnlCbb.classList.add('form-group');
            const lbType = new label_1.Label(pnlCbb, {
                caption: 'Type'
            });
            lbType.classList.add('form-label');
            const pnlCbbType = new layout_1.Panel(pnlCbb);
            pnlCbbType.classList.add('form-control');
            const cbbType = new combo_box_1.ComboBox(pnlCbbType, {
                items: typeOptions,
                selectedItem: typeOptions.find(v => v.value === currentLayout),
                icon: { name: 'caret-down', width: '16px', height: '16px' }
            });
            cbbType.onChanged = () => {
                const selectedItem = cbbType.selectedItem;
                const value = selectedItem.value;
                if (value === currentLayout)
                    return;
                if (value === 'Control') {
                    pnlUIElements.clearInnerHTML();
                    if (!pnlLabelWrapper.hasChildNodes()) {
                        pnlLabelWrapper.append(pnlLabel);
                    }
                    pnlLabelWrapper.visible = true;
                    inputLabel.value = '';
                    initInputProperty();
                    pnlProperty.visible = true;
                    pnlProperty.width = 'calc(33.33% - 7px)';
                    pnlCbb.width = 'calc(33.33% - 7px)';
                    pnlLabelWrapper.width = 'calc(33.33% - 7px)';
                    btnAddElement.visible = false;
                    btnAddElement.enabled = false;
                }
                else {
                    if (!isChildren && (currentLayout === 'Categorization' || value === 'Categorization')) {
                        pnlUIElements.clearInnerHTML();
                    }
                    if (['Group', 'Category'].includes(value)) {
                        if (!pnlLabelWrapper.hasChildNodes()) {
                            pnlLabelWrapper.append(pnlLabel);
                        }
                        if (!['Group', 'Category'].includes(currentLayout)) {
                            inputLabel.value = value;
                        }
                        if (!inputLabel.value) {
                            inputLabel.value = value;
                        }
                        pnlLabelWrapper.visible = true;
                        pnlLabelWrapper.width = 'calc(50% - 5px)';
                        pnlCbb.width = 'calc(50% - 5px)';
                    }
                    else {
                        pnlLabelWrapper.clearInnerHTML();
                        pnlLabelWrapper.visible = false;
                        pnlCbb.width = '100%';
                    }
                    pnlProperty.clearInnerHTML();
                    pnlProperty.visible = false;
                    // const hasProperties = !!this.getUISchemaMap(this.schema).length;
                    const hasProperties = true;
                    btnAddElement.visible = (hasProperties && isExpanded) || !isChildren;
                    btnAddElement.enabled = hasProperties;
                    if (currentLayout === 'Control') {
                        this.updateActionsItems();
                    }
                }
                currentLayout = value;
                pnlArrayOption.clearInnerHTML();
                this.updateJsonUISchema();
            };
            const pnlLabelWrapper = new layout_1.Panel(undefined, {
                width: 'calc(50% - 5px)',
                minWidth: 100
            });
            pnlLabelWrapper.visible = currentLayout === 'Category';
            const pnlLabel = new layout_1.Panel();
            pnlLabel.classList.add('form-group');
            const lbLabel = new label_1.Label(pnlLabel, {
                caption: 'Label'
            });
            lbLabel.classList.add('form-label');
            const inputLabel = new input_1.Input(undefined, { inputType: 'text' });
            inputLabel.onChanged = () => {
                this.updateJsonUISchema();
            };
            const pnlInputLabel = new layout_1.Panel(pnlLabel);
            pnlInputLabel.classList.add('form-control');
            pnlInputLabel.appendChild(inputLabel);
            if (currentLayout === 'Category') {
                pnlLabelWrapper.append(pnlLabel);
            }
            let currentProperty = '';
            const pnlProperty = new layout_1.Panel(undefined, {
                width: 'calc(50% - 5px)',
                minWidth: 100
            });
            pnlProperty.visible = false;
            pnlProperty.classList.add('form-group');
            const initInputProperty = async () => {
                currentProperty = '';
                pnlProperty.clearInnerHTML();
                const lbProperty = new label_1.Label(pnlProperty, {
                    caption: 'Property'
                });
                lbProperty.classList.add('form-label');
                let scopeArrInput = scopeArr;
                if (scopeArrInput) {
                    scopeArrInput = parent.closest('[item-element]')?.querySelector('[cbb-property]')?.selectedItem?.value || '';
                }
                const cbbProperty = new combo_box_1.ComboBox(undefined, {
                    items: await this.getUISchemaMap(this.schema, { _scopeArr: scopeArrInput }),
                    icon: { name: 'caret-down', width: '16px', height: '16px' }
                });
                cbbProperty.setAttribute('cbb-property', 'true');
                if (scopeArrInput) {
                    cbbProperty.setAttribute('cbb-property-array', scopeArrInput);
                }
                cbbProperty.onChanged = () => {
                    const selectedItem = cbbProperty.selectedItem;
                    const value = selectedItem.value;
                    if (currentProperty === value)
                        return;
                    iconClear.visible = true;
                    deleteOptionsUI();
                    createOptionsUI(value, !!(selectedItem.type === 'array' && selectedItem.hasItems), !!(selectedItem.isEnum || selectedItem.isOneOf));
                    cbbProperty.setAttribute('scope-element', value);
                    cbbProperty.options['scope-element'] = value;
                    if (scopeArr) {
                        const parentScope = parent.closest('[item-element]')?.querySelector('[cbb-property]')?.selectedItem?.value || '';
                        cbbProperty.setAttribute('full-scope-element', `${parentScope}${value.substring(1, value.length)}`);
                        cbbProperty.options['full-scope-element'] = `${parentScope}${value.substring(1, value.length)}`;
                    }
                    currentProperty = value;
                    const childPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-element*='${value}/']`);
                    for (const _picked of childPicked) {
                        _picked.closest('[item-element]')?.initInputProperty();
                    }
                    this.updateActionsItems();
                    this.updateJsonUISchema();
                };
                const iconClear = new icon_1.Icon(undefined, {
                    name: 'times-circle',
                    width: 12,
                    height: 12,
                    fill: Theme.colors.secondary.main,
                    visible: false
                });
                iconClear.onClick = () => {
                    iconClear.visible = false;
                    deleteOptionsUI();
                    initInputProperty();
                    this.updateJsonUISchema();
                };
                const resetOptions = async () => {
                    const selectedItem = cbbProperty.selectedItem;
                    const value = selectedItem.value;
                    const newSelectedItem = (await this.getUISchemaMap(this.schema, { _scopeArr: scopeArrInput, _getScope: value }))[0];
                    if (newSelectedItem) {
                        cbbProperty.selectedItem = newSelectedItem;
                        const { type, hasItems, isOneOf, isEnum } = newSelectedItem;
                        deleteOptionsUI();
                        createOptionsUI(value, !!(type === 'array' && hasItems), !!(isEnum || isOneOf));
                    }
                    this.updateActionsRules();
                    this.updateJsonUISchema();
                };
                pnlUISchema.resetOptions = () => resetOptions();
                const hStackProperty = new layout_1.HStack(pnlProperty, {
                    gap: 4,
                    verticalAlignment: 'center'
                });
                hStackProperty.classList.add('form-control');
                hStackProperty.appendChild(cbbProperty);
                hStackProperty.appendChild(iconClear);
            };
            const getData = () => {
                let data = {
                    type: currentLayout
                };
                if (currentLayout === 'Control') {
                    const _scp = pnlProperty.querySelector('[cbb-property]')?.selectedItem?.value || '';
                    if (!_scp)
                        return null;
                    data.scope = pnlProperty.querySelector('[cbb-property]')?.selectedItem?.value || '';
                    if (inputLabel.value) {
                        data.label = inputLabel.value;
                    }
                    if (useOptions) {
                        const options = getOptionsUI();
                        if (options && Object.keys(options).length) {
                            data.options = options;
                        }
                    }
                }
                else {
                    if (['Group', 'Category'].includes(currentLayout)) {
                        data.label = inputLabel.value || currentLayout;
                    }
                    let elements = [];
                    const arrElm = pnlUISchema.querySelectorAll(":scope > i-panel > i-panel > [item-element]");
                    for (const subElm of arrElm) {
                        const data = subElm.getData();
                        if (data !== null) {
                            elements.push(data);
                        }
                    }
                    data.elements = elements;
                }
                if (useRule) {
                    data.rule = getRule();
                }
                return data;
            };
            const deleteElement = () => {
                parent.removeChild(pnlUISchema);
                this.updateActionsItems();
                this.updateActionsRules();
                this.updateJsonUISchema();
            };
            pnlUISchema.getData = () => getData();
            pnlUISchema.deleteElement = () => deleteElement();
            pnlUISchema.initInputProperty = () => initInputProperty();
            pnlUISchema.deleteOptionsUI = () => deleteOptionsUI();
            let btnDelete = [];
            let btnExpand = [];
            let iconExpand = [];
            let isExpanded = false;
            const onExpand = () => {
                isExpanded = !isExpanded;
                pnlArrayOption.visible = isExpanded;
                pnlRule.visible = isExpanded;
                btnAddElement.visible = currentLayout !== 'Control' && isExpanded;
                btnExpand.caption = isExpanded ? 'Hide' : 'Show';
                iconExpand.name = isExpanded ? 'angle-up' : 'angle-down';
            };
            if (isChildren) {
                btnDelete = new button_1.Button(undefined, {
                    caption: 'Delete',
                    background: { color: `${Theme.colors.secondary.main} !important` },
                    display: 'flex',
                    width: '100%',
                    height: 28,
                    padding: { top: 6, bottom: 6, left: 12, right: 12 },
                });
                btnDelete.prepend(new icon_1.Icon(undefined, {
                    name: 'trash',
                    width: '1em',
                    height: '1em',
                    fill: Theme.colors.primary.contrastText,
                }));
                btnDelete.onClick = () => { deleteElement(); };
                btnExpand = new button_1.Button(undefined, {
                    caption: 'Show',
                    width: '100%',
                    padding: { top: 6, bottom: 6, left: 12, right: 12 }
                });
                iconExpand = new icon_1.Icon(undefined, {
                    name: 'angle-down',
                    width: '1.125em',
                    height: '1.125em',
                    fill: Theme.colors.primary.contrastText,
                });
                btnExpand.prepend(iconExpand);
                btnExpand.onClick = onExpand;
            }
            const pnlDataSchema = new layout_1.Panel(pnlUISchema, {
                border: { width: 1, style: 'solid', color: '#DADDE1', radius: '1em' },
                padding: { top: 10, bottom: 10, left: 10, right: 10 },
                margin: { top: isChildren ? 10 : 0, bottom: isChildren ? 10 : 0 }
            });
            pnlDataSchema.classList.add('data-schema');
            const vStack = new layout_1.VStack(pnlDataSchema, {
                gap: 10,
                width: '100%',
                verticalAlignment: 'center'
            });
            const hStack = new layout_1.HStack(vStack, {
                gap: 10,
                verticalAlignment: 'center'
            });
            const vStackItem = new layout_1.VStack(hStack, {
                gap: 10,
                width: isChildren ? 'calc(100% - 120px)' : '100%',
                verticalAlignment: 'center'
            });
            const pnlItem = new layout_1.Panel(vStackItem);
            pnlItem.classList.add('cs-ui--schema');
            pnlItem.appendChild(pnlCbb);
            if (isChildren) {
                pnlItem.appendChild(pnlProperty);
                const hStackButtons = new layout_1.HStack(hStack, {
                    gap: 10,
                    wrap: 'wrap',
                    width: 100
                });
                hStackButtons.appendChild(btnDelete);
                hStackButtons.appendChild(btnExpand);
            }
            pnlItem.appendChild(pnlLabelWrapper);
            pnlDataSchema.appendChild(pnlRule);
            pnlDataSchema.appendChild(pnlArrayOption);
            pnlDataSchema.appendChild(btnAddElement);
            pnlDataSchema.appendChild(pnlUIElements);
            return pnlUISchema;
        }
        initUI() {
            const gridLayout = new layout_1.GridLayout(this, {
                position: 'relative',
                width: '100%',
                height: '100%',
                templateColumns: ['5.5fr', '4.5fr'],
                gap: { column: 10, row: 10 }
            });
            this.pnlUISchemaBuilder = new layout_1.Panel(gridLayout, {
                height: '100%',
                overflow: 'auto'
            });
            this.pnlUISchemaBuilder.classList.add('cs-webkit--scrollbar');
            const pnlJsonUI = new layout_1.Panel(gridLayout, { height: '100%' });
            this.txtUISchema = new input_1.Input(pnlJsonUI, {
                inputType: 'textarea',
                rows: 10,
                readOnly: true,
                width: '100%'
            });
            this.txtUISchema.classList.add('cs-json--text');
        }
    };
    SchemaDesignerUI = __decorate([
        (0, base_1.customElements)('i-schema-designer-ui')
    ], SchemaDesignerUI);
    exports.SchemaDesignerUI = SchemaDesignerUI;
});
define("@ijstech/schema-designer/style/schema-designer.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    const scrollBar = {
        '&::-webkit-scrollbar-track': {
            borderRadius: '12px',
            border: '1px solid transparent',
            background: Theme.action.hover
        },
        '&::-webkit-scrollbar': {
            width: '8px',
            backgroundColor: 'unset'
        },
        '&::-webkit-scrollbar-thumb': {
            borderRadius: '12px',
            background: Theme.action.active
        }
    };
    Styles.cssRule('i-schema-designer', {
        $nest: {
            'i-label': {
                padding: '5px 0'
            },
            'i-tabs': {
                $nest: {
                    '.cs-webkit--scrollbar': {
                        $nest: scrollBar
                    }
                }
            },
            'i-input': {
                height: '30px !important',
                width: 'calc(100% - 15px) !important',
                $nest: {
                    'input[type="color"]': {
                        width: '60px !important'
                    },
                    'input': {
                        height: '30px !important',
                        width: '100% !important',
                        border: 0,
                        borderBottom: `0.5px solid ${Theme.divider}`,
                        background: 'transparent'
                    },
                    'textarea': {
                        height: '100% !important',
                        border: `0.5px solid ${Theme.divider}`,
                        borderRadius: '1em',
                        background: 'transparent',
                        $nest: scrollBar
                    },
                    '&.cs-json--text': {
                        height: '100% !important'
                    }
                }
            },
            'i-combo-box': {
                height: '30px !important',
                width: 'calc(100% - 15px)',
                $nest: {
                    'input': {
                        background: 'transparent !important',
                        height: '30px !important',
                        border: '0 !important',
                        borderBottom: `0.5px solid ${Theme.divider} !important`
                    },
                    '.selection': {
                        background: 'transparent',
                        padding: 0,
                        border: 0
                    },
                    'span.icon-btn': {
                        border: '0',
                        borderBottom: `0.5px solid ${Theme.divider}`,
                        borderRadius: '0',
                        height: '30px !important',
                        width: '32px !important',
                        padding: '3px',
                        $nest: {
                            'i-icon': {
                                padding: '5px',
                                height: '100% !important',
                                width: '100% !important'
                            }
                        }
                    }
                }
            },
            'i-grid-layout': {
                alignItems: 'center'
            },
            'i-icon': {
                cursor: 'pointer',
                $nest: {
                    '&.disabled': {
                        cursor: 'default'
                    }
                }
            },
            'i-button': {
                background: Theme.colors.primary.main,
                color: Theme.colors.primary.contrastText
            },
            '.cs-wrapper--header': {
                padding: '5px 10px',
                borderRadius: 10
            },
            '.cs-width--input': {
                width: 'calc(100% - 65px) !important',
                minWidth: 100
            },
            '.cs-prefix--items': {
                $nest: {
                    '.cs-box--shadow': {
                        boxShadow: Theme.shadows[2]
                    }
                }
            },
            '.cs-box--enum': {
                boxShadow: Theme.shadows[2],
                padding: '8px 16px',
                borderRadius: 8,
                minWidth: 100,
                $nest: {
                    '.cs-width--input': {
                        width: 'calc(100% - 70px) !important'
                    }
                }
            },
            '.cs-enum--value': {
                textAlign: 'center',
                wordBreak: 'break-word'
            },
            '.cs-ui--schema': {
                display: 'flex',
                flexWrap: 'wrap',
                gap: 10,
                $nest: {
                    '&> i-panel': {
                        minWidth: 150
                    }
                }
            },
            'i-panel.invalid': {
                $nest: {
                    'i-label': {
                        color: 'red'
                    }
                }
            }
        }
    });
});
define("@ijstech/schema-designer/schemaDesigner.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/tab", "@ijstech/label", "@ijstech/input", "@ijstech/combo-box", "@ijstech/checkbox", "@ijstech/button", "@ijstech/icon", "@ijstech/schema-designer/uiSchema.ts", "@ijstech/base", "@ijstech/style", "@ijstech/schema-designer/style/schema-designer.css.ts"], function (require, exports, base_2, layout_2, tab_1, label_2, input_2, combo_box_2, checkbox_2, button_2, icon_2, uiSchema_1, base_3, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaDesigner = void 0;
    const Theme = Styles.Theme.ThemeVars;
    const dataTypes = [
        { label: 'string', value: 'string' },
        { label: 'number', value: 'number' },
        { label: 'integer', value: 'integer' },
        { label: 'boolean', value: 'boolean' },
        { label: 'object', value: 'object' },
        { label: 'array', value: 'array' }
    ];
    const formatTypes = [
        { label: 'text', value: 'text' },
        { label: 'date', value: 'date' },
        { label: 'time', value: 'time' },
        { label: 'date-time', value: 'date-time' },
        { label: 'color', value: 'color' },
        { label: 'wallet-address', value: 'wallet-address' },
        { label: 'cid', value: 'cid' },
        { label: 'cid-v0', value: 'cid-v0' },
        { label: 'cid-v1', value: 'cid-v1' },
        { label: 'uuid', value: 'uuid' }
    ];
    const objectSchema = [
        { field: 'title', type: 'string' },
        { field: 'description', type: 'string' },
        { field: 'const', type: 'string' },
        { field: 'default', type: 'string' },
        { field: 'minProperties', type: 'number' },
        { field: 'maxProperties', type: 'number' },
        { field: 'additionalProperties', type: 'boolean' },
        { field: 'deprecated', type: 'boolean' },
        { field: 'readOnly', type: 'boolean' },
        { field: 'writeOnly', type: 'boolean' }
    ];
    const arraySchema = [
        { field: 'title', type: 'string' },
        { field: 'const', type: 'string' },
        { field: 'default', type: 'string' },
        { field: 'minItems', type: 'number' },
        { field: 'maxItems', type: 'number' },
        { field: 'uniqueItems', type: 'boolean' },
        { field: 'deprecated', type: 'boolean' },
        { field: 'readOnly', type: 'boolean' },
        { field: 'writeOnly', type: 'boolean' }
    ];
    const stringSchema = [
        { field: 'pattern', type: 'string' },
        { field: 'format', type: 'string', options: formatTypes },
        { field: 'title', type: 'string' },
        { field: 'const', type: 'string' },
        { field: 'default', type: 'string' },
        { field: 'minLength', type: 'number' },
        { field: 'maxLength', type: 'number' },
        { field: 'deprecated', type: 'boolean' },
        { field: 'readOnly', type: 'boolean' },
        { field: 'writeOnly', type: 'boolean' }
    ];
    const numberSchema = [
        { field: 'title', type: 'string' },
        { field: 'const', type: 'number' },
        { field: 'default', type: 'number' },
        { field: 'multipleOf', type: 'number' },
        { field: 'minimum', type: 'number' },
        { field: 'maximum', type: 'number' },
        { field: 'exclusiveMinimum', type: 'number' },
        { field: 'exclusiveMaximum', type: 'number' },
        { field: 'deprecated', type: 'boolean' },
        { field: 'readOnly', type: 'boolean' },
        { field: 'writeOnly', type: 'boolean' }
    ];
    const booleanSchema = [
        { field: 'title', type: 'string' },
        { field: 'const', type: 'boolean', options: [{ label: 'true', value: true }, { label: 'false', value: false }] },
        { field: 'default', type: 'boolean', options: [{ label: 'true', value: true }, { label: 'false', value: false }], defaultValue: { label: '', value: false } },
        { field: 'deprecated', type: 'boolean' },
        { field: 'readOnly', type: 'boolean' },
        { field: 'writeOnly', type: 'boolean' }
    ];
    const controls = {};
    let SchemaDesigner = class SchemaDesigner extends base_2.Container {
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        constructor(parent, options) {
            super(parent, options);
        }
        refresh() {
            super.refresh();
        }
        init() {
            super.init();
            this.initUI();
        }
        getJsonData() {
            return this.schema || {};
        }
        getJsonUI() {
            return this.uiSchemaPanel?.getUISchema() || {};
        }
        async getJSON(_controls) {
            if (_controls === undefined)
                return undefined;
            if (_controls instanceof base_2.Control) {
                const control = _controls;
                if (control.getAttribute('ignore-field'))
                    return undefined;
                if (control.tagName === 'I-CHECKBOX')
                    return control.checked;
                if (control.tagName === 'I-COMBO-BOX') {
                    return (control.selectedItem)?.value;
                }
                if (control.tagName === 'I-INPUT') {
                    const inputType = control.inputType;
                    if (inputType === 'text')
                        return control.value;
                    if (inputType === 'number') {
                        const value = parseInt(control.value);
                        return isNaN(value) ? undefined : value;
                    }
                    return control.value;
                }
                return control.value;
            }
            if (_controls instanceof Array || typeof _controls !== 'object') {
                return _controls;
            }
            let data = {};
            const keys = Object.keys(_controls).sort(function (a, b) { return _controls[a].itemIdx - _controls[b].itemIdx; });
            for (const key of keys) {
                const value = await this.getJSON(_controls[key]);
                if (key === 'itemIdx' && typeof value === 'number') {
                    continue;
                }
                if (key === this.uuid) {
                    data['properties'] = value;
                }
                else if (value instanceof Array) {
                    if (key === 'prefixItems') {
                        data[key] = value.map((v) => {
                            if (v.type) {
                                return { type: v.type };
                            }
                            return { enum: v.enum };
                        });
                    }
                    else if (value.length) {
                        data[key] = value;
                    }
                }
                else if (value !== '' && value !== undefined) {
                    data[key] = value;
                }
            }
            return data;
        }
        async updateJsonData() {
            let schema = {
                type: 'object',
                required: controls['required'],
                properties: await this.getJSON(controls[this.uuid])
            };
            for (const obj of objectSchema) {
                const value = await this.getJSON(controls[obj.field]);
                if (value !== '' && value !== undefined) {
                    schema[obj.field] = value;
                }
            }
            this.schema = schema;
            this.txtSchema.value = JSON.stringify(schema, null, 4);
            this.uiSchemaPanel.schema = schema;
        }
        convertFieldNameToLabel(name) {
            let label = '';
            for (let i = 0; i < name.length; i++) {
                let char = name[i];
                if (i == 0) {
                    label += char.toUpperCase();
                    continue;
                }
                if (char == char.toUpperCase())
                    label += ` ${char}`;
                else
                    label += char;
            }
            return label;
        }
        generateFieldName(requiredElm) {
            while (true) {
                const fieldName = `item-${base_3.IdUtils.generateUUID(4)}`;
                const oldField = requiredElm.querySelector(`[field-required='${fieldName.toLowerCase()}']`);
                if (!oldField) {
                    return fieldName;
                }
            }
        }
        createDataSchema(parent, dataType, parentFields, parentType, field, listRequired, subIdx) {
            const pnlSchema = new layout_2.Panel();
            const isChildren = !!field;
            let fields = [...(parentFields || [])];
            let schemaDesigner = [];
            let isExpanded = true;
            let type = dataType;
            let requiredFields = [];
            let subItemIdx = 0;
            parent.append(pnlSchema);
            const pnlForm = new layout_2.Panel(undefined, {
                padding: { left: 10, right: 10 }
            });
            if (parentType === 'array') {
                fields.push('items');
                pnlSchema.setAttribute('role', 'sub-items');
            }
            if (isChildren) {
                fields.push(this.uuid);
                fields.push(field || '');
                schemaDesigner = this.addSchemaByType(fields, dataType);
                this.updateControls(controls, [...fields, 'itemIdx'], subIdx);
                pnlForm.setAttribute('role', 'form-item');
                const updateParentFields = (newParentFields, parentIdx) => {
                    fields.splice(parentIdx - 1, 1, newParentFields);
                };
                pnlForm.updateFields = (newParentField, parentIdx) => updateParentFields(newParentField, parentIdx);
                pnlForm.append(schemaDesigner);
            }
            const hasAction = dataType === 'object' || dataType === 'array';
            const btnAddItem = new button_2.Button(undefined, {
                caption: 'Add Item',
                padding: { top: 6, bottom: 6, left: 16, right: 16 }
            });
            btnAddItem.prepend(new icon_2.Icon(undefined, {
                name: 'plus',
                width: '1em',
                height: '1em',
                fill: Theme.colors.primary.contrastText,
            }));
            const hStackActions = new layout_2.HStack(undefined, {
                verticalAlignment: 'center',
                wrap: 'wrap',
                gap: 10,
                margin: { top: 10 }
            });
            const hStackAdd = new layout_2.HStack(hStackActions, {
                verticalAlignment: 'center',
                gap: 10,
                visible: hasAction
            });
            btnAddItem.onClick = async () => {
                const fieldName = this.generateFieldName(parent.querySelector("[role='fields-required']"));
                this.createDataSchema(pnlForm, 'object', fields, type, fieldName, requiredFields, subItemIdx++);
                requiredFields.push(fieldName);
                if (!vStackRequired.hasChildNodes()) {
                    const lb = new label_2.Label(vStackRequired, {
                        caption: 'Required',
                        margin: { top: isChildren ? 10 : 0 }
                    });
                    lb.classList.add('form-label');
                }
                const chkBox = new checkbox_2.Checkbox(undefined, {
                    caption: fieldName,
                    checked: true
                });
                chkBox.onChanged = () => {
                    const currentFieldName = pnlGroupRequired.getAttribute('field-required');
                    if (chkBox.checked) {
                        if (!requiredFields.some(v => v.toLowerCase() === currentFieldName.toLowerCase())) {
                            requiredFields.push(currentFieldName);
                        }
                    }
                    else {
                        const idx = requiredFields.findIndex(v => v.toLowerCase() === currentFieldName.toLowerCase());
                        if (idx !== -1) {
                            requiredFields.splice(idx, 1);
                        }
                    }
                    this.updateJsonData();
                };
                const pnlGroupRequired = new layout_2.Panel();
                pnlGroupRequired.classList.add('form-group');
                const pnlControl = new layout_2.Panel(pnlGroupRequired);
                pnlControl.classList.add('form-control');
                pnlControl.appendChild(chkBox);
                pnlGroupRequired.setAttribute('field-required', fieldName);
                vStackRequired.appendChild(pnlGroupRequired);
                await this.updateJsonData();
                this.uiSchemaPanel.updateActionsItems();
            };
            hStackAdd.appendChild(btnAddItem);
            hStackAdd.setAttribute('role', 'add-new-item');
            btnAddItem.setAttribute('action', 'add-item');
            const vStackRequired = new layout_2.VStack(undefined, {
                gap: 10,
                verticalAlignment: 'center'
            });
            vStackRequired.setAttribute('role', 'fields-required');
            this.updateControls(controls, [...fields, 'required'], requiredFields);
            let btnDelete = [];
            let inputDescription = [];
            let iconRemoveDescription = [];
            let iconRenameInvalid = [];
            let btnExpand = [];
            let iconExpand = [];
            const onExpand = (src) => {
                isExpanded = !isExpanded;
                schemaDesigner.visible = isExpanded;
                vStackRequired.visible = isExpanded;
                hStackActions.visible = isExpanded;
                if (src) {
                    btnExpand.caption = isExpanded ? 'Hide' : 'Show';
                    iconExpand.name = isExpanded ? 'angle-up' : 'angle-down';
                }
            };
            if (isChildren) {
                btnExpand = new button_2.Button(undefined, {
                    caption: 'Show',
                    display: 'flex',
                    width: '100%',
                    padding: { top: 6, bottom: 6, left: 12, right: 12 }
                });
                iconExpand = new icon_2.Icon(undefined, {
                    name: 'angle-down',
                    width: '1.125em',
                    height: '1.125em',
                    fill: Theme.colors.primary.contrastText,
                });
                btnExpand.prepend(iconExpand);
                btnExpand.onClick = onExpand;
                inputDescription = new input_2.Input(undefined, {
                    inputType: 'text',
                });
                iconRemoveDescription = new icon_2.Icon(undefined, {
                    name: 'times-circle',
                    visible: false,
                    width: 12,
                    height: 12,
                    position: 'absolute',
                    top: 5,
                    right: 5,
                    fill: Theme.colors.secondary.main,
                    tooltip: {
                        content: 'Remove this property',
                        trigger: 'hover',
                    }
                });
                iconRemoveDescription.onClick = () => {
                    iconRemoveDescription.visible = false;
                    inputDescription.value = '';
                    this.updateJsonData();
                };
                this.updateControls(controls, [...fields, 'description'], inputDescription);
                inputDescription.onChanged = () => {
                    iconRemoveDescription.visible = !!inputDescription.value;
                    this.updateJsonData();
                };
                iconRenameInvalid = new icon_2.Icon(undefined, {
                    name: 'exclamation-circle',
                    width: 12,
                    height: 12,
                    fill: Theme.colors.secondary.main,
                    tooltip: {
                        content: 'Invalid field',
                        trigger: 'hover',
                    },
                    visible: false
                });
                btnDelete = new button_2.Button(undefined, {
                    caption: 'Delete',
                    background: { color: `${Theme.colors.secondary.main} !important` },
                    display: 'flex',
                    width: '100%',
                    padding: { top: 6, bottom: 6, left: 12, right: 12 },
                });
                btnDelete.prepend(new icon_2.Icon(undefined, {
                    name: 'trash',
                    width: '1em',
                    height: '1em',
                    fill: Theme.colors.primary.contrastText,
                }));
                btnDelete.setAttribute('action', 'delete');
                btnDelete.onClick = async () => {
                    parent.removeChild(pnlSchema);
                    this.updateControls(controls, fields);
                    const elm = parent.querySelector("[role='fields-required']");
                    if (elm) {
                        const fieldName = fields[fields.length - 1] || '';
                        if (listRequired && listRequired.length) {
                            const idx = listRequired.findIndex(v => v.toLowerCase() === fieldName.toLowerCase());
                            if (idx !== -1) {
                                listRequired.splice(idx, 1);
                            }
                        }
                        const fieldRequired = elm.querySelector(`[field-required='${fieldName.toLowerCase()}']`);
                        if (fieldRequired) {
                            elm.removeChild(fieldRequired);
                            if (elm.childNodes.length === 1) {
                                elm.clearInnerHTML();
                            }
                        }
                    }
                    await this.updateJsonData();
                    let deleteFields = [];
                    for (const field of fields) {
                        if (deleteFields.length > 1 && deleteFields[deleteFields.length - 1] !== this.uuid && field !== this.uuid) {
                            continue;
                        }
                        deleteFields.push(field);
                    }
                    this.uiSchemaPanel.deleteUISchema(deleteFields);
                    this.uiSchemaPanel.updateActionsItems();
                };
                onExpand();
            }
            pnlForm.append(vStackRequired);
            pnlForm.append(hStackActions);
            const pnlSchemaItem = new layout_2.Panel(pnlSchema, {
                border: { width: 1, style: 'solid', color: '#DADDE1', radius: '1em' },
                padding: { top: 10, bottom: 10, left: 10, right: 10 },
                margin: { top: isChildren ? 20 : 0 }
            });
            pnlSchemaItem.classList.add('data-schema');
            const vStack = new layout_2.VStack(pnlSchemaItem, { gap: 10 });
            pnlSchemaItem.appendChild(pnlForm);
            if (!isChildren) {
                const hStack = new layout_2.HStack(vStack, {
                    gap: 10,
                    justifyContent: 'start',
                    alignItems: 'center'
                });
                const hStackRoot = new layout_2.HStack(hStack, {
                    gap: 10,
                    verticalAlignment: 'center'
                });
                hStackRoot.classList.add('cs-wrapper--header');
                new label_2.Label(hStackRoot, {
                    caption: 'Root',
                    font: { size: '1rem', bold: true }
                });
                new label_2.Label(hStackRoot, {
                    caption: 'object',
                    font: { size: '1rem' },
                    opacity: 0.65
                });
            }
            else {
                const hStack = new layout_2.HStack(vStack, {
                    gap: 10,
                    verticalAlignment: 'center'
                });
                const hStackChild = new layout_2.HStack(hStack, {
                    gap: 10,
                    wrap: 'wrap',
                    width: 'calc(100% - 120px)',
                    padding: { left: 10, right: 10 },
                });
                const pnlPropertyGroup = new layout_2.Panel(hStackChild, {
                    width: 'calc(33.33% - 7px)',
                    minWidth: 100
                });
                pnlPropertyGroup.classList.add('form-group');
                const lbPropertyName = new label_2.Label(pnlPropertyGroup, {
                    caption: 'Property Name'
                });
                lbPropertyName.classList.add('form-label');
                const pnlPropertyControl = new layout_2.Panel(pnlPropertyGroup);
                pnlPropertyControl.classList.add('form-control');
                const inputPropertyName = new input_2.Input(pnlPropertyControl, {
                    inputType: 'text',
                    value: field
                });
                pnlPropertyControl.appendChild(iconRenameInvalid);
                inputPropertyName.onChanged = async () => {
                    const currentFieldName = inputPropertyName.value;
                    if (currentFieldName && /^[a-zA-Z0-9_-]*$/.test(currentFieldName)) {
                        const requiredElm = parent.querySelector("[role='fields-required']");
                        const oldField = requiredElm.querySelector(`[field-required='${currentFieldName.toLowerCase()}']`);
                        if (oldField) {
                            iconRenameInvalid.visible = true;
                            iconRenameInvalid.tooltip.content = 'Duplicate field';
                        }
                        else {
                            iconRenameInvalid.visible = false;
                            const lastIndex = fields.length - 1;
                            const oldControl = this.getControlByPath(fields);
                            const oldFieldName = fields[lastIndex];
                            const oldFields = [...fields];
                            this.updateControls(controls, [...fields]);
                            fields.splice(lastIndex, 1);
                            fields.push(currentFieldName);
                            this.updateControls(controls, [...fields], oldControl);
                            const childForms = pnlForm.querySelectorAll("[role='form-item']");
                            for (const chidlForm of childForms) {
                                chidlForm.updateFields(currentFieldName, fields.length);
                            }
                            const requiredElm = parent.querySelector("[role='fields-required']");
                            if (requiredElm) {
                                if (listRequired && listRequired.length) {
                                    const idx = listRequired.findIndex(v => v.toLowerCase() === oldFieldName.toLowerCase());
                                    if (idx !== -1) {
                                        listRequired.splice(idx, 1, currentFieldName);
                                    }
                                }
                                const fieldRequired = requiredElm.querySelector(`[field-required='${oldFieldName.toLowerCase()}']`);
                                if (fieldRequired) {
                                    fieldRequired.setAttribute('field-required', currentFieldName.toLowerCase());
                                    fieldRequired.options['field-required'] = currentFieldName.toLowerCase();
                                    fieldRequired.firstChild.firstChild.caption = currentFieldName;
                                }
                            }
                            await this.updateJsonData();
                            this.uiSchemaPanel.updateUISchemaItemsByRename(oldFields, fields);
                        }
                    }
                    else {
                        iconRenameInvalid.visible = true;
                        iconRenameInvalid.tooltip.content = 'Invalid field';
                    }
                };
                const pnlTypeGroup = new layout_2.Panel(hStackChild, {
                    width: 'calc(33.33% - 7px)',
                    minWidth: 100
                });
                pnlPropertyGroup.classList.add('form-group');
                const lbTypeName = new label_2.Label(pnlTypeGroup, {
                    caption: 'Type'
                });
                lbTypeName.classList.add('form-label');
                const pnlTypeControl = new layout_2.Panel(pnlTypeGroup);
                pnlTypeControl.classList.add('form-control');
                const cbbType = new combo_box_2.ComboBox(pnlTypeControl, {
                    items: dataTypes,
                    selectedItem: dataTypes.find(v => v.value === 'object'),
                    icon: { name: 'caret-down', width: '16px', height: '16px' }
                });
                cbbType.onChanged = async () => {
                    const selectedItem = cbbType.selectedItem;
                    const value = selectedItem.value;
                    if (value === type)
                        return;
                    requiredFields = [];
                    pnlForm.clearInnerHTML();
                    schemaDesigner.clearInnerHTML();
                    schemaDesigner = this.addSchemaByType(fields, value);
                    schemaDesigner.visible = isExpanded;
                    vStackRequired.clearInnerHTML();
                    this.updateControls(controls, [...fields, 'required'], requiredFields);
                    this.updateControls(controls, [...fields, 'description'], inputDescription);
                    pnlForm.append(schemaDesigner);
                    pnlForm.append(vStackRequired);
                    pnlForm.append(hStackActions);
                    if (value === 'object' || value === 'array') {
                        btnAddItem.enabled = true;
                        hStackAdd.visible = true;
                    }
                    else {
                        btnAddItem.enabled = false;
                        hStackAdd.visible = false;
                    }
                    type = value;
                    await this.updateJsonData();
                    this.uiSchemaPanel.deleteUISchema(fields, true);
                    this.uiSchemaPanel.updateUISchemaByType(fields);
                };
                const pnlDescriptionGroup = new layout_2.Panel(hStackChild, {
                    width: 'calc(33.33% - 7px)',
                    minWidth: 100
                });
                pnlDescriptionGroup.classList.add('form-group');
                const lbDescriptionName = new label_2.Label(pnlDescriptionGroup, {
                    caption: 'Description'
                });
                lbDescriptionName.classList.add('form-label');
                const pnlDescriptionControl = new layout_2.Panel(pnlDescriptionGroup);
                pnlDescriptionControl.classList.add('form-control');
                pnlDescriptionControl.appendChild(inputDescription);
                pnlDescriptionControl.appendChild(iconRemoveDescription);
                const hStackGroupBtn = new layout_2.HStack(hStack, {
                    gap: 10,
                    width: 100,
                    wrap: 'wrap',
                    verticalAlignment: 'center'
                });
                hStackGroupBtn.appendChild(btnDelete);
                hStackGroupBtn.appendChild(btnExpand);
            }
        }
        renderEnum(parentFields, type, parentList) {
            let listEnum = [];
            if (parentList) {
                listEnum = parentList;
            }
            else {
                this.updateControls(controls, [...parentFields, 'enum'], listEnum);
            }
            const hStackEnum = new layout_2.HStack(undefined, {
                gap: 8,
                verticalAlignment: 'center',
                wrap: 'wrap'
            });
            hStackEnum.setAttribute('role', 'fields-enum');
            const btnAdd = new button_2.Button(undefined, {
                caption: 'Add',
                enabled: false,
                padding: { top: 6, bottom: 6, left: 16, right: 16 },
            });
            const inputEnum = new input_2.Input(undefined, {
                inputType: type,
            });
            inputEnum.classList.add('cs-width--input');
            inputEnum.onChanged = () => {
                const val = inputEnum.value;
                if (type === 'number') {
                    btnAdd.enabled = val !== '' && !isNaN(Number(val)) && !listEnum.some(v => v === Number(val));
                }
                else {
                    btnAdd.enabled = val && !listEnum.some(v => v.toString().toLowerCase() === val.toString().toLowerCase());
                }
            };
            btnAdd.onClick = async () => {
                const val = inputEnum.value;
                if (((type === 'number' && !isNaN(val)) || type === 'text' && val) && !listEnum.some(v => v.toString().toLowerCase() === val.toString().toLowerCase())) {
                    listEnum.push(type === 'number' ? Number(val) : val);
                    inputEnum.value = '';
                    btnAdd.enabled = false;
                    const pnlEnum = new layout_2.Panel(hStackEnum, {
                        position: 'relative',
                        display: 'flex',
                        padding: { top: 8, bottom: 8, left: 16, right: 16 },
                        border: { radius: 8 },
                        background: { color: Theme.action.selected }
                    });
                    const iconTimes = new icon_2.Icon(pnlEnum, {
                        name: 'times',
                        width: 14,
                        height: 14,
                        fill: Theme.colors.secondary.main,
                        position: 'absolute',
                        right: 2,
                        top: 2
                    });
                    iconTimes.onClick = async () => {
                        const idx = listEnum.findIndex(v => v.toString().toLowerCase() === val.toString().toLowerCase());
                        listEnum.splice(idx, 1);
                        if (!parentList) {
                            iconRemove.visible = !!listEnum.length;
                        }
                        hStackEnum.removeChild(pnlEnum);
                        await this.updateJsonData();
                        this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
                    };
                    const lbVal = new label_2.Label(pnlEnum, {
                        caption: val,
                        font: { size: '12px' },
                        minWidth: 20,
                        padding: { top: 0, bottom: 0, left: 0, right: 0 }
                    });
                    lbVal.classList.add('cs-enum--value');
                    if (!parentList) {
                        iconRemove.visible = true;
                    }
                    await this.updateJsonData();
                    this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
                }
            };
            const pnlEnumGroup = new layout_2.Panel(undefined, {
                width: '100%',
                margin: { top: 8 }
            });
            pnlEnumGroup.classList.add('form-group');
            let iconRemove = [];
            if (!parentList) {
                iconRemove = new icon_2.Icon(undefined, {
                    name: 'times-circle',
                    visible: false,
                    width: 12,
                    height: 12,
                    position: 'absolute',
                    top: 5,
                    right: 5,
                    fill: Theme.colors.secondary.main,
                    tooltip: {
                        content: 'Remove this property',
                        trigger: 'hover',
                    }
                });
                iconRemove.onClick = async () => {
                    hStackEnum.clearInnerHTML();
                    listEnum.splice(0, listEnum.length);
                    iconRemove.visible = false;
                    await this.updateJsonData();
                    this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
                };
                pnlEnumGroup.classList.add('cs-box--enum');
                pnlEnumGroup.appendChild(iconRemove);
            }
            const lbEnum = new label_2.Label(pnlEnumGroup, {
                caption: 'Enum'
            });
            lbEnum.classList.add('form-label');
            const pnlEnumControl = new layout_2.Panel(pnlEnumGroup);
            pnlEnumControl.classList.add('form-control');
            pnlEnumControl.appendChild(hStackEnum);
            const hStackInputEnum = new layout_2.Panel(pnlEnumControl, {
                gap: 8,
                margin: { top: 8 },
                wrap: 'wrap',
                verticalAlignment: 'center'
            });
            hStackInputEnum.appendChild(inputEnum);
            hStackInputEnum.appendChild(btnAdd);
            return pnlEnumGroup;
        }
        renderOneOf(parentFields, type, parentList) {
            let listOneOf = [];
            if (parentList) {
                listOneOf = parentList;
            }
            else {
                this.updateControls(controls, [...parentFields, 'oneOf'], listOneOf);
            }
            const hStackOneOf = new layout_2.HStack(undefined, {
                gap: 8,
                verticalAlignment: 'center',
                wrap: 'wrap'
            });
            hStackOneOf.setAttribute('role', 'fields-one-of');
            const btnAdd = new button_2.Button(undefined, {
                caption: 'Add',
                enabled: false,
                padding: { top: 6, bottom: 6, left: 16, right: 16 },
                maxHeight: 25
            });
            const inputOneOfTitle = new input_2.Input(undefined, {
                inputType: 'text',
            });
            const inputOneOfValue = new input_2.Input(undefined, {
                inputType: type,
            });
            inputOneOfTitle.onChanged = () => {
                const title = inputOneOfTitle.value || '';
                const val = inputOneOfValue.value;
                if (type === 'number') {
                    btnAdd.enabled = title && val !== '' && !isNaN(Number(val)) && !listOneOf.some(v => v.const === Number(val) || v.title.toLowerCase() === title.toLowerCase());
                }
                else {
                    btnAdd.enabled = title && val && !listOneOf.some(v => v.const.toString().toLowerCase() === val.toString().toLowerCase() || v.title.toLowerCase() === title.toLowerCase());
                }
            };
            inputOneOfValue.onChanged = () => {
                const title = inputOneOfTitle.value;
                const val = inputOneOfValue.value;
                if (type === 'number') {
                    btnAdd.enabled = title && val !== '' && !isNaN(Number(val)) && !listOneOf.some(v => v.const === Number(val) || v.title.toLowerCase() === title.toLowerCase());
                }
                else {
                    btnAdd.enabled = title && val && !listOneOf.some(v => v.const.toString().toLowerCase() === val.toString().toLowerCase() || v.title.toLowerCase() === title.toLowerCase());
                }
            };
            btnAdd.onClick = async () => {
                const title = inputOneOfTitle.value;
                const val = inputOneOfValue.value;
                if (((type === 'number' && !isNaN(val)) || type === 'text' && val) && !listOneOf.some(v => v.const.toString().toLowerCase() === val.toString().toLowerCase())) {
                    listOneOf.push({ title, const: type === 'number' ? Number(val) : val });
                    inputOneOfTitle.value = '';
                    inputOneOfValue.value = '';
                    btnAdd.enabled = false;
                    const pnlEnum = new layout_2.Panel(hStackOneOf, {
                        position: 'relative',
                        display: 'flex',
                        padding: { top: 8, bottom: 8, left: 16, right: 16 },
                        border: { radius: 8 },
                        background: { color: Theme.action.selected }
                    });
                    const iconTimes = new icon_2.Icon(pnlEnum, {
                        name: 'times',
                        width: 14,
                        height: 14,
                        fill: Theme.colors.secondary.main,
                        position: 'absolute',
                        right: 2,
                        top: 2
                    });
                    iconTimes.onClick = async () => {
                        const idx = listOneOf.findIndex(v => v.const.toString().toLowerCase() === val.toString().toLowerCase());
                        listOneOf.splice(idx, 1);
                        if (!parentList) {
                            iconRemove.visible = !!listOneOf.length;
                        }
                        hStackOneOf.removeChild(pnlEnum);
                        await this.updateJsonData();
                        this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
                    };
                    const lbVal = new label_2.Label(pnlEnum, {
                        caption: title,
                        font: { size: '12px' },
                        minWidth: 20,
                        padding: { top: 0, bottom: 0, left: 0, right: 0 }
                    });
                    lbVal.classList.add('cs-enum--value');
                    if (!parentList) {
                        iconRemove.visible = true;
                    }
                    await this.updateJsonData();
                    this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
                }
            };
            let iconRemove = [];
            if (!parentList) {
                iconRemove = new icon_2.Icon(undefined, {
                    name: 'times-circle',
                    visible: false,
                    width: 12,
                    height: 12,
                    position: 'absolute',
                    top: 5,
                    right: 5,
                    fill: Theme.colors.secondary.main,
                    tooltip: {
                        content: 'Remove this property',
                        trigger: 'hover',
                    }
                });
                iconRemove.onClick = async () => {
                    hStackOneOf.clearInnerHTML();
                    listOneOf.splice(0, listOneOf.length);
                    iconRemove.visible = false;
                    await this.updateJsonData();
                    this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
                };
            }
            const pnlOneOfGroup = new layout_2.Panel(undefined, {
                margin: { top: 8 }
            });
            pnlOneOfGroup.classList.add('`form-group');
            if (!parentList) {
                pnlOneOfGroup.classList.add('cs-box--enum');
            }
            pnlOneOfGroup.appendChild(iconRemove);
            const lbOneOf = new label_2.Label(pnlOneOfGroup, {
                caption: 'One Of'
            });
            lbOneOf.classList.add('form-label');
            const pnlOneOfControl = new layout_2.Panel(pnlOneOfGroup);
            pnlOneOfControl.classList.add('form-control');
            pnlOneOfControl.appendChild(hStackOneOf);
            const hStackOneOfInput = new layout_2.HStack(pnlOneOfControl, {
                gap: 8,
                margin: { top: 8 },
                wrap: 'wrap',
                verticalAlignment: 'end'
            });
            const pnlOneOfInput = new layout_2.Panel(hStackOneOfInput, {
                margin: { top: 8 }
            });
            pnlOneOfInput.classList.add('form-group', 'cs-width--input');
            const lbTitle = new label_2.Label(pnlOneOfInput, {
                caption: 'Title'
            });
            const pnlControlTitle = new layout_2.Panel(pnlOneOfInput);
            pnlControlTitle.classList.add('form-control');
            pnlControlTitle.appendChild(inputOneOfTitle);
            const lbConst = new label_2.Label(pnlOneOfInput, {
                caption: 'Const'
            });
            const pnlControlConst = new layout_2.Panel(pnlOneOfInput);
            pnlControlConst.classList.add('form-control');
            pnlControlConst.appendChild(inputOneOfValue);
            hStackOneOfInput.appendChild(btnAdd);
            return pnlOneOfGroup;
        }
        renderPrefixItems(parentFields) {
            let listType = [];
            this.updateControls(controls, [...parentFields, 'prefixItems'], listType);
            const vStackPrefixItems = new layout_2.VStack(undefined, {
                gap: 8,
                verticalAlignment: 'center',
                wrap: 'wrap',
                minWidth: 180
            });
            vStackPrefixItems.setAttribute('role', 'prefix-items');
            const hStackAdd = new layout_2.HStack(vStackPrefixItems, {
                verticalAlignment: 'center',
                gap: 10,
            });
            const options = [
                { label: 'string', value: 'string' },
                { label: 'number', value: 'number' },
                { label: 'enum', value: 'enum' }
            ];
            const cbbType = new combo_box_2.ComboBox(hStackAdd, {
                items: options,
                selectedItem: options[0],
                icon: { name: 'caret-down', width: '16px', height: '16px' },
                minWidth: 180
            });
            cbbType.style.width = 'calc(100% - 70px)';
            const btnAdd = new button_2.Button(hStackAdd, {
                caption: 'Add',
                padding: { top: 6, bottom: 6, left: 16, right: 16 },
            });
            btnAdd.onClick = () => {
                const val = cbbType.selectedItem.value;
                const idx = listType.length;
                let pnlEnum;
                const pnlType = new layout_2.Panel(undefined, {
                    position: 'relative',
                    display: 'flex',
                    padding: { top: 8, bottom: 8, left: 16, right: 16 },
                    border: { radius: 8 },
                });
                pnlType.classList.add('cs-box--shadow');
                const iconTimes = new icon_2.Icon(pnlType, {
                    name: 'times',
                    width: 14,
                    height: 14,
                    fill: Theme.colors.secondary.main,
                    position: 'absolute',
                    right: 4,
                    top: 4
                });
                iconTimes.onClick = () => {
                    const _idx = listType.findIndex(v => v.idx === idx);
                    listType.splice(_idx, 1);
                    vStackPrefixItems.removeChild(pnlType);
                    this.updateJsonData();
                };
                if (val !== 'enum') {
                    listType.push({ type: val, idx });
                    const lbVal = new label_2.Label(pnlType, {
                        caption: val,
                        font: { size: '12px' },
                        minWidth: 20,
                        padding: { top: 0, bottom: 0, left: 0, right: 0 }
                    });
                    lbVal.classList.add('cs-enum--value');
                }
                else {
                    listType.push({ enum: [], idx });
                    pnlEnum = this.renderEnum([], 'text', listType[idx].enum);
                }
                if (pnlEnum) {
                    pnlType.appendChild(pnlEnum);
                }
                vStackPrefixItems.appendChild(pnlType);
                this.updateJsonData();
            };
            const vStackPrefix = new layout_2.VStack(undefined, {
                gap: 8,
                verticalAlignment: 'center'
            });
            vStackPrefix.classList.add('cs-prefix--items');
            const pnlFormGroup = new layout_2.Panel(vStackPrefix);
            pnlFormGroup.classList.add('form-group');
            const lbPrefix = new label_2.Label(pnlFormGroup, {
                caption: 'Prefix Items'
            });
            lbPrefix.classList.add('form-label');
            const pnlPrefixControl = new layout_2.Panel(pnlFormGroup);
            pnlPrefixControl.classList.add('form-control');
            const hStackPrefixInput = new layout_2.HStack(pnlPrefixControl, {
                gap: 8,
                wrap: 'wrap',
                verticalAlignment: 'center'
            });
            hStackPrefixInput.appendChild(cbbType);
            hStackPrefixInput.appendChild(btnAdd);
            pnlPrefixControl.appendChild(vStackPrefixItems);
            return vStackPrefix;
        }
        updateControls(obj, keyPath, control) {
            let lastKeyIndex = keyPath.length - 1;
            for (let i = 0; i < lastKeyIndex; ++i) {
                const key = keyPath[i];
                if (!(key in obj)) {
                    obj[key] = {};
                }
                obj = obj[keyPath[i]];
            }
            if (control !== undefined) {
                obj[keyPath[lastKeyIndex]] = control;
            }
            else {
                delete obj[keyPath[lastKeyIndex]];
            }
        }
        getControlByPath(keyPath) {
            let obj = Object(controls);
            for (const key of keyPath) {
                if (!(key in obj)) {
                    obj[key] = {};
                }
                obj = obj[key];
            }
            return obj;
        }
        renderSchema(parentFields, schema, propType) {
            let _controls = {};
            this.updateControls(controls, parentFields, _controls);
            _controls['type'] = propType;
            const vStack = new layout_2.VStack(undefined, { gap: 10 });
            if (parentFields.length) {
                new label_2.Label(vStack, {
                    caption: 'Advanced options',
                    font: { size: '16px', color: Theme.colors.primary.main }
                });
            }
            const gridLayout = new layout_2.GridLayout(vStack, {
                templateColumns: ['1fr', '1fr'],
                gap: { column: 10, row: 10 }
            });
            for (const item of schema) {
                const { field, type, options, defaultValue } = item;
                const notCheckbox = type !== 'boolean' || (type === 'boolean' && options);
                const fieldName = this.convertFieldNameToLabel(field);
                const pnlFormGroup = new layout_2.Panel(gridLayout, {
                    margin: { top: notCheckbox ? undefined : 'auto' }
                });
                if (notCheckbox) {
                    const lbFieldName = new label_2.Label(pnlFormGroup, { caption: fieldName });
                    lbFieldName.classList.add('form-label');
                }
                const pnlFormControl = new layout_2.Panel(pnlFormGroup, { margin: { top: notCheckbox ? undefined : 10 } });
                let controlElm;
                if (options) {
                    controlElm = new combo_box_2.ComboBox(pnlFormControl, {
                        items: options,
                        selectedItem: defaultValue,
                        icon: { name: 'caret-down', width: '16px', height: '16px' }
                    });
                }
                else if (type === 'boolean') {
                    controlElm = new checkbox_2.Checkbox(pnlFormControl, {
                        caption: fieldName,
                        checked: !!defaultValue
                    });
                }
                else {
                    controlElm = new input_2.Input(pnlFormControl, {
                        inputType: type === 'number' ? 'number' : 'text',
                        value: defaultValue || ''
                    });
                }
                _controls[field] = controlElm;
                controlElm.options['ignore-field'] = true;
                const iconRemove = new icon_2.Icon(pnlFormControl, {
                    name: 'times-circle',
                    visible: false,
                    width: 12,
                    height: 12,
                    position: notCheckbox ? 'absolute' : 'relative',
                    fill: Theme.colors.secondary.main,
                    tooltip: {
                        content: 'Remove this property',
                        trigger: 'hover',
                    }
                });
                if (notCheckbox) {
                    iconRemove.top = 10;
                    iconRemove.right = 0;
                }
                else {
                    iconRemove.margin = { left: 4 };
                    iconRemove.style.verticalAlign = '-2px';
                }
                iconRemove.onClick = () => {
                    if (controlElm.tagName === 'I-CHECKBOX') {
                        controlElm.checked = false;
                    }
                    else if (controlElm.tagName === 'I-COMBO-BOX') {
                        controlElm.value = options && options[0];
                    }
                    else if (controlElm.tagName === 'I-INPUT') {
                        controlElm.value = '';
                    }
                    controlElm.options['ignore-field'] = true;
                    iconRemove.visible = false;
                    this.updateJsonData();
                };
                controlElm.onChanged = () => {
                    iconRemove.visible = true;
                    controlElm.options['ignore-field'] = false;
                    if (controlElm.tagName === 'I-INPUT' && controlElm.value === '') {
                        iconRemove.visible = false;
                    }
                    this.updateJsonData();
                };
            }
            return vStack;
        }
        addSchemaByType(parentFields, dataType) {
            switch (dataType) {
                case 'object':
                    return this.renderObjectSchema(parentFields, dataType);
                case 'array':
                    return this.renderArraySchema(parentFields, dataType);
                case 'string':
                    return this.renderStringSchema(parentFields, dataType);
                case 'number':
                case 'integer':
                    return this.renderNumberSchema(parentFields, dataType);
                case 'boolean':
                    return this.renderBooleanSchema(parentFields, dataType);
                default:
                    return [];
            }
        }
        renderObjectSchema(parentFields, dataType) {
            const pnlObjectSchema = new layout_2.Panel(undefined, {
                margin: { top: parentFields.length ? 20 : 0 }
            });
            pnlObjectSchema.appendChild(this.renderSchema(parentFields, objectSchema, dataType));
            return pnlObjectSchema;
        }
        renderStringSchema(parentFields, dataType) {
            const pnlStringSchema = new layout_2.Panel(undefined, {
                margin: { top: 20 }
            });
            pnlStringSchema.appendChild(this.renderSchema(parentFields, stringSchema, dataType));
            const gridLayout = new layout_2.GridLayout(pnlStringSchema, {
                templateColumns: ['1fr', '1fr'],
                verticalAlignment: 'start',
                gap: { column: 10, row: 10 }
            });
            gridLayout.appendChild(this.renderOneOf(parentFields, 'text'));
            gridLayout.appendChild(this.renderEnum(parentFields, 'text'));
            return pnlStringSchema;
        }
        renderNumberSchema(parentFields, dataType) {
            const pnlNumberSchema = new layout_2.Panel(undefined, {
                margin: { top: 20 }
            });
            pnlNumberSchema.appendChild(this.renderSchema(parentFields, numberSchema, dataType));
            const gridLayout = new layout_2.GridLayout(pnlNumberSchema, {
                templateColumns: ['1fr', '1fr'],
                verticalAlignment: 'start',
                gap: { column: 10, row: 10 }
            });
            gridLayout.appendChild(this.renderOneOf(parentFields, 'number'));
            gridLayout.appendChild(this.renderEnum(parentFields, 'number'));
            return pnlNumberSchema;
        }
        renderBooleanSchema(parentFields, dataType) {
            const pnlBooleanSchema = new layout_2.Panel(undefined, {
                margin: { top: 20 }
            });
            pnlBooleanSchema.appendChild(this.renderSchema(parentFields, booleanSchema, dataType));
            return pnlBooleanSchema;
        }
        renderArraySchema(parentFields, dataType) {
            const pnlPrefixItems = new layout_2.Panel(undefined, {
                width: 'calc(50% - 5px)'
            });
            let itemsType = 'object';
            const options = [
                { label: 'object', value: 'object' },
                { label: 'string', value: 'string' },
                { label: 'number', value: 'number' },
                { label: 'false', value: false }
            ];
            const cbbItemsType = new combo_box_2.ComboBox(undefined, {
                items: options,
                selectedItem: options[0],
                icon: { name: 'caret-down', width: '16px', height: '16px' },
            });
            const setEnableActions = (parentElm, enabled) => {
                if (!parentElm)
                    return;
                const hStackAdd = parentElm.querySelector(`[role='add-new-item']`);
                if (hStackAdd) {
                    const btnAddItem = hStackAdd.querySelector(`[action='add-field']`);
                    hStackAdd.visible = enabled;
                    if (btnAddItem) {
                        btnAddItem.enabled = enabled;
                    }
                }
            };
            cbbItemsType.onChanged = async () => {
                const selectedItem = cbbItemsType.selectedItem;
                const value = selectedItem.value;
                if (itemsType !== value) {
                    const parentElm = cbbItemsType.closest('.data-schema');
                    const subItemsElm = parentElm.querySelectorAll(":scope > i-panel > [role='sub-items']");
                    for (const subElm of subItemsElm) {
                        const btnDelete = subElm.querySelector("[action='delete']");
                        if (btnDelete) {
                            btnDelete.click();
                        }
                    }
                    if (value === 'object') {
                        pnlPrefixItems.clearInnerHTML();
                        setEnableActions(parentElm, true);
                        this.updateControls(controls, [...parentFields, 'prefixItems']);
                        pnlPrefixItems.visible = false;
                        this.updateControls(controls, [...parentFields, 'items'], { 'type': value });
                    }
                    else {
                        setEnableActions(parentElm, false);
                        pnlPrefixItems.visible = true;
                        if (value.toString() === 'false') {
                            this.updateControls(controls, [...parentFields, 'items'], false);
                        }
                        else {
                            this.updateControls(controls, [...parentFields, 'items'], { 'type': value });
                            if (itemsType === 'object') {
                                pnlPrefixItems.clearInnerHTML();
                                pnlPrefixItems.appendChild(this.renderPrefixItems(parentFields));
                            }
                        }
                    }
                    itemsType = value;
                    await this.updateJsonData();
                    this.uiSchemaPanel.deleteUISchema(parentFields, true);
                }
            };
            const formArr = this.renderSchema(parentFields, arraySchema, dataType);
            this.updateControls(controls, [...parentFields, 'items', 'type'], cbbItemsType);
            const pnlArrSchema = new layout_2.Panel(undefined, {
                margin: { top: 20 }
            });
            pnlArrSchema.appendChild(formArr);
            const hStackArr = new layout_2.HStack(pnlArrSchema, {
                gap: 10,
                margin: { top: 10 },
                width: '100%'
            });
            const pnlFormGroup = new layout_2.Panel(hStackArr, {
                width: 'calc(50% - 5px)',
                minWidth: 180
            });
            pnlFormGroup.classList.add('form-group');
            const lbItems = new label_2.Label(pnlFormGroup, {
                caption: 'Items'
            });
            lbItems.classList.add('form-label');
            const pnlItems = new layout_2.Panel(pnlFormGroup);
            pnlItems.classList.add('form-control');
            pnlItems.appendChild(cbbItemsType);
            hStackArr.appendChild(pnlPrefixItems);
            return pnlArrSchema;
        }
        async initUI() {
            const panel = await layout_2.Panel.create({
                width: '100%',
                height: '100%',
                padding: { top: 12, bottom: 12, left: 16, right: 16 }
            }, this);
            const tabs = await tab_1.Tabs.create({
                mode: 'horizontal'
            }, panel);
            const pnlData = await layout_2.Panel.create({ height: '100%' });
            this.pnlUISchema = await layout_2.Panel.create({ height: '100%' });
            tabs.add({ caption: 'Data Schema', children: pnlData });
            tabs.add({ caption: 'UI Schema (Optional)', children: this.pnlUISchema });
            tabs.activeTabIndex = 0;
            const gridLayout = await layout_2.GridLayout.create({
                position: 'relative',
                width: '100%',
                height: '100%',
                templateColumns: ['5.5fr', '4.5fr'],
                gap: { column: 10, row: 10 }
            }, pnlData);
            this.pnlSchemaBuilder = await layout_2.Panel.create({
                height: '100%',
                overflow: 'auto'
            }, gridLayout);
            this.pnlSchemaBuilder.classList.add('cs-webkit--scrollbar');
            const pnlJsonData = await layout_2.Panel.create({ height: '100%' }, gridLayout);
            this.txtSchema = await input_2.Input.create({
                inputType: 'textarea',
                rows: 10,
                readOnly: true,
                width: '100%'
            }, pnlJsonData);
            this.txtSchema.classList.add('cs-json--text');
            this.uiSchemaPanel = new uiSchema_1.SchemaDesignerUI(this.pnlUISchema);
            // this.uiSchemaPanel.uuid = this.uuid;
            this.createDataSchema(this.pnlSchemaBuilder, 'object');
            this.updateJsonData();
        }
    };
    SchemaDesigner = __decorate([
        (0, base_2.customElements)('i-schema-designer')
    ], SchemaDesigner);
    exports.SchemaDesigner = SchemaDesigner;
});
define("@ijstech/schema-designer", ["require", "exports", "@ijstech/schema-designer/schemaDesigner.ts"], function (require, exports, schemaDesigner_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaDesigner = void 0;
    Object.defineProperty(exports, "SchemaDesigner", { enumerable: true, get: function () { return schemaDesigner_1.SchemaDesigner; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/navigator/style/navigator.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const Theme = Styles.Theme.ThemeVars;
    Styles.cssRule('i-nav', {
        border: `1px solid ${Theme.divider}`,
        $nest: {
            '> i-vstack': {
                alignItems: 'center',
                height: '100%',
                $nest: {
                    '.search-container': {
                        width: '100%',
                        padding: 10,
                        borderBottom: `1px solid ${Theme.divider}`,
                        alignItems: 'center',
                        gap: 5,
                        $nest: {
                            '.clear': {
                                cursor: 'pointer'
                            },
                            'i-input': {
                                $nest: {
                                    'input': {
                                        background: 'transparent',
                                        border: '0',
                                        borderBottom: `1px solid ${Theme.divider}`
                                    }
                                }
                            }
                        }
                    },
                    '.nav-wrapper': {
                        width: '100%',
                        overflow: 'auto',
                        paddingBottom: 50
                    }
                }
            },
            'i-nav-item': {
                cursor: 'pointer',
                background: Theme.background.main,
                borderLeft: '3px solid transparent',
                borderBottom: `1px solid ${Theme.divider}`,
                $nest: {
                    '> i-grid-layout': {
                        height: 50,
                        padding: 10,
                        gap: 5,
                        alignItems: 'center'
                    },
                    'i-icon': {
                        height: Theme.typography.fontSize,
                        width: Theme.typography.fontSize,
                        fill: Theme.colors.primary.main
                    },
                    '&.active': {
                        color: Theme.colors.primary.contrastText,
                        background: Theme.colors.primary.main,
                        borderLeft: `3px solid ${Theme.colors.primary.main}`
                    }
                }
            }
        }
    });
});
define("@ijstech/navigator/navigator.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/input", "@ijstech/label", "@ijstech/icon", "@ijstech/navigator/style/navigator.css.ts"], function (require, exports, base_1, layout_1, input_1, label_1, icon_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NavItem = exports.Nav = void 0;
    // @customElements("i-nav", {
    //     icon: 'bars',
    //     group: GroupType.BASIC,
    //     className: 'Nav',
    //     props: {
    //         navItems: {type: 'object'},
    //         options: {type: 'object'}
    //     },
    //     events: {},
    //     dataSchema: {
    //         type: 'object',
    //         properties: {
    //             navItems: {
    //                 type: 'object',
    //                 items: {
    //                     type: 'array',
    //                     properties: {
    //                         id: {
    //                             type: 'string'
    //                         },
    //                         caption: {
    //                             type: 'string'
    //                         },
    //                         navItems: {
    //                             type: 'object'
    //                         },
    //                         data: {
    //                             type: 'object'
    //                         }
    //                     }
    //                 }
    //             },
    //             options: {
    //                 type: 'object'
    //             }
    //         }
    //     }
    // })
    let Nav = class Nav extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {});
            this._options = {};
            this._searching = false;
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        init() {
            super.init();
            const navItems = this.getAttribute('navItems', true);
            if (navItems) {
                this._navItems = navItems;
                this._flatNavItems = this.flattenNavItem(navItems);
            }
            if (!this._wrapper)
                this._wrapper = new layout_1.VStack();
            const navOptions = this.getAttribute('options', true);
            const onItemClick = this.getAttribute('onItemClick', true);
            if (onItemClick)
                this._onItemClick = onItemClick;
            this._options = navOptions;
            this.appendChild(this._wrapper);
            this.render();
        }
        set navItems(navItems) {
            this._navItems = navItems;
            this.renderNav(navItems);
        }
        get navItems() {
            return this._navItems;
        }
        setRootActive() {
            this._activeNavItem = undefined;
            this._parentNavItem = undefined;
            this.renderNav(this._navItems);
        }
        setSelectedItemById(id) {
            const navItem = this._flatNavItems.find(item => item.id === id);
            if (navItem) {
                if (navItem.navItems && navItem.navItems.length > 0) {
                    this._parentNavItem = navItem;
                    this.renderNav(navItem.navItems);
                }
                else {
                    const parentNavItem = this.findParentNavItem(this._navItems, id);
                    if (parentNavItem)
                        this._parentNavItem = parentNavItem;
                    const siblings = this.findSiblingsById(this._navItems, id);
                    if (siblings) {
                        this.renderNav(siblings);
                    }
                }
                this.setNavItemActive(id);
            }
        }
        getSelectedItemById(id) {
            return this._flatNavItems.find(item => item.id === id);
        }
        getActiveRoute() {
            let routeNavItems = [];
            if (this._activeNavItem) {
                routeNavItems.push(this._activeNavItem);
                let parentNavItem = this.findParentNavItem(this._navItems, this._activeNavItem.id);
                if (parentNavItem)
                    routeNavItems = [parentNavItem, ...routeNavItems];
                while (parentNavItem) {
                    parentNavItem = this.findParentNavItem(this._navItems, parentNavItem.id);
                    if (parentNavItem)
                        routeNavItems = [parentNavItem, ...routeNavItems];
                }
            }
            return routeNavItems;
        }
        clear() {
            this._navWrapper.clearInnerHTML();
        }
        render() {
            const pnlSearch = new layout_1.GridLayout(this._wrapper, {
                templateColumns: ['12px', '1fr', '12px']
            });
            pnlSearch.classList.add('search-container');
            new icon_1.Icon(pnlSearch, {
                name: 'search',
                height: '12px',
                width: '12px'
            });
            this.txtSearch = new input_1.Input(pnlSearch, {
                width: '100%',
                height: 30,
                placeholder: this._options.searchPlaceholder
            });
            const btnClear = new icon_1.Icon(pnlSearch, {
                name: 'times',
                width: '12px',
                height: '12px'
            });
            btnClear.classList.add('clear');
            btnClear.onClick = () => {
                this.txtSearch.value = '';
                this.handleSearchOnChange(this.txtSearch);
            };
            this.txtSearch.onChanged = this.handleSearchOnChange.bind(this);
            this._navWrapper = new layout_1.VStack(this._wrapper);
            this._navWrapper.classList.add('nav-wrapper');
            this.renderNav(this._navItems);
        }
        renderNav(navItems, searchMode) {
            this.clear();
            if (navItems) {
                if (this._parentNavItem && !searchMode) {
                    const backNavItem = new NavItem(this._navWrapper, {
                        back: true,
                        ...this._parentNavItem,
                    });
                    backNavItem.onClick = () => {
                        if (this._parentNavItem) {
                            const siblings = this.findSiblingsById(this._navItems, this._parentNavItem.id);
                            this._parentNavItem = this.findParentNavItem(this._navItems, this._parentNavItem.id);
                            if (siblings)
                                this.renderNav(siblings);
                        }
                    };
                }
                let parentPaths = [];
                for (const navItem of navItems) {
                    if (searchMode && (!navItem.navItems || (navItem.navItems && navItem.navItems.length === 0))) {
                        const parentPath = this.findParentPathByNavItem(navItem);
                        if (!parentPaths.includes(parentPath) && parentPath) {
                            parentPaths.push(parentPath);
                            const parentNavSiblings = this.findSiblingsById(this._navItems, navItem.id);
                            const parentPathNavItem = new NavItem(this._navWrapper, {
                                caption: parentPath,
                                navItems: parentNavSiblings
                            });
                            parentPathNavItem.onClick = () => {
                                this._parentNavItem = this.findParentNavItem(this._navItems, navItem.id);
                                if (this._parentNavItem && this._parentNavItem.navItems) {
                                    // const siblings = this.findSiblingsById(this._navItems, this._parentNavItem.id);
                                    // if (siblings)
                                    this.renderNav(this._parentNavItem.navItems);
                                }
                            };
                        }
                    }
                    const elmNavItem = new NavItem(this._navWrapper, {
                        ...navItem,
                    });
                    elmNavItem.onClick = () => {
                        if (navItem.navItems && navItem.navItems.length > 0)
                            this._parentNavItem = navItem;
                        else
                            this._parentNavItem = this.findParentNavItem(this._navItems, navItem.id);
                        if (navItem.navItems && navItem.navItems.length > 0) {
                            this.renderNav(navItem.navItems);
                        }
                        else {
                            if (this._searching) {
                                const siblings = this.findSiblingsById(this._navItems, navItem.id);
                                if (siblings)
                                    this.renderNav(siblings);
                            }
                            this.setNavItemActive(elmNavItem.id);
                            if (this._onItemClick) {
                                this._onItemClick(navItem);
                            }
                        }
                    };
                }
            }
        }
        setNavItemActive(id) {
            const filterNavItem = this._flatNavItems.find(item => item.id === id);
            if (filterNavItem) {
                if (filterNavItem.navItems && filterNavItem.navItems.length > 0)
                    return;
                this._activeNavItem = filterNavItem;
                const activeItem = this.querySelector('i-nav-item.active');
                if (activeItem)
                    activeItem.classList.remove('active');
                if (id) {
                    const navItem = this.querySelector(`i-nav-item[nav-id="${id}"]`);
                    if (navItem)
                        navItem.classList.add('active');
                }
            }
        }
        handleSearchOnChange(control) {
            const value = control.value;
            if (value.trim() === '')
                this.renderNav(this._navItems);
            else {
                this._searching = true;
                const filteredNavItems = this._flatNavItems.filter(v => v.caption.trim().toLowerCase().indexOf(value.trim().toLowerCase()) >= 0);
                this.renderNav(filteredNavItems, true);
            }
        }
        flattenNavItem(navItems) {
            if (!navItems || navItems.length == 0)
                return [];
            const flattenNavItems = [];
            for (const navItem of navItems) {
                let additionalNavItems = [];
                if (navItem.navItems) {
                    additionalNavItems = this.flattenNavItem(navItem.navItems);
                }
                flattenNavItems.push(navItem, ...additionalNavItems);
            }
            return flattenNavItems;
        }
        findSiblingsById(navItems, navItemId) {
            for (const navItem of navItems) {
                if (navItem.id === navItemId)
                    return navItems;
                else if (navItem.navItems && navItem.navItems.length > 0) {
                    const siblings = this.findSiblingsById(navItem.navItems, navItemId);
                    if (siblings !== undefined)
                        return siblings;
                }
            }
        }
        findParentNavItem(navItems, navItemId) {
            for (const navItem of navItems) {
                if (navItem.navItems && navItem.navItems.length > 0) {
                    if (navItem.navItems.find(item => item.id === navItemId))
                        return navItem;
                    else {
                        const parentNavItem = this.findParentNavItem(navItem.navItems, navItemId);
                        if (parentNavItem)
                            return parentNavItem;
                    }
                }
            }
        }
        findParentPathByNavItem(navItem) {
            if (!navItem)
                return '';
            let parentNavItem = this.findParentNavItem(this._navItems, navItem.id);
            if (!parentNavItem)
                return '';
            let path = parentNavItem.caption;
            while (parentNavItem) {
                parentNavItem = this.findParentNavItem(this._navItems, parentNavItem.id);
                if (parentNavItem)
                    path = `${parentNavItem.caption} / ${path}`;
            }
            return path;
        }
    };
    Nav = __decorate([
        (0, base_1.customElements)("i-nav")
    ], Nav);
    exports.Nav = Nav;
    let NavItem = class NavItem extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {});
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        init() {
            super.init();
            this._caption = this.getAttribute('caption', true);
            this._navItems = this.getAttribute('navItems', true);
            this._back = this.getAttribute('back', true);
            const id = this.getAttribute('id', true);
            if (id)
                this.setAttribute('nav-id', id);
            this.render();
            this.appendChild(this._wrapper);
        }
        render() {
            const templateColumns = [];
            if (this._back)
                templateColumns.push('18px');
            templateColumns.push('1fr');
            if (this._navItems && this._navItems.length > 0)
                templateColumns.push('18px');
            this._wrapper = new layout_1.GridLayout(undefined, {
                templateColumns,
            });
            if (this._back) {
                new icon_1.Icon(this._wrapper, {
                    name: 'chevron-left',
                });
            }
            new label_1.Label(this._wrapper, {
                caption: this._caption
            });
            if (!this._back && this._navItems && this._navItems.length > 0) {
                new icon_1.Icon(this._wrapper, {
                    name: 'chevron-right',
                });
            }
        }
    };
    NavItem = __decorate([
        (0, base_1.customElements)("i-nav-item")
    ], NavItem);
    exports.NavItem = NavItem;
});
define("@ijstech/navigator", ["require", "exports", "@ijstech/navigator/navigator.ts"], function (require, exports, navigator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NavItem = exports.Nav = void 0;
    Object.defineProperty(exports, "Nav", { enumerable: true, get: function () { return navigator_1.Nav; } });
    Object.defineProperty(exports, "NavItem", { enumerable: true, get: function () { return navigator_1.NavItem; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/breadcrumb/style/breadcrumb.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Styles.cssRule('i-breadcrumb', {
        $nest: {
            'i-icon': {
                scale: 0.9
            }
        }
    });
});
define("@ijstech/breadcrumb/breadcrumb.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/label", "@ijstech/icon", "@ijstech/style", "@ijstech/breadcrumb/style/breadcrumb.css.ts"], function (require, exports, base_1, layout_1, label_1, icon_1, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Breadcrumb = void 0;
    const Theme = Styles.Theme.ThemeVars;
    let Breadcrumb = class Breadcrumb extends base_1.Control {
        constructor(parent, options) {
            super(parent, options, {});
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        init() {
            super.init();
            const data = this.getAttribute('breadcrumbItems', true);
            this._onItemClick = this.getAttribute('onItemClick', true);
            if (data) {
                this._breadcrumbItems = data;
                this.render();
            }
        }
        set breadcrumbItems(breadcrumbItems) {
            this._breadcrumbItems = breadcrumbItems;
            this.render();
        }
        get breadcrumbItems() {
            return this._breadcrumbItems;
        }
        clear() {
            this._wrapper.clearInnerHTML();
        }
        render() {
            if (!this._wrapper) {
                const { gap = '5px' } = this.tag || {};
                this._wrapper = new layout_1.HStack(undefined, {
                    justifyContent: 'start',
                    alignItems: 'center',
                    gap
                });
            }
            this.clear();
            if (this._breadcrumbItems) {
                for (let i = 0; i < this._breadcrumbItems.length; i++) {
                    const breadcrumbItem = this._breadcrumbItems[i];
                    const activedColor = this.tag?.activeColor || Theme.colors.primary.main;
                    const color = i === this._breadcrumbItems.length - 1 ? activedColor : Theme.text.primary;
                    const lbBreadcrumb = new label_1.Label(this._wrapper, {
                        caption: breadcrumbItem.caption,
                        font: this.tag?.font || { size: Theme.typography.fontSize, color }
                    });
                    if (this._onItemClick !== undefined)
                        this.classList.add('pointer');
                    lbBreadcrumb.onClick = () => {
                        if (this._onItemClick)
                            this._onItemClick(breadcrumbItem);
                    };
                    if (i + 1 < this._breadcrumbItems.length) {
                        new icon_1.Icon(this._wrapper, {
                            name: 'chevron-right',
                            width: Theme.typography.fontSize,
                            height: Theme.typography.fontSize,
                            fill: Theme.text.primary
                        });
                    }
                }
            }
            this.appendChild(this._wrapper);
        }
    };
    Breadcrumb = __decorate([
        (0, base_1.customElements)("i-breadcrumb")
    ], Breadcrumb);
    exports.Breadcrumb = Breadcrumb;
});
define("@ijstech/breadcrumb", ["require", "exports", "@ijstech/breadcrumb/breadcrumb.ts"], function (require, exports, breadcrumb_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Breadcrumb = void 0;
    Object.defineProperty(exports, "Breadcrumb", { enumerable: true, get: function () { return breadcrumb_1.Breadcrumb; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/form/styles/index.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenInputStyle = exports.uploadStyle = exports.cardBody = exports.cardHeader = exports.cardStyle = exports.tabsStyle = exports.listItemBtnDelete = exports.listVerticalLayoutStyle = exports.listItemStyle = exports.listColumnHeaderStyle = exports.listBtnAddStyle = exports.listHeaderStyle = exports.checkboxStyle = exports.iconButtonStyle = exports.buttonStyle = exports.comboBoxStyle = exports.datePickerStyle = exports.inputStyle = exports.collapseBtnStyle = exports.groupBodyStyle = exports.groupHeaderStyle = exports.groupStyle = exports.formGroupStyle = exports.formStyle = void 0;
    const Theme = Styles.Theme.ThemeVars;
    exports.formStyle = Styles.style({
        $nest: {
            'i-vstack > .form-group': {
                width: '100%'
            }
        }
    });
    exports.formGroupStyle = Styles.style({
        display: 'flex',
        flexDirection: 'column',
        gap: 5,
        justifyContent: 'center'
    });
    exports.groupStyle = Styles.style({
        border: `1px solid ${Theme.divider}`,
        borderRadius: 5,
        width: '100%',
        marginBottom: 5,
    });
    exports.groupHeaderStyle = Styles.style({
        padding: 10,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        cursor: 'pointer'
    });
    exports.groupBodyStyle = Styles.style({
        padding: 10
    });
    exports.collapseBtnStyle = Styles.style({
        cursor: 'pointer',
        height: Theme.typography.fontSize,
        width: Theme.typography.fontSize
    });
    // Controls Style
    exports.inputStyle = Styles.style({
        width: '100% !important',
        $nest: {
            '& > input, & > textarea': {
                width: '100% !important',
                maxWidth: '100%',
                padding: '0.5rem 1rem',
                color: Theme.input.fontColor,
                backgroundColor: Theme.input.background,
                borderColor: Theme.input.background,
                borderRadius: '0.625rem',
                outline: 'none'
            },
            'i-color .input-span': {
                borderRadius: '0.625rem',
                $nest: {
                    '> span': {
                        borderRadius: '0.375rem'
                    }
                }
            },
            // '& > input:focus, & > textarea:focus': {
            //     backgroundColor: `darken(${Theme.input.background}, 20%)`,
            //     borderColor: `darken(${Theme.input.background}, 20%)`,
            // }
        }
    });
    exports.datePickerStyle = Styles.style({
        display: 'inline-flex',
        width: '100% !important',
        borderRadius: '0.625rem',
        $nest: {
            '> input': {
                width: 'calc(100% - 24px) !important',
                maxWidth: 'calc(100% - 24px)',
                padding: '0.5rem 1rem',
                color: Theme.input.fontColor,
                backgroundColor: Theme.input.background,
                borderColor: Theme.input.background,
                outline: 'none'
            },
            '> input:focus ~ .datepicker-toggle': {
                borderColor: Theme.colors.info.main
            },
            '.datepicker-toggle': {
                backgroundColor: Theme.input.background,
                width: '42px'
            }
        }
    });
    exports.comboBoxStyle = Styles.style({
        width: '100% !important',
        $nest: {
            '.selection': {
                width: '100% !important',
                maxWidth: '100%',
                padding: '0.5rem 1rem',
                color: Theme.input.fontColor,
                backgroundColor: Theme.input.background,
                borderColor: Theme.input.background,
                borderRadius: '0.625rem!important',
            },
            '.selection input': {
                color: 'inherit',
                backgroundColor: 'inherit',
                padding: 0
            },
            // '.selection:focus-within': {
            //     backgroundColor: `darken(${Theme.input.background}, 20%)`,
            //     borderColor: `darken(${Theme.input.background}, 20%)`
            // },
            '> .icon-btn': {
                justifyContent: 'center',
                borderColor: Theme.input.background,
                borderRadius: '0.625rem',
                width: '42px'
            }
        }
    });
    exports.buttonStyle = Styles.style({
        padding: 5
    });
    exports.iconButtonStyle = Styles.style({
        cursor: 'pointer',
        height: Theme.typography.fontSize,
        width: Theme.typography.fontSize
    });
    exports.checkboxStyle = Styles.style({
        $nest: {
            '.checkmark': {
                width: '22px',
                height: '22px',
                borderRadius: '6px'
            },
            '.checkmark:after': {
                width: '4px',
                height: '8px',
                top: '4px'
            }
        }
    });
    exports.listHeaderStyle = Styles.style({
        padding: '10px 0px',
        borderBottom: `1px solid ${Theme.divider}`,
        marginBottom: 10,
        minHeight: '60px',
        alignItems: 'center',
        fontWeight: 600
    });
    exports.listBtnAddStyle = Styles.style({
        color: Theme.colors.primary.contrastText,
        backgroundColor: Theme.colors.primary.main,
        padding: '0.5rem 1rem',
        borderRadius: 0,
        cursor: 'pointer',
    });
    exports.listColumnHeaderStyle = Styles.style({
        padding: '10px 0',
        textAlign: 'center'
    });
    exports.listItemStyle = Styles.style({
        $nest: {
            'i-panel': {
                $nest: {
                    'i-input': {
                        width: '100% !important'
                    },
                    'input': {
                        width: '100% !important'
                    },
                    'i-color': {
                        $nest: {
                            '.i-color': {
                                width: '100% !important'
                            },
                            '.input-span': {
                                width: '100% !important'
                            }
                        }
                    },
                    'i-checkbox': {
                        height: 'auto !important',
                        $nest: {
                            '.i-checkbox': {
                                width: '100%',
                                justifyContent: 'center'
                            },
                            '.i-checkbox_label': {
                                display: 'none'
                            }
                        }
                    }
                }
            }
        }
    });
    exports.listVerticalLayoutStyle = Styles.style({
        $nest: {
            '& > i-grid-layout:not(:last-child)': {
                paddingBottom: 10,
                borderBottom: '1px solid var(--divider)',
            },
            '& > i-grid-layout > i-panel': {
                flexDirection: 'row',
                flexWrap: 'wrap',
                $nest: {
                    '> i-hstack:first-child': {
                        width: '25% !important',
                    },
                    '> :nth-child(2)': {
                        width: 'calc(75% - 5px) !important'
                    },
                    'i-checkbox': {
                        width: '100%',
                        $nest: {
                            '.i-checkbox': {
                                display: 'flex',
                                flexDirection: 'row-reverse',
                                justifyContent: 'flex-end',
                                gap: 5
                            },
                            '.i-checkbox_label': {
                                display: 'flex',
                                paddingLeft: 0,
                                width: '25%'
                            }
                        }
                    }
                }
            }
        }
    });
    exports.listItemBtnDelete = Styles.style({
        cursor: 'pointer',
        placeSelf: 'center',
        height: Theme.typography.fontSize,
        width: Theme.typography.fontSize
    });
    exports.tabsStyle = Styles.style({
        marginBottom: 41,
        $nest: {
            '.tabs-nav-wrap': {
                $nest: {
                    '.tabs-nav': {
                        borderColor: 'transparent',
                        height: '54px'
                    },
                    'i-tab': {
                        border: 0,
                        fontFamily: Theme.typography.fontFamily,
                        fontSize: Theme.typography.fontSize,
                        fontWeight: 600,
                        borderBottom: '1px solid transparent',
                        background: 'transparent',
                        color: Theme.text.secondary,
                        margin: '0 0.75rem',
                        padding: '0.5rem 0',
                        transition: 'color .2s ease',
                        $nest: {
                            "&:first-of-type": {
                                marginLeft: 0
                            },
                            '&:not(.disabled):hover': {
                                color: Theme.text.primary,
                            },
                            '&:not(.disabled).active': {
                                background: 'transparent',
                                color: Theme.colors.info.main,
                                borderBottom: `1px solid ${Theme.colors.info.main}`,
                            },
                            '.tab-item': {
                                padding: 0
                            }
                        }
                    }
                }
            },
            '.tabs-content': {
                overflow: 'visible'
            }
        }
    });
    exports.cardStyle = Styles.style({
        // background: Theme.background.main,
        border: `1px solid ${Theme.divider}`
    });
    exports.cardHeader = Styles.style({
        padding: 20,
        borderBottom: `1px solid ${Theme.divider}`,
        cursor: 'pointer'
    });
    exports.cardBody = Styles.style({
        padding: 20
    });
    exports.uploadStyle = Styles.style({
        height: 'auto',
        width: '100%',
        margin: 0,
        fontFamily: Theme.typography.fontFamily,
        $nest: {
            '> .i-upload-wrapper': {
                marginBottom: 0,
                borderRadius: 5
            }
        }
    });
    exports.tokenInputStyle = Styles.style({
        $nest: {
            '#gridTokenInput': {
                border: '1px solid var(--divider) !important',
                borderRadius: '5px !important',
                padding: '0.31rem !important',
                background: 'transparent',
                $nest: {
                    '&:hover': {
                        borderColor: `${Theme.colors.primary.main} !important`
                    }
                }
            },
            '#btnToken': {
                display: 'flex',
                justifyContent: 'space-between',
                $nest: {
                    'i-icon': {
                        width: '20px !important',
                        height: '20px !important'
                    }
                }
            },
            'i-vstack.custom-border': {
                marginBlock: '0 !important'
            }
        }
    });
});
define("@ijstech/form/types/jsonSchema4.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("@ijstech/form/types/jsonSchema6.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("@ijstech/form/types/jsonSchema7.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("@ijstech/form/types/index.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("@ijstech/form/translations.json.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ///<amd-module name='@ijstech/form/translations.json.ts'/> 
    exports.default = {
        "en": {
            "is_not_an_instance_of_the_class/constructor_name": "is not an instance of the class/constructor {{name}}",
            "invalid_schema/property_definition_name": "Invalid schema/property definition {{name}}",
            "is_a_readonly_field_it_can_not_be_changed": "is a readonly field, it can not be changed",
            "is_missing_and_it_is_required": "is missing and it is required",
            "disallowed_value_was_matched": "disallowed value was matched",
            "There_must_be_a_minimum_of_number_in_the_array": "There must be a minimum of {{number}} in the array",
            "There_must_be_a_maximum_of_number_in_the_array": "There must be a maximum of {{number}} in the array",
            "does_not_match_the_regex_pattern_name": "does not match the regex pattern {{name}}",
            "may_only_be_length_characters_long": "may only be {{length}} characters long",
            "must_be_at_least_length_characters_long": "must be at least {{length}} characters long",
            "must_have_a_minimum_value_of_number": "must have a minimum value of {{number}}",
            "must_have_a_maximum_value_of_number": "must have a maximum value of {{number}}",
            "does_not_have_a_value_in_the_enumeration_enumer": "does not have a value in the enumeration {{enumer}}",
            "may_only_have_number_digits_of_decimal_places": "may only have {{number}} digits of decimal places",
            "is_not_a_valid_wallet_address": "is not a valid wallet address",
            "is_not_a_valid_cid": "is not a valid cid",
            "is_not_a_valid_version_0_cid": "is not a valid version 0 cid",
            "is_not_a_valid_version_1_cid": "is not a valid version 1 cid",
            "is_not_a_valid_uuid": "is not a valid uuid",
            "is_not_a_valid_URL": "is not a valid URL",
            "this": "This",
            "confirm": "Confirm",
            "clear": "Clear",
            "add": "Add",
        },
        "zh-hant": {
            "is_not_an_instance_of_the_class/constructor_name": "/ {{name}} ",
            "invalid_schema/property_definition_name": "/ {{name}}",
            "is_a_readonly_field_it_can_not_be_changed": "",
            "is_missing_and_it_is_required": "",
            "disallowed_value_was_matched": "",
            "There_must_be_a_minimum_of_number_in_the_array": " {{number}} ",
            "There_must_be_a_maximum_of_number_in_the_array": " {{number}} ",
            "does_not_match_the_regex_pattern_name": " {{name}}",
            "may_only_be_length_characters_long": " {{length}} ",
            "must_be_at_least_length_characters_long": " {{length}} ",
            "must_have_a_minimum_value_of_number": " {{number}}",
            "must_have_a_maximum_value_of_number": " {{number}}",
            "does_not_have_a_value_in_the_enumeration_enumer": " {{enumer}} ",
            "may_only_have_number_digits_of_decimal_places": " {{number}} ",
            "is_not_a_valid_wallet_address": "",
            "is_not_a_valid_cid": " cid",
            "is_not_a_valid_version_0_cid": " 0 cid",
            "is_not_a_valid_version_1_cid": " 1 cid",
            "is_not_a_valid_uuid": " UUID",
            "is_not_a_valid_URL": " URL",
            "this": "",
            "confirm": "",
            "clear": "",
            "add": "",
        },
        "vi": {
            "is_not_an_instance_of_the_class/constructor_name": "khng phi l mt th hin ca lp/hm to {{name}}",
            "invalid_schema/property_definition_name": "nh ngha s /thuc tnh khng hp l {{name}}",
            "is_a_readonly_field_it_can_not_be_changed": "l mt trng ch c, khng th thay i",
            "is_missing_and_it_is_required": "b thiu v l bt buc",
            "disallowed_value_was_matched": "khp vi gi tr khng c php",
            "There_must_be_a_minimum_of_number_in_the_array": "Mng phi c t nht {{number}} phn t",
            "There_must_be_a_maximum_of_number_in_the_array": "Mng phi c ti a {{number}} phn t",
            "does_not_match_the_regex_pattern_name": "khng khp vi mu regex {{name}}",
            "may_only_be_length_characters_long": "ch c th di {{length}} k t",
            "must_be_at_least_length_characters_long": "phi c t nht {{length}} k t",
            "must_have_a_minimum_value_of_number": "phi c gi tr ti thiu l {{number}}",
            "must_have_a_maximum_value_of_number": "phi c gi tr ti a l {{number}}",
            "does_not_have_a_value_in_the_enumeration_enumer": "khng c gi tr trong bng lit k {{enumer}}",
            "may_only_have_number_digits_of_decimal_places": "ch c th c {{number}} ch s thp phn",
            "is_not_a_valid_wallet_address": "khng phi l mt a ch v hp l",
            "is_not_a_valid_cid": "khng phi l mt cid hp l",
            "is_not_a_valid_version_0_cid": "khng phi l mt cid phin bn 0 hp l",
            "is_not_a_valid_version_1_cid": "khng phi l mt cid phin bn 1 hp l",
            "is_not_a_valid_uuid": "khng phi l mt UUID hp l",
            "is_not_a_valid_URL": "khng phi l mt URL hp l",
            "this": "Ci ny",
            "confirm": "Xc nhn",
            "clear": "Xa",
            "add": "Thm",
        }
    };
});
define("@ijstech/form/form.ts", ["require", "exports", "@ijstech/base", "@ijstech/tab", "@ijstech/input", "@ijstech/layout", "@ijstech/datepicker", "@ijstech/combo-box", "@ijstech/checkbox", "@ijstech/radio", "@ijstech/label", "@ijstech/upload", "@ijstech/icon", "@ijstech/button", "@ijstech/form/styles/index.css.ts", "@ijstech/style", "@ijstech/moment", "@ijstech/ipfs", "@ijstech/application", "@ijstech/form/translations.json.ts", "@ijstech/form/styles/index.css.ts"], function (require, exports, base_1, tab_1, input_1, layout_1, datepicker_1, combo_box_1, checkbox_1, radio_1, label_1, upload_1, icon_1, button_1, Styles, style_1, moment_1, ipfs_1, application_1, translations_json_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Form = void 0;
    const theme = style_1.Theme.ThemeVars;
    const IPFS_Gateway = 'https://ipfs.scom.dev/ipfs/';
    const DEFAULT_OPTIONS = {
        columnsPerRow: 1,
        confirmButtonOptions: {
            caption: '$confirm',
            backgroundColor: theme.colors.primary.main,
            fontColor: theme.colors.primary.contrastText,
            hide: false
        },
        clearButtonOptions: {
            caption: '$clear',
            backgroundColor: theme.colors.primary.main,
            fontColor: theme.colors.primary.contrastText,
            hide: true
        },
        dateTimeFormat: {
            date: 'YYYY-MM-DD',
            time: 'HH:mm:ss',
            dateTime: 'YYYY-MM-DD HH:mm:ss'
        },
        columnWidth: '100%'
    };
    let Form = class Form extends base_1.Control {
        constructor(parent, options) {
            super(parent, options);
            this._formRules = [];
            this._formControls = {};
            this.replacePhrase = (str) => {
                return str.replace(/([^\/]+)\/items\/properties/g, function (match, p1) {
                    if (p1 === 'properties') {
                        return match;
                    }
                    return `${p1}/properties`;
                });
            };
            // Validation
            this.validateOnValueChanged = async (currentControl, parent, scope, caption) => {
                const data = this.validationData ?? await this.getFormData();
                const validationResult = this.validationResult ?? this.validate(data, this.jsonSchema, { changing: false });
                let showErrMsg = false;
                let errMsg = '';
                const isNonObject = parent.closest('[non-object="true"]');
                let _scope = scope;
                const parentListItem = parent.closest('[role="list-item"]');
                if (parentListItem && !isNonObject) {
                    let parentFields = [];
                    const getParentIdxs = async (_parent) => {
                        if (!_parent)
                            return;
                        const parentElm = _parent.closest('[role="array"]');
                        const arrayField = parentElm?.getAttribute('array-field');
                        if (arrayField) {
                            const parentList = parentElm.querySelectorAll(':scope > i-vstack > [role="list-item"]');
                            for (let i = 0; i < parentList.length; i++) {
                                if (parentList[i] === _parent) {
                                    parentFields.push({ key: arrayField, idx: i });
                                    await getParentIdxs(parentElm.closest('[role="list-item"]'));
                                    break;
                                }
                            }
                        }
                    };
                    await getParentIdxs(parentListItem);
                    // Remove items props
                    if (scope.includes('/items/properties')) {
                        _scope = this.replacePhrase(scope);
                    }
                    const scopeWithoutIdx = _scope.replace('#', '');
                    const getListFields = (property) => {
                        const regex = /\w+\[\d+\]/g;
                        const matches = property.match(regex);
                        return matches || [];
                    };
                    let nestedScopeKeys = _scope.replace(/\/properties/g, '').split('/');
                    parentFields.forEach(field => {
                        const idx = nestedScopeKeys.findIndex(v => v === field.key);
                        if (idx > -1) {
                            nestedScopeKeys[idx + 1] = `${nestedScopeKeys[idx + 1]}_${field.idx + 1}`;
                        }
                    });
                    let nestedScope = nestedScopeKeys.join('/properties/');
                    if (parentFields[0]) {
                        _scope = `${_scope}_${parentFields[0].idx + 1}`;
                    }
                    nestedScope = nestedScope.replace('#', '');
                    _scope = _scope.replace('#', '');
                    const parentControl = currentControl.parentElement;
                    const lbError = (parentControl?.querySelector('[role="error"]') || parent.querySelector('[role="error"]') || parent);
                    const err = validationResult.errors.find(f => {
                        const listFields = getListFields(f.property).reverse();
                        if (f.scope.endsWith(_scope) || f.scope.endsWith(nestedScope) || f.scope.endsWith(scopeWithoutIdx)) {
                            for (let idx = 0; idx < listFields.length; idx++) {
                                const fld = listFields[idx];
                                const parentFld = parentFields[idx];
                                if (fld !== `${parentFld.key}[${parentFld.idx}]`)
                                    return false;
                            }
                            return true;
                        }
                        return false;
                    });
                    /* let lbArrayError = parent.closest('[role="array"]')?.querySelector('[role="error"][array-scope]') as Label;
                    if (lbArrayError && lbArrayError.hasAttribute('is-visible')) {
                        lbArrayError.removeAttribute('is-visible')
                        lbArrayError.caption = '';
                        lbArrayError.visible = false;
                    } */
                    if (!lbError)
                        return;
                    if (err) {
                        lbError.setAttribute('is-visible', '');
                        lbError.caption = `${this.getTranslatedText(caption || '')} ${this.getTranslatedMessage(err.message)}`;
                        lbError.visible = true;
                    }
                    else {
                        lbError.removeAttribute('is-visible');
                        lbError.caption = '';
                        lbError.visible = false;
                    }
                    return;
                }
                let itemScope = scope;
                let itemControl = {};
                if (isNonObject) {
                    const parentItem = currentControl.closest('[non-object]');
                    const allItems = parentItem.querySelectorAll('[role="field"]');
                    for (let idx = 0; idx <= allItems.length; idx++) {
                        if (allItems[idx] === currentControl) {
                            itemScope = `${scope.replace(/\/items$/, '')}_${idx + 1}`;
                            break;
                        }
                    }
                    const parentControl = currentControl.parentElement;
                    const lbError = (parentControl?.querySelector('[role="error"]') || parent.querySelector('[role="error"]'));
                    itemControl = { error: lbError };
                }
                if (validationResult?.valid == false) {
                    const err = validationResult.errors.find(f => f.scope === (isNonObject ? itemScope : scope));
                    if (err) {
                        showErrMsg = true;
                        errMsg = err.message;
                    }
                }
                const control = isNonObject ? itemControl : this._formControls[_scope];
                if (control) {
                    const { error, description } = control;
                    if (showErrMsg) {
                        if (description) {
                            description.visible = false;
                        }
                        if (error) {
                            error.setAttribute('is-visible', '');
                            error.caption = `${isNonObject ? 'Item' : this.getTranslatedText(caption || '')} ${this.getTranslatedMessage(errMsg)}`;
                            error.visible = true;
                        }
                    }
                    else {
                        if (description && description.caption) {
                            description.visible = true;
                        }
                        if (error) {
                            error.removeAttribute('is-visible');
                            error.caption = '';
                            error.visible = false;
                        }
                    }
                }
            };
        }
        init() {
            this.i18nMessage = new base_1.I18n();
            this.i18nMessage.init({ ...translations_json_1.default });
            super.init();
            this.classList.add(Styles.formStyle);
            this._jsonSchema = this.getAttribute('jsonSchema', true);
            this._uiSchema = this.getAttribute('uiSchema', true);
            this._formOptions = this.getAttribute('options', true);
            if (!this._formOptions)
                this._formOptions = DEFAULT_OPTIONS;
            this.renderForm();
        }
        set formOptions(options) {
            this._formOptions = options;
        }
        get formOptions() {
            return this._formOptions;
        }
        set jsonSchema(jsonSchema) {
            this._jsonSchema = jsonSchema;
        }
        get jsonSchema() {
            return this._jsonSchema;
        }
        set uiSchema(uiSchema) {
            this._uiSchema = uiSchema;
        }
        get uiSchema() {
            return this._uiSchema;
        }
        clearFormData() {
            for (const scope in this._formControls) {
                const control = this._formControls[scope];
                const { input, error } = control;
                if (input) {
                    if (error) {
                        error.removeAttribute('is-visible');
                        error.caption = '';
                        error.visible = false;
                    }
                    switch (input.tagName) {
                        case 'I-INPUT':
                            input.value = '';
                            break;
                        case 'I-CHECKBOX':
                            input.checked = false;
                            break;
                        case 'I-DATEPICKER':
                            input.value = undefined;
                            break;
                        case 'I-COMBO-BOX':
                            input.clear();
                            break;
                        case 'I-VSTACK':
                            input.clearInnerHTML();
                            break;
                        case 'I-UPLOAD':
                            input.clear();
                            break;
                    }
                }
            }
        }
        setFormData(data) {
            for (const key in data) {
                const value = data[key];
                const scope = `#/properties/${key}`;
                this.setData(scope, value, undefined, data);
            }
            this.validateAllRule();
        }
        setCustomData(scope, value, control, customData) {
            let newScope = scope;
            if (newScope.includes('/items/properties')) {
                newScope = this.replacePhrase(scope);
            }
            if (this._formOptions.customControls && !!this._formOptions.customControls[newScope]?.setData) {
                const _control = control || this._formControls[newScope].input;
                if (_control) {
                    if (_control.tagName === 'I-SCOM-TOKEN-INPUT' && !value && customData) {
                        this._formOptions.customControls[newScope].setData(_control, customData.symbol, customData);
                    }
                    else {
                        this._formOptions.customControls[newScope].setData(_control, value, customData);
                    }
                }
            }
        }
        setData(scope, value, parentElm, customData) {
            let _control;
            this.setCustomData(scope, value, undefined, customData);
            const input = this._formControls[scope]?.input;
            if (input?.tagName === 'designer-template-areas'.toUpperCase()) {
                return;
            }
            if (typeof value === 'object') {
                if (value instanceof Array) {
                    if (parentElm) {
                        const currentFld = scope.split('/').pop();
                        _control = parentElm.querySelector(`[array-field="${currentFld}"]`)?.lastChild;
                    }
                    const grid = _control || this._formControls[scope]?.input;
                    if (grid) {
                        grid.clearInnerHTML();
                        for (const data of value) {
                            const schema = this.getDataSchemaByScope(scope)[1]?.items;
                            this.renderCard({ parent: grid, scope, schema: schema, options: {} });
                        }
                        const listItems = grid?.querySelectorAll(':scope > [role="list-item"]');
                        if (listItems && listItems.length > 0) {
                            for (let i = 0; i < listItems.length; i++) {
                                const listItem = listItems[i];
                                const rowData = value[i];
                                const fields = listItem.querySelectorAll('[role="field"]');
                                if (grid.getAttribute('non-object') === true) {
                                    const field = fields[0];
                                    if (field) {
                                        if (field.tagName === 'I-INPUT') {
                                            field.value = rowData;
                                        }
                                        else if (field.tagName === 'I-CHECKBOX') {
                                            field.checked = rowData;
                                        }
                                        else if (field.tagName === 'I-COMBO-BOX') {
                                            field.value = rowData;
                                            // const selectedItem = (field as ComboBox).items.find(v => v.value === rowData);
                                            // if (selectedItem)
                                            //     (field as ComboBox).selectedItem = selectedItem;
                                        }
                                        else if (field.tagName === 'I-RADIO-GROUP') {
                                            field.selectedValue = rowData;
                                        }
                                        else if (field.tagName === 'I-DATEPICKER') {
                                            let datepicker = field;
                                            datepicker.value = (0, moment_1.moment)(rowData, datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
                                        }
                                        else {
                                            this.setCustomData(scope, rowData, field, rowData);
                                        }
                                    }
                                }
                                else {
                                    for (let j = 0; j < fields.length; j++) {
                                        const field = fields[j];
                                        const fieldName = field.getAttribute('field') || '';
                                        const columnData = rowData[fieldName];
                                        if (field.tagName === 'I-INPUT') {
                                            const customScope = field.getAttribute('custom-control');
                                            if (customScope) {
                                                this.setCustomData(customScope, columnData, field, rowData);
                                            }
                                            else {
                                                field.value = columnData;
                                            }
                                        }
                                        else if (field.tagName === 'I-CHECKBOX') {
                                            field.checked = columnData;
                                        }
                                        else if (field.tagName === 'I-COMBO-BOX') {
                                            field.value = columnData;
                                            // const selectedItem = (field as ComboBox).items.find(v => v.value === columnData);
                                            // if (selectedItem)
                                            //     (field as ComboBox).selectedItem = selectedItem;
                                        }
                                        else if (field.tagName === 'I-RADIO-GROUP') {
                                            field.selectedValue = columnData;
                                        }
                                        else if (field.tagName === 'I-DATEPICKER') {
                                            let datepicker = field;
                                            datepicker.value = (0, moment_1.moment)(columnData, datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
                                        }
                                        else if (field.tagName === 'I-UPLOAD') {
                                            this.setDataUpload(columnData, field);
                                        }
                                        else {
                                            const customScope = `${scope}/properties/${fieldName}`;
                                            this.setCustomData(customScope, columnData, field, rowData);
                                        }
                                    }
                                    const subArr = listItem.querySelectorAll('[role="array"]');
                                    for (const subItem of subArr) {
                                        if (subItem.closest('[role="list-item"]') === listItem) {
                                            const field = subItem.getAttribute('array-field') || '';
                                            this.setData(`${scope}/items/properties/${field}`, rowData[field], listItem, rowData);
                                        }
                                    }
                                    const subObj = listItem.querySelectorAll('[role="object"]');
                                    for (const subItem of subObj) {
                                        if (subItem.closest('[role="list-item"]') === listItem) {
                                            const field = subItem.getAttribute('object-field') || '';
                                            this.setData(`${scope}/items/properties/${field}`, rowData[field], listItem, rowData);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    if (parentElm) {
                        const currentFld = scope.split('/').pop();
                        _control = parentElm.querySelector(`[object-field="${currentFld}"]`);
                    }
                    for (const key in value) {
                        const data = value[key];
                        const currentScope = `${scope}/properties/${key}`;
                        this.setData(currentScope, data, _control || parentElm, data);
                    }
                }
            }
            else {
                if (parentElm) {
                    _control = parentElm.querySelector(`[scope="${scope}"]`);
                    if (!_control) {
                        const customScope = scope.includes('/items/properties') ? this.replacePhrase(scope) : scope;
                        _control = parentElm.querySelector(`[custom-control="${customScope}"]`);
                    }
                }
                const input = _control || this._formControls[scope]?.input;
                if (!input && value === undefined) {
                    const currentFld = scope.split('/').pop();
                    const objElm = parentElm?.querySelector(`[object-field="${currentFld}"]`);
                    if (objElm) {
                        const _inputs = objElm.querySelectorAll(':scope > i-panel > i-vstack > [role="field"]');
                        for (const _input of _inputs) {
                            this.setData(`${scope}/properties/${_input.getAttribute('field')}`, undefined, objElm);
                        }
                    }
                    return;
                }
                if (input) {
                    if (input.getAttribute('custom-control')) {
                        this.setCustomData(input.getAttribute('custom-control'), value, input, customData);
                    }
                    else {
                        switch (input.tagName) {
                            case 'I-INPUT':
                                input.value = value;
                                break;
                            case 'I-CHECKBOX':
                                input.checked = value;
                                break;
                            case 'I-COMBO-BOX':
                                input.value = value;
                                const isValid = input.items.find(v => v.value === value);
                                if (!isValid)
                                    input.selectedItem = input.items[0];
                                // (input as ComboBox).selectedItem = (input as ComboBox).items.find(v => v.value === value) || (input as ComboBox).items[0];
                                break;
                            case 'I-DATEPICKER':
                                let datepicker = input;
                                datepicker.value = (0, moment_1.moment)(value, datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
                                break;
                            case 'I-UPLOAD':
                                this.setDataUpload(value, input);
                                break;
                        }
                    }
                }
            }
        }
        async getFormData(isErrorShown) {
            if (!this._jsonSchema)
                return undefined;
            const data = await this.getDataBySchema(this._jsonSchema, '#', isErrorShown);
            if (isErrorShown) {
                this.checkArrayErrors();
            }
            this.isSubmitted = false;
            return data;
        }
        async getDataBySchema(schema, scope = '#', isErrorShown, parentElm, listItem, parentScope) {
            if (!schema)
                return undefined;
            const customParentScope = parentScope ? `${parentScope}${scope.replace('#', '')}` : scope;
            let _control;
            // if (parentElm) {
            //     _control = parentElm.querySelector(`[scope="${scope}"]`);
            // }
            let control;
            if (listItem) {
                const fieldName = scope.split('/').pop();
                control = listItem.querySelector(`[scope="${scope}"]`);
                if (!control) {
                    const flds = listItem.querySelectorAll(`[field="${fieldName}"]`);
                    const currentScope = scope.replace('#', '');
                    for (const fld of flds) {
                        const _fldScope = fld.getAttribute('scope');
                        if (_fldScope && _fldScope.endsWith(currentScope)) {
                            control = fld;
                            break;
                        }
                    }
                }
                if (!control && this._formOptions.customControls) {
                    if (this._formOptions.customControls[customParentScope]) {
                        control = listItem.querySelector(`[custom-control="${customParentScope}"]`);
                    }
                    else if (this._formOptions.customControls[scope] && listItem.parentElement?.hasAttribute('non-object')) {
                        control = listItem.querySelector(`[custom-control="${scope}"]`);
                    }
                }
            }
            else {
                control = _control || this._formControls[scope]?.input;
            }
            const checkValidation = () => {
                if (isErrorShown && control) {
                    const actControl = control;
                    if (actControl.querySelector('i-color') && typeof actControl.onClosed === 'function') {
                        actControl.onClosed();
                    }
                    else if (typeof actControl.onChanged === 'function') {
                        actControl.onChanged();
                    }
                }
            };
            if (this._formOptions.customControls && typeof this._formOptions.customControls[customParentScope]?.getData === 'function') {
                checkValidation();
                return this._formOptions.customControls[customParentScope].getData(control);
            }
            if (schema.type === 'string') {
                if (control) {
                    checkValidation();
                    switch (control.tagName) {
                        case 'I-INPUT':
                            return control.value;
                        case 'I-COMBO-BOX':
                            return control.selectedItem?.value;
                        case 'I-DATEPICKER':
                            let datepicker = control;
                            return datepicker.value?.format(datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
                        case 'I-UPLOAD':
                            const uploader = control;
                            const file = uploader.fileList[0];
                            if (file) {
                                if (schema.format === 'data-url') {
                                    const dataUrl = await uploader.toBase64(file);
                                    return dataUrl;
                                }
                                else if (schema.format === 'data-cid') {
                                    let cid = file.cid?.cid;
                                    if (!cid)
                                        return undefined;
                                    try {
                                        try {
                                            let result = await fetch(`https://ipfs.scom.dev/ipfs/${cid}`);
                                        }
                                        catch {
                                            await uploader.upload();
                                        }
                                    }
                                    catch { }
                                    return cid;
                                }
                                else
                                    return undefined;
                            }
                            else
                                return undefined;
                        default:
                            return undefined;
                    }
                }
                else
                    return undefined;
            }
            else if (schema.type === 'integer') {
                if (control) {
                    checkValidation();
                    switch (control.tagName) {
                        case 'I-INPUT':
                            const val = control.value;
                            return this.isNumber(val) ? parseInt(val) : undefined;
                        case 'I-COMBO-BOX':
                            return parseFloat(control.selectedItem?.value || '');
                        default:
                            return undefined;
                    }
                }
                else
                    return undefined;
            }
            else if (schema.type === 'number') {
                if (control) {
                    checkValidation();
                    switch (control.tagName) {
                        case 'I-INPUT':
                            const val = control.value;
                            return this.isNumber(val) ? parseFloat(val) : undefined;
                        case 'I-COMBO-BOX':
                            return parseFloat(control.value?.value);
                        default:
                            return undefined;
                    }
                }
                else
                    return undefined;
            }
            else if (schema.type === 'boolean') {
                if (control) {
                    checkValidation();
                    switch (control.tagName) {
                        case 'I-CHECKBOX':
                            return control.checked;
                        default:
                            return undefined;
                    }
                }
            }
            else if (schema.type === 'object') {
                const properties = schema.properties;
                if (!properties)
                    return undefined;
                const obj = {};
                for (const propertyName in properties) {
                    const currentSchema = properties[propertyName];
                    const currentScope = `${scope}/properties/${propertyName}`;
                    obj[propertyName] = await this.getDataBySchema(currentSchema, currentScope, isErrorShown, parentElm, listItem, parentScope);
                }
                return obj;
            }
            else if (schema.type === 'array') {
                if (parentElm) {
                    _control = parentElm.querySelector('[role="list-item"]')?.parentElement;
                }
                else if (listItem) {
                    _control = listItem.querySelector('[role="list-item"]')?.parentElement;
                }
                const grid = _control || this._formControls[scope]?.input;
                const listItems = grid?.querySelectorAll(':scope > [role="list-item"]');
                if (!(schema.items instanceof Array) && typeof schema.items === 'object') {
                    const currentSchema = schema.items;
                    if (listItems && listItems.length > 0) {
                        const list = [];
                        const newScope = currentSchema.type === 'string' ? scope + '/items' : '#';
                        for (let i = 0; i < listItems.length; i++) {
                            const listItem = listItems[i];
                            const data = await this.getDataBySchema(currentSchema, newScope, isErrorShown, parentElm, listItem, customParentScope);
                            list.push(data);
                        }
                        return list;
                    }
                }
            }
        }
        isNumber(value) {
            if (value === null || value === undefined || value === '' || isNaN(Number(value))) {
                return false;
            }
            return true;
        }
        checkArrayErrors() {
            if (!this.validationResult || this.validationResult.valid)
                return;
            const lbArrayError = this.querySelectorAll('[role="error"][array-scope]');
            lbArrayError.forEach(elm => {
                this.checkError(elm);
            });
        }
        checkError(lbError) {
            if (!lbError)
                return;
            const listItem = lbError.closest('[role="list-item"]');
            let error;
            if (!listItem) {
                error = this.validationResult?.errors.find(f => f.scope === lbError.getAttribute('array-scope'));
            }
            else {
                const parentArr = listItem.parentElement;
                if (!parentArr)
                    return;
                let arrIdx = -1;
                for (let i = 0; i < parentArr.childElementCount; i++) {
                    if (parentArr.childNodes[i] === listItem) {
                        arrIdx = i;
                        break;
                    }
                }
                if (arrIdx > -1) {
                    const arrayScope = `${lbError.getAttribute('array-scope')}_${arrIdx + 1}`;
                    error = this.validationResult?.errors.find(f => f.scope.endsWith(arrayScope));
                }
            }
            if (error) {
                lbError.setAttribute('is-visible', '');
                lbError.caption = `${this.getTranslatedText(lbError.getAttribute('array-caption')) || this.getTranslatedMessage('$this')} ${this.getTranslatedMessage(error.message)}`;
                lbError.visible = true;
            }
            else {
                lbError.removeAttribute('is-visible');
                lbError.caption = '';
                lbError.visible = false;
            }
        }
        findTabByElm(elm) {
            const wrapper = elm.closest('.content-pane');
            if (wrapper && this.contains(wrapper)) {
                const tabsContent = wrapper.closest('.tabs-content');
                if (tabsContent) {
                    let wrapperIdx = -1;
                    for (let i = 0; i < tabsContent.childElementCount; i++) {
                        if (wrapper === tabsContent.childNodes[i]) {
                            wrapperIdx = i;
                            break;
                        }
                    }
                    if (wrapperIdx > -1) {
                        const tabs = tabsContent.closest('i-tabs');
                        if (tabs) {
                            tabs.activeTabIndex = wrapperIdx;
                            this.findTabByElm(tabs);
                        }
                    }
                }
            }
        }
        renderForm() {
            this.clearInnerHTML();
            this._formRules = [];
            this._formControls = {};
            let controls;
            if (this._uiSchema) {
                this.renderFormByUISchema(this, this._uiSchema);
                this.setupRules();
            }
            else {
                this.renderFormByJSONSchema(this, this._jsonSchema);
            }
            // if (controls)
            //     this.appendChild(controls);
            const pnlButton = new layout_1.HStack(undefined, {
                justifyContent: 'end',
                alignItems: 'center',
                gap: 5,
                padding: {
                    top: 10,
                    bottom: 10
                }
            });
            if (!this._formOptions.confirmButtonOptions)
                this._formOptions.confirmButtonOptions = DEFAULT_OPTIONS.confirmButtonOptions;
            if (!this._formOptions.clearButtonOptions)
                this._formOptions.clearButtonOptions = DEFAULT_OPTIONS.clearButtonOptions;
            if (!this._formOptions.clearButtonOptions?.hide) {
                const btnClear = new button_1.Button(pnlButton, {
                    caption: this.convertToKey(this._formOptions.clearButtonOptions.caption || DEFAULT_OPTIONS.clearButtonOptions.caption),
                    font: {
                        color: this._formOptions.clearButtonOptions.fontColor || DEFAULT_OPTIONS.clearButtonOptions.fontColor,
                        transform: 'capitalize'
                    },
                    background: {
                        color: this._formOptions.clearButtonOptions.backgroundColor || DEFAULT_OPTIONS.clearButtonOptions.backgroundColor
                    },
                    padding: { top: '0.65rem', bottom: '0.65rem', left: '1rem', right: '1rem' },
                    border: { radius: '0px' }
                });
                btnClear.classList.add(Styles.buttonStyle);
                if (this._formOptions.clearButtonOptions?.onClick)
                    btnClear.onClick = this._formOptions.clearButtonOptions.onClick;
                else
                    btnClear.onClick = () => {
                        this.clearFormData();
                    };
                pnlButton.appendChild(btnClear);
            }
            if (!this._formOptions.confirmButtonOptions?.hide) {
                const btnConfirm = new button_1.Button(pnlButton, {
                    caption: this.convertToKey(this._formOptions.confirmButtonOptions.caption || DEFAULT_OPTIONS.confirmButtonOptions.caption),
                    font: {
                        color: this._formOptions.confirmButtonOptions.fontColor || DEFAULT_OPTIONS.confirmButtonOptions.fontColor,
                        transform: 'capitalize'
                    },
                    background: {
                        color: this._formOptions.confirmButtonOptions.backgroundColor || DEFAULT_OPTIONS.confirmButtonOptions.backgroundColor
                    },
                    padding: { top: '0.65rem', bottom: '0.65rem', left: '1rem', right: '1rem' },
                    border: { radius: '0px' }
                });
                btnConfirm.classList.add(Styles.buttonStyle);
                btnConfirm.onClick = async (target, event) => {
                    this.validationData = await this.getFormData();
                    this.validationResult = this.validate(this.validationData, this._jsonSchema, { changing: false });
                    this.isSubmitted = true;
                    await this.getFormData(true);
                    if (this.validationResult && !this.validationResult.valid && this.uiSchema) {
                        const firstErrorElement = this.querySelector('i-label[role="error"][is-visible]');
                        if (firstErrorElement) {
                            this.findTabByElm(firstErrorElement);
                        }
                    }
                    else if (this.validationResult?.valid && this._formOptions.confirmButtonOptions?.onClick) {
                        this._formOptions.confirmButtonOptions.onClick(target, event);
                    }
                    this.validationData = null;
                    this.validationResult = null;
                };
                pnlButton.appendChild(btnConfirm);
            }
            this.appendChild(pnlButton);
        }
        // Build form base on JSON Schema
        renderFormByJSONSchema(parent, schema, scope = '#', hideLabel = false, subLevel = false, options = {}) {
            if (!parent || !schema)
                return undefined;
            const { idx, schemaOptions, elementLabelProp, parentProp } = options;
            let labelProp = options.labelProp;
            const currentField = scope.substr(scope.lastIndexOf('/') + 1);
            if (elementLabelProp && elementLabelProp != currentField)
                labelProp = undefined;
            const labelName = schema.title || (scope != '#/' ? this.convertFieldNameToLabel(currentField) : '');
            const columnWidth = this._formOptions.columnWidth ? this._formOptions.columnWidth : '100px';
            const idxScope = idx !== undefined ? `${scope}_${idx}` : scope;
            const defaultValue = schema.default;
            let isRequired = false;
            let arrRequired = [];
            if (schema.required instanceof Array)
                arrRequired = schema.required;
            else
                isRequired = !!schema.required;
            const controlOptions = {
                caption: this.convertToKey(labelName),
                description: schema.description,
                tooltip: schema.tooltip ? this.convertToKey(schema.tooltip) : '',
                placeholder: schema.placeholder ? this.convertToKey(schema.placeholder) : '',
                columnWidth: columnWidth,
                readOnly: schema.readOnly,
                required: isRequired,
                hideLabel: hideLabel
            };
            // Check has custom control
            if (this._formOptions.customControls) {
                let customControlScope = parentProp ? `${parentProp}${scope.replace('#', '')}` : scope;
                if (customControlScope.includes('/items/properties')) {
                    customControlScope = this.replacePhrase(customControlScope);
                }
                if (this._formOptions.customControls[customControlScope]) {
                    const customRenderer = this._formOptions.customControls[customControlScope];
                    const wrapper = new layout_1.Panel(parent, {
                        width: controlOptions.columnWidth
                    });
                    wrapper.classList.add(Styles.formGroupStyle);
                    const control = customRenderer.render(parent);
                    control.setAttribute('custom-control', customControlScope);
                    control.setAttribute('field', scope.substr(scope.lastIndexOf('/') + 1));
                    control.setAttribute('role', 'field');
                    if (control.tagName === 'I-SCOM-TOKEN-INPUT') {
                        control.classList.add(Styles.tokenInputStyle);
                    }
                    control.onChanged = () => {
                        this.validateOnValueChanged(control, parent, customControlScope, labelName);
                        if (!this.isSubmitted && this._formOptions.onChange) {
                            this._formOptions.onChange(control, customRenderer.getData(control));
                        }
                    };
                    let label;
                    if (!hideLabel) {
                        label = this.renderLabel({ parent: wrapper, options: controlOptions, type: 'caption' });
                    }
                    const vstack = new layout_1.VStack(wrapper, { gap: 4 });
                    vstack.appendChild(control);
                    const error = this.renderLabel({ parent: vstack, options: controlOptions, type: 'error' });
                    this._formControls[customControlScope] = {
                        input: control,
                        getCustomData: () => customRenderer.getData(control),
                        label,
                        error
                    };
                    return;
                }
            }
            // Combo Box
            if ((schema.enum && schema.enum.length > 0) || (schema.oneOf && schema.oneOf.length > 0)) {
                let items = [];
                if (schema.oneOf && schema.oneOf.length > 0) {
                    items = schema.oneOf.map(item => {
                        let data = {
                            label: item.title || '',
                            value: item.const
                        };
                        if (item.description)
                            data.description = item.description;
                        if (item.icon)
                            data.icon = item.icon;
                        return data;
                    });
                }
                else if (schema.enum && schema.enum.length > 0) {
                    items = schema.enum.map(item => ({
                        label: item,
                        value: item
                    }));
                }
                if (schemaOptions?.format === "radio") {
                    items = items.map(v => ({
                        caption: this.convertToKey(v.label),
                        value: v.value
                    }));
                    return this.renderRadioGroup({ parent, scope, items, options: controlOptions, labelProp, defaultValue });
                }
                return this.renderComboBox({ parent, scope, items, options: controlOptions, labelProp, defaultValue });
            }
            else if (schema.type === 'string') {
                // Date Picker
                if (['date', 'time', 'date-time'].includes(schema.format || '')) {
                    let datePickerType = schema.format;
                    if (schema.format === 'date-time')
                        datePickerType = 'dateTime';
                    return this.renderDatePicker({ parent, scope, type: datePickerType || '', options: controlOptions, defaultValue });
                }
                // Uploader
                else if (schema.format === 'data-url') {
                    return this.renderUploader({ parent, scope, options: controlOptions, defaultValue });
                }
                // Uploader (IPFS)
                else if (schema.format === 'data-cid') {
                    return this.renderUploader({ parent, scope, options: controlOptions, defaultValue });
                }
                // Color Picker
                else if (schema.format === 'color') {
                    return this.renderColorPicker({ parent, scope, options: controlOptions, labelProp, defaultValue });
                }
                // Textarea
                else if (schemaOptions?.multi === true) {
                    return this.renderTextArea({ parent, scope, options: controlOptions, labelProp, defaultValue });
                }
                // Input
                else {
                    return this.renderInput({ parent, scope, options: controlOptions, labelProp, defaultValue });
                }
            }
            // Number Input
            else if (['integer', 'number'].includes(schema.type?.toString() || '')) {
                return this.renderNumberInput({ parent, scope, options: controlOptions, labelProp, defaultValue });
            }
            // Checkbox
            else if (schema.type === 'boolean') {
                return this.renderCheckBox({ parent, scope, options: controlOptions, labelProp, defaultValue });
            }
            // Group Box / Sublevel
            else if (schema.type === 'object') {
                const properties = schema.properties;
                if (!properties)
                    return undefined;
                let wrapperObj;
                let wrapper;
                let container;
                if (scope !== '#' && !subLevel) {
                    wrapperObj = this.renderGroup({ parent, options: controlOptions });
                    wrapper = wrapperObj.wrapper;
                    container = wrapperObj.body;
                }
                else {
                    wrapper = new layout_1.Panel(parent);
                    container = wrapper;
                }
                let form = new layout_1.GridLayout(container, {
                    gap: { column: 10, row: 10 },
                    columnsPerRow: this._formOptions.columnsPerRow || DEFAULT_OPTIONS.columnsPerRow
                });
                form.setAttribute('role', 'object');
                form.setAttribute('object-field', currentField);
                for (const propertyName in properties) {
                    let currentSchema = properties[propertyName];
                    if (!currentSchema?.required && arrRequired.includes(propertyName)) {
                        currentSchema.required = true;
                    }
                    this.renderFormByJSONSchema(form, currentSchema, `${idxScope}/properties/${propertyName}`, false, false, { idx, elementLabelProp, labelProp });
                }
                // if (scope !== '#' && wrapperObj && wrapperObj.body)
                //     wrapperObj.body.append(form);
                // else if (wrapper)
                //     wrapper.append(form);
                this._formControls[scope] = {
                    wrapper
                };
                return wrapper;
            }
            // Card List
            else if (schema.type === 'array') {
                if (!schema.items)
                    return undefined;
                const isVertical = schemaOptions?.detail?.type === 'VerticalLayout';
                const { body, btnAdd, columnHeader } = this.renderList({ parent, scope, options: controlOptions, isVertical, defaultValue });
                // Render list header
                if (typeof schema.items === 'object' && !(schema.items instanceof Array)) {
                    if (schema.items.type === 'object') {
                        const properties = schema.items.properties;
                        let hasSublevel = Object.values(properties).find((value) => value.type === 'object' || value.type === 'array');
                        if (!hasSublevel && !isVertical) {
                            // Render header
                            const templateColumns = [];
                            for (let i = 0; i < Object.values(properties).length; i++)
                                templateColumns.push('1fr');
                            templateColumns.push('50px');
                            const header = new layout_1.GridLayout(columnHeader, {
                                templateColumns,
                                gap: {
                                    column: 5,
                                    row: 5
                                }
                            });
                            header.classList.add(Styles.listColumnHeaderStyle);
                            for (const fieldName in properties) {
                                const property = properties[fieldName];
                                const caption = property.title || this.convertFieldNameToLabel(fieldName);
                                this.renderLabel({ parent: header, options: { caption, required: !!property.required } });
                            }
                        }
                    }
                    else {
                        body.setAttribute('non-object', 'true');
                    }
                }
                if (btnAdd) {
                    btnAdd.onClick = () => {
                        const lbError = btnAdd.parentElement?.querySelector('[role="error"][array-scope]');
                        if (lbError && lbError.hasAttribute('is-visible')) {
                            lbError.removeAttribute('is-visible');
                            lbError.caption = '';
                            lbError.visible = false;
                        }
                        if (schemaOptions && schemaOptions.detail) {
                            this.renderCard({ parent: body, scope, schema: schema.items, options: controlOptions, uiSchema: schemaOptions.detail, elementLabelProp: schemaOptions.elementLabelProp });
                        }
                        else if (schema.items instanceof Array) {
                            // Todo
                        }
                        else if (typeof schema.items === 'object') {
                            if (schema.items.type === 'object') {
                                // Grid
                                const properties = schema.items.properties;
                                if (!properties || (properties && Object.values(properties).length > 0)) {
                                    this.renderCard({ parent: body, scope, schema: schema.items, options: controlOptions });
                                }
                            }
                            else {
                                this.renderCard({ parent: body, scope, schema: schema.items, options: controlOptions });
                            }
                        }
                    };
                }
            }
            else if (schema.type === 'null') {
                return undefined;
            }
            else if (schema.type === 'any') {
                // To do
                return undefined;
            }
            else
                return undefined;
        }
        // Build form base on UI Schema
        renderFormByUISchema(parent, uiSchema, carryData, jsonSchema, elementLabelProp, labelProp, parentProp) {
            if (!parent || !uiSchema)
                return null;
            const { elements, type, scope, label, options, rule } = uiSchema;
            if (type === 'VerticalLayout') {
                const elm = new layout_1.VStack(parent, {
                    justifyContent: 'center',
                    alignItems: 'center'
                });
                if (elements)
                    elements.map(v => {
                        this.renderFormByUISchema(elm, v, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
                    });
                if (rule)
                    this._formRules.push({ elm, rule });
                return elm;
            }
            else if (type === 'HorizontalLayout') {
                const elm = new layout_1.GridLayout(parent, {
                    width: '100%',
                    gap: { column: 16 },
                    columnsPerRow: elements?.length || 1
                });
                if (elements)
                    elements.map(v => {
                        this.renderFormByUISchema(elm, v, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
                    });
                if (rule)
                    this._formRules.push({ elm, rule });
                return elm;
            }
            else if (type === 'Group') {
                const groupObj = this.renderGroup({ parent, options: {
                        required: false,
                        caption: this.convertToKey(typeof label === 'string' ? label : ''),
                        columnWidth: '100%',
                        description: '',
                        readOnly: false
                    }
                });
                if (elements) {
                    elements.map(v => {
                        if (groupObj.body)
                            this.renderFormByUISchema(groupObj.body, v, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
                    });
                }
                if (rule)
                    this._formRules.push({ elm: groupObj.wrapper, rule });
                return groupObj.wrapper;
                // return elm;
            }
            else if (type === 'Categorization') {
                let elm = new tab_1.Tabs(parent);
                elm.classList.add(Styles.tabsStyle);
                // elm.classList.add(jsonUITabStyle);
                // let formTabs = document.getElementById('formTabs') as Tabs;
                // if (formTabs) formTabs.visible = true;
                if (elements) {
                    for (let i = 0; i < elements.length; i++) {
                        const element = elements[i];
                        this.renderFormByUISchema(elm, element, { tabs: elm, index: i }, jsonSchema, elementLabelProp, labelProp, parentProp);
                    }
                    elm.activeTabIndex = 0;
                }
                // elm = formTabs;
                if (rule)
                    this._formRules.push({ elm, rule });
                return elm;
            }
            else if (type === 'Category') {
                let caption;
                if (label !== false) {
                    caption = label;
                }
                if (carryData && carryData.tabs && carryData.index != undefined) {
                    const children = new layout_1.Panel(undefined, {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    });
                    if (elements) {
                        for (const element of elements) {
                            let ui = this.renderFormByUISchema(children, element, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
                            if (ui)
                                children.append(ui);
                        }
                    }
                    let tabCaption = (typeof caption == 'boolean') ? '' : caption;
                    const tab = carryData.tabs.add({ caption: this.convertToKey(tabCaption || ''), children: children });
                    if (rule)
                        this._formRules.push({ elm: tab, rule });
                }
            }
            else if (type === 'Control' && scope) {
                const [key, dataSchema] = this.getDataSchemaByScope(scope, jsonSchema);
                const stub = new layout_1.Panel(parent, {
                    padding: {
                        left: 5,
                        right: 5,
                        top: 5,
                        bottom: 5
                    }
                });
                stub.classList.add('form-group');
                let caption, labelElm, descriptionElm;
                let formControlElm = new layout_1.Panel();
                formControlElm.classList.add('form-control');
                let hideLabel = false;
                if (label !== false) {
                    caption = label;
                    if (!caption)
                        caption = this.convertFieldNameToLabel(key);
                }
                this.renderFormByJSONSchema(formControlElm, dataSchema, scope, false, false, { schemaOptions: options, elementLabelProp, labelProp, parentProp });
                if (formControlElm)
                    stub.append(formControlElm);
                if (descriptionElm)
                    stub.append(descriptionElm);
                if (rule)
                    this._formRules.push({ elm: stub, rule, control: this._formControls[scope] });
                return stub;
            }
            else
                return null;
        }
        // Setup Rules
        setupRules() {
            if (!this._formRules || (this._formRules && this._formRules.length === 0))
                return;
            for (const ruleObj of this._formRules) {
                const { elm, rule, control: inputControl } = ruleObj;
                if (!elm)
                    continue;
                if (!rule)
                    continue;
                if (rule && (!rule.condition || !rule.effect))
                    continue;
                if (rule && rule.condition && (!rule.condition.scope || !rule.condition.schema))
                    continue;
                if (rule.condition?.scope) {
                    const control = this._formControls[rule.condition.scope].input;
                    if (!control)
                        continue;
                    this.setupControlRule(elm, rule.effect, control, rule.condition.schema, inputControl, this._formControls[rule.condition.scope].getCustomData);
                }
            }
            this.validateAllRule();
        }
        setupControlRule(elm, effect, control, schema, inputControl, getCustomData) {
            if (!elm || !effect || !control || !schema)
                return;
            if (control.tagName === 'I-INPUT') {
                let cachedOnChanged;
                if (control.onChanged)
                    cachedOnChanged = control.onChanged;
                control.onChanged = () => {
                    if (cachedOnChanged)
                        cachedOnChanged();
                    const value = control.value;
                    this.validateRule(elm, effect, value, schema, inputControl);
                };
            }
            else if (control.tagName === 'I-COMBO-BOX') {
                let cachedOnChanged;
                if (control.onChanged)
                    cachedOnChanged = control.onChanged;
                control.onChanged = () => {
                    if (cachedOnChanged)
                        cachedOnChanged();
                    const value = (control.selectedItem)?.value;
                    this.validateRule(elm, effect, value, schema, inputControl);
                };
            }
            else if (control.tagName === 'I-DATEPICKER') {
                let cachedOnChanged;
                if (control.onChanged)
                    cachedOnChanged = control.onChanged;
                control.onChanged = () => {
                    if (cachedOnChanged)
                        cachedOnChanged();
                    const value = control.value;
                    this.validateRule(elm, effect, value, schema, inputControl);
                };
            }
            else if (control.tagName === 'I-CHECKBOX') {
                let cachedOnChanged;
                if (control.onChanged)
                    cachedOnChanged = control.onChanged;
                control.onChanged = () => {
                    if (cachedOnChanged)
                        cachedOnChanged();
                    const value = control.checked;
                    this.validateRule(elm, effect, value, schema, inputControl);
                };
            }
            else if (control.tagName === 'I-RADIO-GROUP') {
                let cachedOnChanged;
                if (control.onChanged)
                    cachedOnChanged = control.onChanged;
                control.onChanged = () => {
                    if (cachedOnChanged)
                        cachedOnChanged();
                    const value = control.selectedValue;
                    this.validateRule(elm, effect, value, schema, inputControl);
                };
            }
            else if (getCustomData) {
                let cachedOnChanged;
                if (control.onChanged)
                    cachedOnChanged = control.onChanged;
                control.onChanged = () => {
                    if (cachedOnChanged)
                        cachedOnChanged();
                    const value = getCustomData();
                    this.validateRule(elm, effect, value, schema, inputControl);
                };
            }
        }
        validateRule(elm, effect, value, schema, inputControl) {
            let isValid = false;
            if (schema.const) {
                if (value === schema.const)
                    isValid = true;
            }
            else if (schema.enum) {
                const stringEnum = schema.enum.map((v) => v.toString());
                if (stringEnum.includes(value))
                    isValid = true;
            }
            else if (schema.not) {
                if (value !== schema.not.const.toString())
                    isValid = true;
                else if (schema.not.enum) {
                    const stringEnum = schema.not.enum.map((v) => v.toString());
                    if (stringEnum.includes(value))
                        isValid = true;
                }
            }
            if (effect === 'HIDE')
                elm.visible = !isValid;
            else if (effect === 'SHOW')
                elm.visible = isValid;
            else if (effect === 'ENABLE') {
                if (inputControl && inputControl.input) {
                    if (inputControl.input.tagName === 'I-COMBO-BOX') {
                        inputControl.input.readOnly = !isValid;
                    }
                    else
                        inputControl.input.enabled = isValid;
                }
                else
                    elm.enabled = isValid;
            }
            else if (effect === 'DISABLE') {
                if (inputControl && inputControl.input) {
                    if (inputControl.input.tagName === 'I-COMBO-BOX') {
                        inputControl.input.readOnly = isValid;
                    }
                    else
                        inputControl.input.enabled = !isValid;
                }
                else
                    elm.enabled = !isValid;
            }
        }
        validateAllRule() {
            if (!this._formRules || (this._formRules && this._formRules.length === 0))
                return;
            for (const ruleObj of this._formRules) {
                const { elm, rule, control: inputControl } = ruleObj;
                if (!elm)
                    continue;
                if (!rule)
                    continue;
                if (rule && (!rule.condition || !rule.effect))
                    continue;
                if (rule && rule.condition && (!rule.condition.scope || !rule.condition.schema))
                    continue;
                if (rule.condition?.scope) {
                    const formControl = this._formControls[rule.condition.scope];
                    const control = formControl.input;
                    if (!control)
                        continue;
                    let value;
                    if (control.tagName === 'I-INPUT') {
                        value = control.value;
                    }
                    else if (control.tagName === 'I-COMBO-BOX') {
                        value = (control.selectedItem)?.value;
                    }
                    else if (control.tagName === 'I-DATEPICKER') {
                        value = control.value;
                    }
                    else if (control.tagName === 'I-CHECKBOX') {
                        value = control.checked;
                    }
                    else if (control.tagName === 'I-RADIO-GROUP') {
                        value = control.selectedValue;
                    }
                    else if (formControl.getCustomData) {
                        value = formControl.getCustomData();
                    }
                    this.validateRule(elm, rule.effect, value, rule.condition.schema, inputControl);
                }
            }
        }
        getDataSchemaByScope(scope, jsonSchema) {
            const segments = scope.split('/');
            let obj = {};
            let preObj = {};
            let parentObj = {};
            for (const segment of segments) {
                parentObj = preObj;
                preObj = obj;
                if (segment === '#')
                    obj = jsonSchema || this._jsonSchema;
                else
                    obj = obj[segment];
            }
            const key = segments[segments.length - 1];
            if (obj == undefined)
                console.log('No corresponding scope:', scope);
            else if (!obj.required && typeof parentObj.required === 'object' && parentObj.required.includes(key)) {
                obj = {
                    ...obj,
                    required: true
                };
            }
            return [segments[segments.length - 1], obj];
        }
        // Render Controls
        renderGroup(groupOption) {
            const { parent, options } = groupOption;
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.groupStyle);
            const header = new layout_1.Panel(wrapper);
            header.classList.add(Styles.groupHeaderStyle);
            const hstack = new layout_1.HStack(header, { gap: 2 });
            new label_1.Label(hstack, { caption: this.convertToKey(options.caption || '') });
            if (options.required) {
                new label_1.Label(hstack, {
                    caption: '*',
                    font: { color: '#ff0000' }
                });
            }
            const icon = new icon_1.Icon(header, {
                name: 'chevron-up'
            });
            const body = new layout_1.Panel(wrapper);
            body.classList.add(Styles.groupBodyStyle);
            // Collapse
            icon.onClick = header.onClick = () => {
                body.visible = !body.visible;
                icon.name = `chevron-${body.visible ? 'up' : 'down'}`;
            };
            icon.classList.add(Styles.collapseBtnStyle);
            return { wrapper, body };
        }
        // private renderTabs(parent: Container, options: IControlOptions) {
        //     const tabs = new Tabs(parent);
        //     return tabs;
        // }
        //
        // private renderTab(tabs: Tabs, caption?: string) {
        //     if (!tabs)
        //         return null;
        //     return tabs.add({caption: caption || `Sheet ${tabs.items.length + 1}`});
        // }
        renderLabel(labelOption) {
            const { parent, options } = labelOption;
            let { type } = labelOption;
            if (!type)
                type = 'caption';
            let label;
            if (type === 'caption') {
                const hstack = new layout_1.HStack(parent, {
                    alignItems: 'center',
                    gap: 2,
                    width: '100%'
                });
                label = new label_1.Label(hstack, {
                    caption: this.convertToKey(options?.caption || '')
                });
                if (options.required) {
                    new label_1.Label(hstack, {
                        caption: '*',
                        font: { color: '#ff0000' }
                    });
                }
                if (options.tooltip) {
                    new icon_1.Icon(hstack, {
                        width: '1rem',
                        height: '1rem',
                        name: 'info-circle',
                        margin: { left: 2 },
                        tooltip: { content: this.convertToKey(options.tooltip), placement: 'bottom' }
                    });
                }
            }
            else if (type === 'description') {
                label = new label_1.Label(parent, {
                    caption: this.convertToKey(options.description || ''),
                    margin: { top: 2 },
                    visible: !!options.description
                });
            }
            else {
                label = new label_1.Label(parent, {
                    visible: false,
                    font: { color: '#ff0000' },
                    margin: { top: 2 }
                });
                label.setAttribute('role', 'error');
            }
            return label;
        }
        renderInput(inputOption) {
            const { parent, scope, options, labelProp, defaultValue } = inputOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent, {
                width: options.columnWidth
            });
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            const inputOpt = {
                inputType: 'text',
                height: '42px',
                width: '100%',
            };
            if (defaultValue) {
                inputOpt.value = defaultValue.toString();
            }
            const input = new input_1.Input(vstack, inputOpt);
            input.onChanged = () => {
                if (labelProp)
                    labelProp.caption = input.value;
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.value);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'string');
            if (options.readOnly !== undefined) {
                input.setAttribute('readOnly', options.readOnly.toString());
            }
            if (options.placeholder !== undefined) {
                const placeholderKey = this.convertToKey(options.placeholder);
                const placeholderText = this.parentModule?.i18n?.get(placeholderKey);
                input.setAttribute('placeholder', placeholderText || options.placeholder);
            }
            input.classList.add(Styles.inputStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            return wrapper;
        }
        renderNumberInput(numberInputOption) {
            const { parent, scope, options, labelProp, defaultValue } = numberInputOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent, { width: options.columnWidth });
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            const inputOpt = {
                inputType: 'number',
                height: '42px',
                width: '100%',
            };
            if (defaultValue) {
                const numDefaultValue = parseFloat(defaultValue);
                if (!isNaN(numDefaultValue))
                    inputOpt.value = numDefaultValue;
            }
            const input = new input_1.Input(vstack, inputOpt);
            input.onChanged = () => {
                if (labelProp)
                    labelProp.caption = input.value;
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.value);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'number');
            if (options.readOnly !== undefined) {
                input.setAttribute('readOnly', options.readOnly.toString());
            }
            if (options.placeholder !== undefined) {
                const placeholderKey = this.convertToKey(options.placeholder);
                const placeholderText = this.parentModule?.i18n?.get(placeholderKey);
                input.setAttribute('placeholder', placeholderText || options.placeholder);
            }
            input.classList.add(Styles.inputStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            return wrapper;
        }
        renderTextArea(textAreaOption) {
            const { parent, scope, options, labelProp, defaultValue } = textAreaOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper);
            const inputOpt = {
                inputType: 'textarea',
                height: 'unset',
                rows: 5
            };
            if (defaultValue) {
                inputOpt.value = defaultValue.toString();
            }
            const input = new input_1.Input(vstack, inputOpt);
            input.onChanged = () => {
                if (labelProp)
                    labelProp.caption = input.value;
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.value);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'string');
            if (options.readOnly !== undefined) {
                input.setAttribute('readOnly', options.readOnly.toString());
            }
            if (options.placeholder !== undefined) {
                const placeholderKey = this.convertToKey(options.placeholder);
                const placeholderText = this.parentModule?.i18n?.get(placeholderKey);
                input.setAttribute('placeholder', placeholderText || options.placeholder);
            }
            input.classList.add(Styles.inputStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            return wrapper;
        }
        renderColorPicker(colorPickerOption) {
            const { parent, scope, options, labelProp, defaultValue } = colorPickerOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            const inputOpt = {
                inputType: 'color',
                height: '42px',
                width: '100%'
            };
            if (defaultValue) {
                inputOpt.value = defaultValue.toString();
            }
            const input = new input_1.Input(vstack, inputOpt);
            input.onClosed = () => {
                if (labelProp)
                    labelProp.caption = input.value;
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.value);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'string');
            if (options.readOnly !== undefined) {
                input.setAttribute('readOnly', options.readOnly.toString());
            }
            input.classList.add(Styles.inputStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            return wrapper;
        }
        renderUploader(uploaderOption) {
            const { parent, scope, options, defaultValue } = uploaderOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            const uploader = new upload_1.Upload(vstack, {
                draggable: true
            });
            uploader.classList.add(Styles.uploadStyle);
            uploader.setAttribute('role', 'field');
            uploader.setAttribute('scope', scope);
            uploader.setAttribute('field', field);
            uploader.setAttribute('dataType', 'string');
            uploader.onChanged = () => {
                this.validateOnValueChanged(uploader, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(uploader);
                }
            };
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input: uploader,
                description,
                error
            };
            // if(defaultValue) {
            //
            // }
            return wrapper;
        }
        renderDatePicker(datePickerOption) {
            const { parent, scope, type, options, defaultValue } = datePickerOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            if (type != 'date' && type != 'time' && type != 'dateTime')
                return this.renderInput({ parent, scope, options, defaultValue });
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            let dateTimeFormat = '';
            if (type === 'date')
                dateTimeFormat = this._formOptions.dateTimeFormat?.date || DEFAULT_OPTIONS.dateTimeFormat.date;
            else if (type === 'dateTime')
                dateTimeFormat = this._formOptions.dateTimeFormat?.dateTime || DEFAULT_OPTIONS.dateTimeFormat.dateTime;
            else if (type === 'time')
                dateTimeFormat = this._formOptions.dateTimeFormat?.time || DEFAULT_OPTIONS.dateTimeFormat.time;
            let defaultDate;
            if (defaultValue) {
                defaultDate = (0, moment_1.moment)(defaultValue, dateTimeFormat);
            }
            const input = new datepicker_1.Datepicker(vstack, {
                type,
                height: '42px',
                dateTimeFormat,
                value: defaultDate || null
            });
            input.onChanged = () => {
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.value);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'string');
            input.classList.add(Styles.datePickerStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            // if(defaultValue) {
            //     input.setAttribute('value', defaultValue);
            // }
            return wrapper;
        }
        renderComboBox(comboBoxOption) {
            const { parent, scope, items, options, labelProp, defaultValue } = comboBoxOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            let matchItem;
            if (defaultValue) {
                matchItem = items.find(item => item.value.toString() === defaultValue.toString());
            }
            const input = new combo_box_1.ComboBox(vstack, {
                items,
                height: '42px',
                icon: {
                    name: 'caret-down'
                },
                selectedItem: matchItem || null
            });
            input.onChanged = () => {
                if (labelProp) {
                    // labelProp.caption = input.value;
                    // console.log('input.value', input.value)
                }
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, (input.selectedItem)?.value);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'string');
            if (options.readOnly !== undefined) {
                input.setAttribute('readOnly', options.readOnly.toString());
            }
            input.classList.add(Styles.comboBoxStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            return wrapper;
        }
        renderRadioGroup(radioGroupOption) {
            const { parent, scope, items, options, labelProp, defaultValue } = radioGroupOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            let label;
            if (!options.hideLabel) {
                label = this.renderLabel({ parent: wrapper, options, type: 'caption' });
            }
            const vstack = new layout_1.VStack(wrapper, { gap: 4 });
            const input = new radio_1.RadioGroup(vstack, {
                radioItems: items
            });
            input.onChanged = () => {
                if (labelProp) {
                    // labelProp.caption = input.value;
                    // console.log('input.value', input.selectedValue)
                }
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.selectedValue);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'string');
            // input.classList.add(Styles.radioGroupStyle)
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                label,
                input,
                description,
                error
            };
            if (defaultValue) {
                // input.selectedValue = defaultValue.toString();
                input.setAttribute('selectedValue', defaultValue.toString());
            }
            return wrapper;
        }
        renderCheckBox(checkBoxOption) {
            const { parent, scope, options, labelProp, defaultValue } = checkBoxOption;
            const field = scope.substr(scope.lastIndexOf('/') + 1);
            const wrapper = new layout_1.Panel(parent);
            wrapper.classList.add(Styles.formGroupStyle);
            const vstack = new layout_1.VStack(wrapper, { gap: 4, width: '100%' });
            const input = new checkbox_1.Checkbox(vstack, {
                caption: this.convertToKey(options.caption || '')
            });
            input.onChanged = () => {
                if (labelProp)
                    labelProp.caption = input.checked.toString();
                this.validateOnValueChanged(input, parent, scope, options?.caption);
                if (!this.isSubmitted && this._formOptions.onChange) {
                    this._formOptions.onChange(input, input.checked);
                }
            };
            input.setAttribute('role', 'field');
            input.setAttribute('scope', scope);
            input.setAttribute('field', field);
            input.setAttribute('dataType', 'boolean');
            if (options.readOnly !== undefined) {
                input.setAttribute('readOnly', options.readOnly.toString());
            }
            input.classList.add(Styles.checkboxStyle);
            const description = this.renderLabel({ parent: vstack, options, type: 'description' });
            const error = this.renderLabel({ parent: vstack, options, type: 'error' });
            this._formControls[scope] = {
                wrapper,
                input,
                description,
                error
            };
            if (defaultValue && typeof defaultValue === 'boolean') {
                // input.checked = defaultValue;
                input.setAttribute('checked', defaultValue.toString());
            }
            return wrapper;
        }
        renderList(listOption) {
            const { parent, scope, options, isVertical } = listOption;
            const wrapper = new layout_1.Panel(parent);
            const field = scope.split('/').pop() || '';
            wrapper.setAttribute('array-field', field);
            wrapper.setAttribute('role', 'array');
            // const header = new HStack(wrapper, {justifyContent: "space-between", alignItems: 'center'});
            const header = new layout_1.GridLayout(wrapper, { templateColumns: ['1fr', '80px'] });
            header.classList.add(Styles.listHeaderStyle);
            const hstack = new layout_1.HStack(header, { gap: 2 });
            new label_1.Label(hstack, { caption: this.convertToKey(options.caption || '') });
            if (options.required) {
                new label_1.Label(hstack, {
                    caption: '*',
                    font: { color: '#ff0000' }
                });
            }
            const btnAdd = new button_1.Button(header, { caption: '$add', font: { transform: 'capitalize' } });
            btnAdd.setAttribute('action', 'add');
            btnAdd.prepend(new icon_1.Icon(undefined, {
                name: 'plus',
                width: '1em',
                height: '1em',
                fill: theme.colors.primary.contrastText,
            }));
            btnAdd.classList.add(Styles.listBtnAddStyle);
            let lbError;
            if (options.required) {
                lbError = new label_1.Label(header, {
                    visible: false,
                    font: { color: '#ff0000', bold: false },
                    margin: { top: 2 }
                });
                lbError.setAttribute('role', 'error');
                lbError.setAttribute('array-scope', this.replacePhrase(scope));
                lbError.setAttribute('array-caption', options.caption || '');
            }
            const columnHeader = new layout_1.VStack(wrapper);
            const body = new layout_1.VStack(wrapper, {
                gap: 10
            });
            if (isVertical) {
                body.setAttribute('layout', 'Vertical');
                body.classList.add(Styles.listVerticalLayoutStyle);
            }
            this._formControls[scope] = {
                wrapper,
                error: lbError,
                input: body
            };
            return {
                wrapper,
                columnHeader,
                body,
                btnAdd
            };
        }
        renderCard(cardOption) {
            const { parent, scope, schema, options, uiSchema, elementLabelProp, btnAdd } = cardOption;
            if (!schema.type)
                return;
            const isVertical = parent.getAttribute('layout') === 'Vertical';
            const setEnableBtnAdd = () => {
                if (schema.maxItems) {
                    let _btnAdd = btnAdd || parent.parentElement?.querySelector('[action="add"]');
                    if (_btnAdd) {
                        _btnAdd.enabled = parent.childElementCount < schema.maxItems;
                    }
                }
            };
            if (schema.type === 'object') {
                const properties = schema.properties;
                let hasSubLevel = !!Object.values(properties).find((value) => value.type === 'object' || value.type === 'array');
                if (!hasSubLevel) {
                    const templates = [];
                    for (let i = 0; i < Object.values((properties)).length; i++) {
                        templates.push('1fr');
                    }
                    if (!isVertical) {
                        templates.push('50px');
                    }
                    const row = new layout_1.GridLayout(parent, {
                        // templateRows: isVertical ? templates : undefined,
                        templateColumns: isVertical ? undefined : templates,
                        gap: {
                            column: 5,
                            row: isVertical ? 8 : 5
                        },
                        verticalAlignment: isVertical ? undefined : 'start',
                        alignItems: isVertical ? undefined : 'center',
                        justifyContent: isVertical ? undefined : 'center'
                    });
                    row.classList.add(Styles.listItemStyle);
                    row.setAttribute('role', 'list-item');
                    if (isVertical) {
                        const btnDelete = new icon_1.Icon(row, {
                            name: 'times',
                            margin: { left: 'auto' }
                        });
                        btnDelete.classList.add(Styles.listItemBtnDelete);
                        btnDelete.onClick = () => {
                            row.remove();
                            setEnableBtnAdd();
                            if (this._formOptions.onChange) {
                                this._formOptions.onChange(parent);
                            }
                        };
                        for (const fieldName in properties) {
                            const property = properties[fieldName];
                            this.renderFormByJSONSchema(row, property, `#/properties/${fieldName}`, false, false, { parentProp: scope });
                        }
                    }
                    else {
                        for (const fieldName in properties) {
                            const property = properties[fieldName];
                            this.renderFormByJSONSchema(row, property, `#/properties/${fieldName}`, !hasSubLevel, false, { parentProp: scope });
                        }
                        const btnDelete = new icon_1.Icon(row, {
                            name: 'trash'
                        });
                        btnDelete.classList.add(Styles.listItemBtnDelete);
                        btnDelete.onClick = () => {
                            row.remove();
                            if (this._formOptions.onChange) {
                                this._formOptions.onChange(parent);
                            }
                            setEnableBtnAdd();
                        };
                    }
                }
                else {
                    const card = new layout_1.Panel(parent);
                    card.classList.add(Styles.cardStyle);
                    card.setAttribute('role', 'list-item');
                    const headerStack = new layout_1.GridLayout(card, { gap: { column: 5, row: 5 }, templateColumns: ['1fr', '30px', '30px'] });
                    headerStack.classList.add(Styles.cardHeader);
                    const bodyStack = new layout_1.VStack(card);
                    bodyStack.classList.add(Styles.cardBody);
                    // const badgeRowNum = new Label(headerStack, {caption: (parent.querySelectorAll('[role="list-item"]')?.length) || 1});
                    const pnlElmLabel = new layout_1.Panel(headerStack);
                    const labelProp = new label_1.Label(pnlElmLabel);
                    const btnDelete = new icon_1.Icon(headerStack, { name: 'trash' });
                    const btnCollapse = new icon_1.Icon(headerStack, { name: 'chevron-down' });
                    btnCollapse.onClick = headerStack.onClick = () => {
                        bodyStack.visible = !bodyStack.visible;
                        btnCollapse.name = `chevron-${bodyStack.visible ? 'up' : 'down'}`;
                    };
                    btnDelete.classList.add(Styles.listItemBtnDelete);
                    btnDelete.onClick = () => {
                        card.remove();
                        if (this._formOptions.onChange) {
                            this._formOptions.onChange(parent);
                        }
                        setEnableBtnAdd();
                    };
                    btnCollapse.classList.add(Styles.listItemBtnDelete);
                    if (uiSchema && uiSchema.elements) {
                        this.renderFormByUISchema(bodyStack, uiSchema, null, schema, elementLabelProp, labelProp);
                    }
                    else {
                        this.renderFormByJSONSchema(bodyStack, schema, `${scope}/items`, true, hasSubLevel, { elementLabelProp, parentProp: scope });
                    }
                }
            }
            else {
                const templateColumns = ['1fr', '50px'];
                const row = new layout_1.GridLayout(parent, {
                    templateColumns,
                    gap: {
                        column: 5,
                        row: 5
                    },
                    verticalAlignment: 'center',
                    alignItems: 'center',
                    justifyContent: 'center'
                });
                row.classList.add(Styles.listItemStyle);
                row.setAttribute('role', 'list-item');
                this.renderFormByJSONSchema(row, schema, `${scope}/items`, true);
                const btnDelete = new icon_1.Icon(row, {
                    name: 'trash'
                });
                btnDelete.classList.add(Styles.listItemBtnDelete);
                btnDelete.onClick = () => {
                    row.remove();
                    if (this._formOptions.onChange) {
                        this._formOptions.onChange(parent);
                    }
                    setEnableBtnAdd();
                };
            }
            setEnableBtnAdd();
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
        }
        getTranslatedMessage(value) {
            if (!this.i18nMessage)
                return value;
            if (typeof value === 'string' && value.startsWith('$')) {
                this.i18nMessage.get(value);
            }
            return value;
        }
        getTranslatedText(value) {
            if (typeof value === 'string' && value.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(value) ||
                    application_1.default.i18n?.get(value) ||
                    value;
                return translated;
            }
            return value;
        }
        checkPropertyChange(value, schema, property) {
            return this.validate(value, schema, { changing: property || 'property' });
        }
        mustBeValid(result) {
            if (!result.valid) {
                throw new TypeError(result.errors.map(function (error) {
                    return 'for property ' + error.property + ': ' + error.message;
                }).join(', \n'));
            }
        }
        validate(instance, schema, options) {
            if (!options)
                options = {};
            const i18nMessage = this.i18nMessage;
            var _changing = options.changing;
            function getType(schema) {
                return schema.type;
            }
            var errors = [];
            // validate a value against a property definition
            function checkProp(value, schema, path, scope, i, isNonObjArrayItem) {
                if (isNonObjArrayItem && typeof i === 'number') {
                    // array's item is not object
                    if (typeof (value) === 'object') {
                        value = value[Object.keys(value)[0]];
                        // if the value is null, it will be NaN. NaN can't be checked
                        if (isNaN(value) && (schema.type === 'number' || schema.type === 'integer'))
                            value = '';
                    }
                    scope = scope + '_' + (i + 1).toString();
                }
                else {
                    // array's item is object
                    const parsedPath = path.split('.');
                    let parsedScope = scope.split('/');
                    let parentProp = '';
                    if (parsedScope.length > 1) {
                        parsedScope = parsedScope.splice(0, parsedScope.length - 2);
                        parentProp = parsedScope[parsedScope.length - 1].split('_')[0];
                    }
                    let idxOfArray = -1;
                    parsedPath.forEach((value) => {
                        if (value.includes(parentProp)) {
                            let matches = value.match(/\[(.*?)\]/);
                            if (matches)
                                idxOfArray = parseInt(matches[1]) + 1;
                        }
                    });
                    if (idxOfArray > 0 && getType(schema) != 'object') {
                        scope = scope + '_' + idxOfArray;
                    }
                }
                var l;
                path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
                function addError(message, scope, overwritePath) {
                    errors.push({ property: overwritePath || path, scope: scope, message: message });
                }
                if ((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))) {
                    if (typeof schema == 'function') {
                        if (!(value instanceof schema)) {
                            addError(i18nMessage.get('$is_not_an_instance_of_the_class/constructor_name', { name: schema.name }), scope);
                        }
                    }
                    else if (schema) {
                        addError(i18nMessage.get('$invalid_schema/property_definition_name', { name: schema }), scope);
                    }
                    return null;
                }
                if (_changing && schema.readOnly) {
                    addError(i18nMessage.get('$is_a_readonly_field_it_can_not_be_changed'), scope);
                }
                if (schema.extends) { // if it extends another schema, it must pass that schema as well
                    checkProp(value, schema.extends, path, scope, i);
                }
                // validate a value against a type definition
                function checkType(type, value, scope) {
                    if (type) {
                        if (type == 'string' && value instanceof moment_1.moment)
                            return [];
                        if (type != 'any' &&
                            (type == 'null' ? value !== null : typeof value != type) &&
                            !(value instanceof Array && type == 'array') &&
                            // !(value instanceof Date && type == 'date') &&
                            typeof type == 'string' &&
                            !(type == 'integer' && value % 1 === 0)) {
                            return [{
                                    property: path,
                                    scope: scope,
                                    message: value + ' - ' + (typeof value) + ' value found, but a ' + type + ' is required'
                                }];
                        }
                        if (type instanceof Array) {
                            let unionErrors = [];
                            for (var j = 0; j < type.length; j++) { // a union type
                                if (!(unionErrors = checkType(type[j], value, scope)).length) {
                                    break;
                                }
                            }
                            if (unionErrors.length) {
                                return unionErrors;
                            }
                        }
                        else if (typeof type == 'object') {
                            var priorErrors = errors;
                            errors = [];
                            checkProp(value, type, path, scope);
                            var theseErrors = errors;
                            errors = priorErrors;
                            return theseErrors;
                        }
                    }
                    return [];
                }
                const isEmptyValue = value === undefined || value === '' || (value instanceof Array && (!value.length || value.findIndex(v => v === undefined || v === '') !== -1) && schema.items?.type === 'object');
                if (isEmptyValue) {
                    if (schema.required && typeof schema.required === 'boolean') {
                        // addError("is missing and it is required", scope + '_' + idxOfArray);
                        addError(i18nMessage.get('$is_missing_and_it_is_required'), scope);
                    }
                }
                else {
                    // Check if required is an array and type is object
                    if (getType(schema) === 'object' && schema.required instanceof Array) {
                        for (let requiredField of schema.required) {
                            if (value[requiredField] === undefined || value[requiredField] === '' || (value[requiredField] instanceof Array && !value[requiredField].length)) {
                                addError(i18nMessage.get('$is_missing_and_it_is_required'), scope + '/properties/' + requiredField, requiredField);
                            }
                        }
                    }
                    errors = errors.concat(checkType(getType(schema), value, scope));
                    if (schema.disallow && !checkType(schema.disallow, value, scope).length) {
                        addError(i18nMessage.get('$disallowed_value_was_matched'), scope);
                    }
                    if (value !== null) {
                        if (value instanceof Array) {
                            if (schema.items) {
                                var itemsIsArray = schema.items instanceof Array;
                                var propDef = schema.items;
                                for (i = 0, l = value.length; i < l; i += 1) {
                                    if (itemsIsArray)
                                        propDef = schema.items[i];
                                    if (options.coerce)
                                        value[i] = options.coerce(value[i], propDef);
                                    if (schema.items.type == 'object') {
                                        var errors2 = checkProp(value[i], propDef, path, scope, i);
                                        if (errors2)
                                            errors.concat(errors2);
                                    }
                                }
                            }
                            if (schema.minItems && value.length < schema.minItems) {
                                addError(i18nMessage.get('$There_must_be_a_minimum_of_number_in_the_array', { number: schema.minItems }), scope);
                            }
                            if (schema.maxItems && value.length > schema.maxItems) {
                                addError(i18nMessage.get('$There_must_be_a_maximum_of_number_in_the_array', { number: schema.maxItems }), scope);
                            }
                        }
                        else if (schema.properties || schema.additionalProperties) {
                            errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties, scope));
                        }
                        if (schema.items && schema.items.type != 'object') {
                            // schema has items and Non-obj array
                            const itemSchema = { required: schema.required, ...schema.items };
                            if (schema.items.type === 'array' && value instanceof Array) {
                                checkProp(value, itemSchema, path, scope);
                            }
                            else {
                                for (let i = 0; i < value.length; i++) {
                                    checkProp(value[i], itemSchema, path, scope, i, true);
                                }
                            }
                        }
                        if (schema.pattern && typeof value == 'string' && !value.match(schema.pattern)) {
                            addError(i18nMessage.get('$does_not_match_the_regex_pattern_name', { name: schema.pattern }), scope);
                        }
                        if (schema.maxLength && typeof value == 'string' && value.length > schema.maxLength) {
                            addError(i18nMessage.get('$may_only_be_length_characters_long', { length: schema.maxLength }), scope);
                        }
                        if (schema.minLength && typeof value == 'string' && value.length < schema.minLength) {
                            addError(i18nMessage.get('$must_be_at_least_length_characters_long', { length: schema.minLength }), scope);
                        }
                        if (typeof schema.minimum !== 'undefined' && typeof value == typeof schema.minimum &&
                            schema.minimum > value) {
                            addError(i18nMessage.get('$must_have_a_minimum_value_of_number', { number: schema.minimum }), scope);
                        }
                        if (typeof schema.maximum !== 'undefined' && typeof value == typeof schema.maximum &&
                            schema.maximum < value) {
                            addError(i18nMessage.get('$must_have_a_maximum_value_of_number', { number: schema.maximum }), scope);
                        }
                        if (schema['enum']) {
                            var enumer = schema['enum'];
                            l = enumer.length;
                            var found;
                            for (var j = 0; j < l; j++) {
                                if (enumer[j] === value) {
                                    found = 1;
                                    break;
                                }
                            }
                            if (!found) {
                                addError(i18nMessage.get('$does_not_have_a_value_in_the_enumeration_enumer', { enumer: enumer.join(', ') }), scope);
                            }
                        }
                        if (typeof schema.maxDecimal == 'number' &&
                            (value.toString().match(new RegExp('\\.[0-9]{' + (schema.maxDecimal + 1) + ',}')))) {
                            addError(i18nMessage.get('$may_only_have_number_digits_of_decimal_places', { number: schema.maxDecimal }), scope);
                        }
                        // Todo: Additional validations
                        if (value !== '') {
                            if (schema.format === 'wallet-address') {
                                const regex = new RegExp('^((0x[a-fA-F0-9]{40})|([13][a-km-zA-HJ-NP-Z1-9]{25,34})|(X[1-9A-HJ-NP-Za-km-z]{33})|(4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}))$');
                                if (!regex.test(value))
                                    addError(i18nMessage.get('$is_not_a_valid_wallet_address'), scope);
                            }
                            else if (schema.format === 'cid') {
                                const regex = new RegExp('^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$');
                                if (!regex.test(value))
                                    addError(i18nMessage.get('$is_not_a_valid_cid'), scope);
                            }
                            else if (schema.format === 'cid-v0') {
                                const regex = new RegExp('^(Qm[1-9A-HJ-NP-Za-km-z]{44,})$');
                                if (!regex.test(value))
                                    addError(i18nMessage.get('$is_not_a_valid_version_0_cid'), scope);
                            }
                            else if (schema.format === 'cid-v1') {
                                const regex = new RegExp('^(b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$');
                                if (!regex.test(value))
                                    addError(i18nMessage.get('$is_not_a_valid_version_1_cid'), scope);
                            }
                            else if (schema.format === 'uuid') {
                                const regex = new RegExp('^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$');
                                if (!regex.test(value))
                                    addError(i18nMessage.get('$is_not_a_valid_uuid'), scope);
                            }
                            else if (schema.format === 'url') {
                                const regex = new RegExp('^(https?|ftp)://[a-zA-Z0-9.-]+.[a-zA-Z]{2,}(?:/[^s]*)?$');
                                if (!regex.test(value))
                                    addError(i18nMessage.get('$is_not_a_valid_URL'), scope);
                            }
                        }
                    }
                }
                return null;
            }
            // validate an object against a schema
            function checkObj(instance, objTypeDef, path, additionalProp, scope) {
                if (typeof objTypeDef == 'object') {
                    if (typeof instance != 'object' || instance instanceof Array) {
                        errors.push({ property: path, scope: scope, message: 'an object is required' });
                    }
                    for (var i in objTypeDef) {
                        if (objTypeDef.hasOwnProperty(i) && i != '__proto__' && i != 'constructor') {
                            var value = instance.hasOwnProperty(i) ? instance[i] : undefined;
                            // skip _not_ specified properties
                            if (value === undefined && options.existingOnly)
                                continue;
                            var propDef = objTypeDef[i];
                            // set default
                            if (value === undefined && propDef['default']) {
                                value = instance[i] = propDef['default'];
                            }
                            if (options.coerce && i in instance) {
                                value = instance[i] = options.coerce(value, propDef);
                            }
                            checkProp(value, propDef, path, scope + '/properties/' + i, i);
                        }
                    }
                }
                for (i in instance) {
                    if (instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp === false) {
                        if (options.filter) {
                            delete instance[i];
                            continue;
                        }
                        else {
                            errors.push({
                                property: path, message: 'The property ' + i +
                                    ' is not defined in the schema and the schema does not allow additional properties',
                                scope: scope
                            });
                        }
                    }
                    var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
                    if (requires && !(requires in instance)) {
                        errors.push({
                            property: path,
                            scope: scope,
                            message: 'the presence of the property ' + i + ' requires that ' + requires + ' also be present'
                        });
                    }
                    value = instance[i];
                    if (additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))) {
                        if (options.coerce) {
                            value = instance[i] = options.coerce(value, additionalProp);
                        }
                        checkProp(value, additionalProp, path, scope + '/properties/' + i, i);
                    }
                    if (!_changing && value && value.$schema) {
                        const errors2 = checkProp(value, value.$schema, path, scope + '/properties/' + i, i);
                        if (errors2)
                            errors = errors.concat(errors2);
                    }
                }
                return errors;
            }
            const root = '#';
            if (schema) {
                checkProp(instance, schema, '', root, _changing || '');
            }
            if (!_changing && instance && instance.$schema) {
                checkProp(instance, instance.$schema, '', root, '');
            }
            return { valid: !errors.length, errors: errors };
        }
        ;
        // Utils
        convertFieldNameToLabel(name) {
            let label = '';
            for (let i = 0; i < name.length; i++) {
                let char = name[i];
                if (i == 0) {
                    label += char.toUpperCase();
                    continue;
                }
                if (char == char.toUpperCase())
                    label += ` ${char}`;
                else
                    label += char;
            }
            return label;
        }
        convertToKey(value) {
            if (!value)
                return '';
            if (value.startsWith('$'))
                return value;
            const str = value.toLowerCase().replace(/\s/g, '_');
            return `$${str}`;
        }
        setDataUpload(url, control) {
            if (!url || !control)
                return;
            const getImageTypeFromUrl = (url) => {
                const extension = url.match(/\.([^.]+)$/);
                switch (extension && extension[1].toLowerCase()) {
                    case 'jpg':
                    case 'jpeg':
                        return 'image/jpeg';
                    case 'gif':
                        return 'image/gif';
                    case 'svg':
                        return 'image/svg';
                    default:
                        return 'image/png';
                }
            };
            const getExtensionFromType = (fileType) => {
                return fileType.split('/')[1];
            };
            try {
                let imgUrl = url;
                const regex = new RegExp('^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$');
                if (regex.test(url)) {
                    // cid
                    imgUrl = IPFS_Gateway + imgUrl;
                }
                else if (url.startsWith('ipfs://')) {
                    imgUrl = imgUrl.replace('ipfs://', IPFS_Gateway);
                }
                fetch(imgUrl)
                    .then(response => response.arrayBuffer())
                    .then(async (arrayBuffer) => {
                    const fileType = getImageTypeFromUrl(imgUrl);
                    const blob = new Blob([arrayBuffer], { type: fileType });
                    const fileName = `image-${Date.now()}.${getExtensionFromType(fileType)}`;
                    const file = new File([blob], fileName, { type: fileType });
                    file.cid = await (0, ipfs_1.hashFile)(file);
                    control.fileList = [file];
                    control.preview(imgUrl);
                });
            }
            catch {
                control.fileList = [];
            }
        }
    };
    Form = __decorate([
        (0, base_1.customElements)('i-form', {
            props: {},
            events: {}
        })
    ], Form);
    exports.Form = Form;
});
define("@ijstech/form", ["require", "exports", "@ijstech/form/form.ts"], function (require, exports, form_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Form = void 0;
    Object.defineProperty(exports, "Form", { enumerable: true, get: function () { return form_1.Form; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/repeater/style/repeater.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    Styles.cssRule('i-repeater', {
        display: 'block',
        width: '100%',
        $nest: {
            '.repeater-container': {
                display: 'flex'
            }
        }
    });
});
define("@ijstech/repeater/repeater.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/types", "@ijstech/repeater/style/repeater.css.ts"], function (require, exports, base_1, layout_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Repeater = void 0;
    const DEFAULT_VALUES = {
        layout: 'vertical',
        count: 0,
        gap: 0
    };
    const layoutOptions = ['horizontal', 'vertical'];
    let Repeater = class Repeater extends base_1.Container {
        constructor(parent, options) {
            super(parent, options);
            this._data = [];
            this._layout = 'vertical';
        }
        get count() {
            return this._count ?? DEFAULT_VALUES.count;
        }
        set count(value) {
            this._count = value ?? DEFAULT_VALUES.count;
            this.cloneItems();
        }
        set data(value) {
            this._data = value || [];
            this.count = value?.length || 0;
            this.cloneItems();
        }
        get data() {
            return this._data || [];
        }
        get layout() {
            return this._layout;
        }
        set layout(value) {
            this._layout = value;
            const direction = value === 'horizontal' ? 'row' : 'column';
            if (this.wrapper) {
                this.wrapper.style.flexDirection = direction;
            }
        }
        get gap() {
            return this._gap;
        }
        set gap(value) {
            if (!this.wrapper)
                return;
            this._gap = value || 'initial';
            const num = +this._gap;
            if (!isNaN(num)) {
                this.wrapper.style.gap = this._gap + 'px';
            }
            else {
                this.wrapper.style.gap = `${this._gap}`;
            }
        }
        get justifyContent() {
            return this._justifyContent;
        }
        set justifyContent(value) {
            this._justifyContent = value || 'start';
            if (this.wrapper) {
                this.wrapper.style.justifyContent = this._justifyContent;
            }
        }
        get alignItems() {
            return this._alignItems;
        }
        set alignItems(value) {
            this._alignItems = value || 'stretch';
            if (this.wrapper) {
                this.wrapper.style.alignItems = this._alignItems;
            }
        }
        foreachNode(node, clonedNode) {
            if (!node)
                return;
            if (typeof node?._getCustomProperties === 'function') {
                const props = node._getCustomProperties().props || {};
                const keys = Object.keys(props);
                for (let key of keys) {
                    const value = node._getDesignPropValue(key) ?? node.getAttribute(key);
                    if (!this.isEmpty(key, value)) {
                        if (clonedNode) {
                            clonedNode[key] = value;
                        }
                    }
                }
            }
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const clonedChild = clonedNode?.children[i];
                if (child.hasChildNodes()) {
                    this.foreachNode(child, clonedChild);
                }
            }
        }
        isEmpty(key, value) {
            return value === undefined ||
                value === null ||
                (typeof value === 'object' && !Object.keys(value).length) ||
                ((key === 'link' || key === 'image') && !value?.url) ||
                ((key === 'icon' || key === 'rightIcon') && (!value?.name || !value?.image?.url)) ||
                key === 'caption';
        }
        cloneItems() {
            if (this._designMode)
                return;
            this.wrapper.innerHTML = '';
            if (!this.templateEl.content || !this.count)
                return;
            for (let i = 0; i < this.count; i++) {
                const clone = document.importNode(this.templateEl.content, true);
                this.wrapper.appendChild(clone);
                const newControl = this.wrapper.lastElementChild;
                this.foreachNode(this.templateEl.content.firstChild, newControl);
                if (newControl && 'setData' in newControl) {
                    newControl.setData(this._data[i]);
                }
                if (typeof this.onRender === 'function')
                    this.onRender(this.wrapper, i);
            }
        }
        add(item) {
            // if (!this.pnlPanel) {
            //   this.pnlPanel = new Panel(undefined, {});
            // }
            // this.pnlPanel.appendChild(item);
            if (this._designMode) {
                this.wrapper.innerHTML = '';
                this.wrapper.append(item);
            }
            else {
                this.templateEl.innerHTML = '';
                this.templateEl.content.append(item);
            }
            this.cloneItems();
            return item;
        }
        update() {
            this.cloneItems();
        }
        clear() {
            this.wrapper.innerHTML = '';
        }
        init() {
            if (!this.initialized) {
                let childNodes = [];
                for (let i = 0; i < this.childNodes.length; i++) {
                    const el = this.childNodes[i];
                    childNodes.push(el);
                }
                this.onRender = this.getAttribute("onRender", true) || this.onRender;
                const count = this.getAttribute("count", true, DEFAULT_VALUES.count);
                const data = this.getAttribute("data", true);
                super.init();
                this.wrapper = this.createElement("div", this);
                this.wrapper.classList.add("repeater-container");
                this.layout = this.getAttribute("layout", true, DEFAULT_VALUES.layout);
                this.gap = this.getAttribute("gap", true, DEFAULT_VALUES.gap);
                this.justifyContent = this.getAttribute("justifyContent", true);
                this.alignItems = this.getAttribute("alignItems", true);
                this.templateEl = this.createElement("template", this);
                if (childNodes?.length) {
                    let templateEl = childNodes[0];
                    if (childNodes.length > 1) {
                        templateEl = new layout_1.Panel(undefined, {});
                        for (let i = 0; i < childNodes.length; i++) {
                            templateEl.appendChild(childNodes[i]);
                        }
                    }
                    if (this._designMode) {
                        this.wrapper.append(templateEl);
                    }
                    else {
                        this.templateEl.content.append(templateEl);
                    }
                }
                this.count = data?.length || count;
            }
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
    };
    __decorate([
        (0, base_1.observable)('data', true)
    ], Repeater.prototype, "_data", void 0);
    Repeater = __decorate([
        (0, base_1.customElements)("i-repeater", {
            icon: 'clone',
            group: types_1.GroupType.BASIC,
            className: 'Repeater',
            props: {
                count: {
                    type: 'number',
                    default: DEFAULT_VALUES.count
                },
                layout: {
                    type: 'string',
                    default: DEFAULT_VALUES.layout,
                    values: layoutOptions
                },
                gap: {
                    type: 'number'
                },
                justifyContent: { type: 'string', default: '' },
                alignItems: { type: 'string', default: '' }
            },
            events: {
                onRender: [
                    { name: 'parent', type: 'Control', isControl: true },
                    { name: 'index', type: 'number' }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    count: {
                        type: 'number',
                        default: DEFAULT_VALUES.count
                    },
                    layout: {
                        type: 'string',
                        default: DEFAULT_VALUES.layout,
                        enum: layoutOptions
                    },
                    gap: {
                        type: 'number'
                    }
                }
            }
        })
    ], Repeater);
    exports.Repeater = Repeater;
});
define("@ijstech/repeater", ["require", "exports", "@ijstech/repeater/repeater.ts"], function (require, exports, repeater_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Repeater = void 0;
    Object.defineProperty(exports, "Repeater", { enumerable: true, get: function () { return repeater_1.Repeater; } });
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("@ijstech/accordion/interface.ts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("@ijstech/accordion/style/accordion.css.ts", ["require", "exports", "@ijstech/style"], function (require, exports, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expandablePanelStyle = exports.customStyles = void 0;
    Styles.cssRule("i-accordion", {
        display: 'block',
        $nest: {},
    });
    exports.customStyles = Styles.style({
        $nest: {
            '.accordion-body': {
                transition: 'height 0.4s ease-in',
                height: 0,
                overflow: 'hidden'
            },
            '&.expanded > .accordion-body': {
                height: 'auto'
            },
            '.accordion-header': {
                $nest: {
                    'i-label': {
                        fontSize: 'inherit'
                    }
                }
            }
        }
    });
    exports.expandablePanelStyle = Styles.style({
        $nest: {
            'i-panel': {
                border: 'none'
            }
        }
    });
});
define("@ijstech/accordion/accordion-item.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/label", "@ijstech/icon", "@ijstech/style", "@ijstech/accordion/style/accordion.css.ts", "@ijstech/types", "@ijstech/application"], function (require, exports, base_1, layout_1, label_1, icon_1, style_1, accordion_css_1, types_1, application_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccordionItem = void 0;
    const defaultIcon = {
        width: 16,
        height: 16,
        fill: style_1.Theme.ThemeVars.text.primary
    };
    let AccordionItem = class AccordionItem extends base_1.Container {
        constructor(parent, options) {
            super(parent, options);
        }
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            if (this.lbTitle && this._name?.startsWith('$'))
                this.lbTitle.caption = i18n.get(this._name) || '';
        }
        get name() {
            const name = this._name || '';
            if (name?.startsWith('$')) {
                const translated = this.parentModule?.i18n?.get(name) ||
                    application_1.application.i18n?.get(name) ||
                    '';
                return translated;
            }
            return name;
        }
        set name(value) {
            if (typeof value !== 'string')
                value = String(value || '');
            this._name = value;
            if (this.lbTitle) {
                this.lbTitle.caption = this.name;
            }
        }
        get icon() {
            if (!this._icon) {
                this._icon = new icon_1.Icon(undefined, defaultIcon);
                if (this.pnlTitle)
                    this.pnlTitle.prepend(this._icon);
            }
            return this._icon;
        }
        set icon(value) {
            if (this.pnlTitle) {
                if (this._icon && this.pnlTitle.contains(this._icon))
                    this.pnlTitle.removeChild(this._icon);
                this._icon = value;
                if (this._icon)
                    this.pnlTitle.prepend(this._icon);
            }
        }
        get defaultExpanded() {
            return this._defaultExpanded ?? false;
        }
        set defaultExpanded(value) {
            this._defaultExpanded = value ?? false;
            this._expanded = this._defaultExpanded;
            this.updatePanel();
        }
        get expanded() {
            return this._expanded ?? false;
        }
        set expanded(value) {
            this._expanded = value ?? false;
            this.updatePanel();
        }
        get showRemove() {
            return this._showRemove ?? false;
        }
        set showRemove(value) {
            this._showRemove = value ?? false;
            if (this.iconRemove) {
                this.iconRemove.visible = this._showRemove;
            }
        }
        get badge() {
            return this._badge;
        }
        set badge(value) {
            this._badge = value;
            if (this.lblBadge) {
                const badgeColor = this._badge?.color || style_1.Theme.ThemeVars.colors.info.main;
                const defaultFontColor = this._badge?.filled ? style_1.Theme.ThemeVars.colors.info.contrastText : style_1.Theme.ThemeVars.colors.info.main;
                this.lblBadge.caption = this._badge?.caption || "";
                this.lblBadge.background = { color: this._badge?.filled ? badgeColor : undefined };
                this.lblBadge.border = { width: 1, style: 'solid', color: badgeColor, radius: '0.25rem' };
                this.lblBadge.font = { size: '0.875rem', color: this._badge?.fontColor || defaultFontColor };
                this.lblBadge.visible = !!this._badge;
            }
        }
        get contentControl() {
            return this.pnlContent;
        }
        get font() {
            return this.lbTitle.font;
        }
        set font(value) {
            if (this.lbTitle) {
                this.lbTitle.font = value;
            }
        }
        async renderUI() {
            this.pnlAccordionItem = new layout_1.VStack(undefined, {
                padding: { top: '0.5rem', bottom: '0.5rem', left: '0.5rem', right: '0.5rem' },
                class: `${accordion_css_1.customStyles}`
            });
            const hStack = new layout_1.HStack(this.pnlAccordionItem, {
                horizontalAlignment: 'space-between',
                verticalAlignment: 'center',
                padding: { top: '0.5rem', bottom: '0.5rem' },
                cursor: 'pointer',
                class: 'accordion-header'
            });
            hStack.onClick = this.onSelectClick.bind(this);
            this.pnlTitle = new layout_1.HStack(hStack, {
                verticalAlignment: 'center',
                gap: '0.5rem'
            });
            this.lbTitle = new label_1.Label(this.pnlTitle, {
                caption: this.name,
                class: 'accordion-title',
                lineHeight: 1.3
            });
            const innerHStack = new layout_1.HStack(hStack, {
                verticalAlignment: 'center',
                gap: '0.5rem'
            });
            const badgeColor = this._badge?.color || style_1.Theme.ThemeVars.colors.info.main;
            const defaultFontColor = this._badge?.filled ? style_1.Theme.ThemeVars.colors.info.contrastText : style_1.Theme.ThemeVars.colors.info.main;
            this.lblBadge = new label_1.Label(innerHStack, {
                caption: this._badge?.caption || "",
                background: { color: this._badge?.filled ? badgeColor : undefined },
                padding: { top: '0.25rem', bottom: '0.25rem', left: '0.5rem', right: '0.5rem' },
                border: { width: 1, style: 'solid', color: badgeColor, radius: '0.25rem' },
                font: { size: '0.875rem', color: this._badge?.fontColor || defaultFontColor },
                visible: !!this._badge
            });
            this.iconExpand = new icon_1.Icon(innerHStack, {
                name: 'angle-right',
                width: 20,
                height: 28,
                fill: style_1.Theme.ThemeVars.text.primary,
                class: 'icon-expand'
            });
            this.iconRemove = new icon_1.Icon(innerHStack, {
                name: 'times',
                width: 20,
                height: 20,
                fill: style_1.Theme.ThemeVars.text.primary,
                visible: this.showRemove
            });
            this.iconRemove.onClick = this.onRemoveClick.bind(this);
            this.pnlContent = new layout_1.Panel(this.pnlAccordionItem, {
                class: `accordion-body ${accordion_css_1.expandablePanelStyle}`
            });
            this.appendChild(this.pnlAccordionItem);
            this.expanded = !this._expanded && this._defaultExpanded;
        }
        updatePanel() {
            if (this._expanded) {
                this.iconExpand.name = 'angle-down';
                this.pnlContent.visible = true;
                this.pnlAccordionItem.classList.add('expanded');
            }
            else {
                this.iconExpand.name = 'angle-right';
                this.pnlContent.visible = false;
                this.pnlAccordionItem.classList.remove('expanded');
            }
        }
        onSelectClick(target, event) {
            event.stopPropagation();
            if (this.onSelected)
                this.onSelected(this);
        }
        onRemoveClick() {
            if (this.onRemoved)
                this.onRemoved(this);
        }
        add(item) {
            item.parent = this.pnlContent;
            this.pnlContent.appendChild(item);
            this._controls.push(item);
            return item;
        }
        async init() {
            if (!this.initialized) {
                let childNodes = [];
                this.childNodes.forEach(node => {
                    childNodes.push(node);
                });
                this.onSelected = this.getAttribute('onSelected', true) || this.onSelected;
                this.onRemoved = this.getAttribute('onRemoved', true) || this.onRemoved;
                const name = this.getAttribute('name', true);
                const defaultExpanded = this.getAttribute('defaultExpanded', true);
                const showRemove = this.getAttribute('showRemove', true, false);
                const badge = this.getAttribute('badge', true);
                let iconAttr = this.getAttribute('icon', true);
                super.init();
                this._name = name;
                this._defaultExpanded = defaultExpanded;
                this._showRemove = showRemove;
                this._badge = badge;
                await this.renderUI();
                if (iconAttr?.name || iconAttr?.image?.url) {
                    iconAttr = { ...defaultIcon, ...iconAttr };
                    const icon = new icon_1.Icon(undefined, iconAttr);
                    this.icon = icon;
                }
                const font = this.getAttribute('font', true);
                if (font)
                    this.font = font;
                if (!this.pnlContent.isConnected)
                    await this.pnlContent.ready();
                if (childNodes?.length) {
                    for (let i = 0; i < childNodes.length; i++) {
                        const item = childNodes[i];
                        this.add(item);
                    }
                }
            }
        }
    };
    AccordionItem = __decorate([
        (0, base_1.customElements)('i-accordion-item', {
            icon: 'angle-down',
            group: types_1.GroupType.BASIC,
            className: 'AccordionItem',
            props: {
                name: { type: 'string', default: '' },
                defaultExpanded: { type: 'boolean', default: false },
                showRemove: { type: 'boolean', default: false }
            },
            events: {},
            dataSchema: {
                type: 'object',
                properties: {
                    name: {
                        type: 'string'
                    },
                    defaultExpanded: {
                        type: 'boolean',
                        default: false
                    },
                    showRemove: {
                        type: 'boolean',
                        default: false
                    }
                }
            }
        })
    ], AccordionItem);
    exports.AccordionItem = AccordionItem;
});
define("@ijstech/accordion/accordion.ts", ["require", "exports", "@ijstech/base", "@ijstech/layout", "@ijstech/accordion/accordion-item.ts", "@ijstech/types"], function (require, exports, base_2, layout_2, accordion_item_1, types_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Accordion = exports.AccordionItem = void 0;
    Object.defineProperty(exports, "AccordionItem", { enumerable: true, get: function () { return accordion_item_1.AccordionItem; } });
    let Accordion = class Accordion extends base_2.Control {
        static async create(options, parent) {
            let self = new this(parent, options);
            await self.ready();
            return self;
        }
        constructor(parent, options) {
            super(parent, options);
            this._items = [];
            this._isFlush = false;
            this.accordionItemMapper = new Map();
            this.onItemClick = this.onItemClick.bind(this);
            this.onRemoveClick = this.onRemoveClick.bind(this);
        }
        updateLocale(i18n) {
            super.updateLocale(i18n);
            const items = Array.from(this.accordionItemMapper).map(item => item[1]);
            items.forEach(item => item.updateLocale(i18n));
        }
        get isFlush() {
            return this._isFlush ?? false;
        }
        set isFlush(value) {
            this._isFlush = value ?? false;
        }
        get items() {
            return this._items ?? [];
        }
        set items(value) {
            this._items = value ?? [];
            this.wrapper.clearInnerHTML();
            this.accordionItemMapper = new Map();
            for (let i = 0; i < this.items.length; i++) {
                const item = { ...this.items[i] };
                this.createAccordionItem(item);
            }
        }
        createAccordionItem(item) {
            const itemElm = new accordion_item_1.AccordionItem(this.wrapper, {
                ...item,
                class: 'accordion-item',
                onSelected: this.onItemClick,
                onRemoved: this.onRemoveClick
            });
            itemElm.id = item.id ?? itemElm.uuid;
            this.accordionItemMapper.set(itemElm.id, itemElm);
            return itemElm;
        }
        onItemClick(target) {
            if (this._designMode)
                return;
            const id = target.id;
            const currentActive = this.accordionItemMapper.get(id);
            if (this.isFlush) {
                Array.from(this.accordionItemMapper).forEach((item) => {
                    if (item[0] !== id)
                        item[1].expanded = false;
                });
            }
            if (currentActive)
                currentActive.expanded = !currentActive.expanded;
        }
        async onRemoveClick(target) {
            if (this._designMode)
                return;
            const id = target.id;
            this.removeItem(id);
            if (typeof this.onCustomItemRemoved === 'function')
                await this.onCustomItemRemoved(target);
        }
        removeItem(id) {
            const item = this.accordionItemMapper.get(id);
            if (item) {
                item.remove();
                this.accordionItemMapper.delete(id);
                this._items = this._items.filter(item => item.id !== id);
            }
        }
        add(item) {
            const itemElm = this.createAccordionItem(item);
            this.items.push(item);
            return itemElm;
        }
        delete(item) {
            this.removeItem(item.id);
        }
        updateItemName(id, name) {
            const item = this.accordionItemMapper.get(id);
            if (item) {
                const titleEl = item.querySelector('.accordion-title');
                if (titleEl)
                    titleEl.caption = name;
            }
        }
        clear() {
            this.wrapper.clearInnerHTML();
            this.accordionItemMapper = new Map();
            this.items = [];
        }
        appendItem(item) {
            if (!item.id) {
                item.id = item.uuid;
            }
            this.accordionItemMapper.set(item.id, item);
            item.onSelected = this.onItemClick;
            item.onRemoved = this.onRemoveClick;
            this.wrapper.append(item);
        }
        async init() {
            if (!this.initialized) {
                let childNodes = [];
                this.childNodes.forEach(node => {
                    if (node instanceof accordion_item_1.AccordionItem) {
                        childNodes.push(node);
                    }
                    else {
                        node.remove();
                    }
                });
                const items = this.getAttribute('items', true);
                const isFlush = this.getAttribute('isFlush', true, false);
                this.onCustomItemRemoved = this.getAttribute('onCustomItemRemoved', true) || this.onCustomItemRemoved;
                super.init();
                this.wrapper = new layout_2.VStack();
                this.append(this.wrapper);
                this.isFlush = isFlush;
                if (childNodes?.length) {
                    for (let i = 0; i < childNodes.length; i++) {
                        const item = childNodes[i];
                        this.appendItem(item);
                    }
                }
                if (items)
                    this.items = items;
            }
        }
    };
    Accordion = __decorate([
        (0, base_2.customElements)('i-accordion', {
            icon: 'angle-down',
            group: types_2.GroupType.BASIC,
            className: 'Accordion',
            props: {
                items: { type: 'array' },
                isFlush: { type: 'boolean', default: false }
            },
            events: {
                onCustomItemRemoved: [
                    { name: 'item', type: 'Control', isControl: true }
                ]
            },
            dataSchema: {
                type: 'object',
                properties: {
                    isFlush: {
                        type: 'boolean',
                        default: false
                    },
                }
            }
        })
    ], Accordion);
    exports.Accordion = Accordion;
});
define("@ijstech/accordion", ["require", "exports", "@ijstech/accordion/accordion.ts"], function (require, exports, accordion_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccordionItem = exports.Accordion = void 0;
    Object.defineProperty(exports, "Accordion", { enumerable: true, get: function () { return accordion_1.Accordion; } });
    Object.defineProperty(exports, "AccordionItem", { enumerable: true, get: function () { return accordion_1.AccordionItem; } });
});
define("@ijstech/components", ["require", "exports", "@ijstech/style", "@ijstech/application", "@ijstech/jsonUI", "@ijstech/base", "@ijstech/alert", "@ijstech/button", "@ijstech/combo-box", "@ijstech/data-grid", "@ijstech/input", "@ijstech/icon", "@ijstech/image", "@ijstech/markdown", "@ijstech/markdown-editor", "@ijstech/menu", "@ijstech/module", "@ijstech/label", "@ijstech/tooltip", "@ijstech/tree-view", "@ijstech/switch", "@ijstech/modal", "@ijstech/popover", "@ijstech/checkbox", "@ijstech/datepicker", "@ijstech/upload", "@ijstech/tab", "@ijstech/iframe", "@ijstech/range", "@ijstech/radio", "@ijstech/layout", "@ijstech/pagination", "@ijstech/progress", "@ijstech/link", "@ijstech/table", "@ijstech/carousel", "@ijstech/ipfs", "@ijstech/moment", "@ijstech/video", "@ijstech/schema-designer", "@ijstech/navigator", "@ijstech/breadcrumb", "@ijstech/form", "@ijstech/color", "@ijstech/repeater", "@ijstech/accordion"], function (require, exports, Styles, application_1, jsonUI_1, base_1, alert_1, button_1, combo_box_1, data_grid_1, input_1, icon_1, image_1, markdown_1, markdown_editor_1, menu_1, module_1, label_1, tooltip_1, tree_view_1, switch_1, modal_1, popover_1, checkbox_1, datepicker_1, upload_1, tab_1, iframe_1, range_1, radio_1, layout_1, pagination_1, progress_1, link_1, table_1, carousel_1, IPFS, moment_1, video_1, schema_designer_1, navigator_1, breadcrumb_1, form_1, color_1, repeater_1, accordion_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccordionItem = exports.Accordion = exports.Repeater = exports.ColorPicker = exports.Form = exports.Breadcrumb = exports.Nav = exports.SchemaDesigner = exports.Video = exports.moment = exports.IPFS = exports.CarouselSlider = exports.TableCell = exports.TableColumn = exports.Table = exports.Link = exports.Progress = exports.Pagination = exports.StackLayout = exports.GridLayout = exports.CardLayout = exports.HStack = exports.VStack = exports.Panel = exports.RadioGroup = exports.Radio = exports.Range = exports.Iframe = exports.Tab = exports.Tabs = exports.Upload = exports.Datepicker = exports.Checkbox = exports.Popover = exports.Modal = exports.Switch = exports.TreeNode = exports.TreeView = exports.Tooltip = exports.Label = exports.Module = exports.MenuItem = exports.ContextMenu = exports.Menu = exports.MarkdownEditor = exports.markdownToPlainText = exports.Markdown = exports.Image = exports.Icon = exports.Input = exports.DataGridCell = exports.DataGrid = exports.ComboBox = exports.Button = exports.Alert = exports.IdUtils = exports.I18n = exports.RequireJS = exports.LibPath = exports.observable = exports.isObservable = exports.ClearObservers = exports.Unobserve = exports.Observe = exports.Container = exports.Control = exports.Component = exports.getCustomElements = exports.customElements = exports.customModule = exports.DataSchemaValidator = exports.renderUI = exports.FormatUtils = exports.EventBus = exports.application = exports.Styles = void 0;
    ///<amd-module name='@ijstech/components'/> 
    exports.Styles = Styles;
    Object.defineProperty(exports, "application", { enumerable: true, get: function () { return application_1.application; } });
    Object.defineProperty(exports, "EventBus", { enumerable: true, get: function () { return application_1.EventBus; } });
    Object.defineProperty(exports, "FormatUtils", { enumerable: true, get: function () { return application_1.FormatUtils; } });
    Object.defineProperty(exports, "renderUI", { enumerable: true, get: function () { return jsonUI_1.renderUI; } });
    Object.defineProperty(exports, "DataSchemaValidator", { enumerable: true, get: function () { return jsonUI_1.DataSchemaValidator; } });
    Object.defineProperty(exports, "customModule", { enumerable: true, get: function () { return base_1.customModule; } });
    Object.defineProperty(exports, "customElements", { enumerable: true, get: function () { return base_1.customElements; } });
    Object.defineProperty(exports, "getCustomElements", { enumerable: true, get: function () { return base_1.getCustomElements; } });
    Object.defineProperty(exports, "Component", { enumerable: true, get: function () { return base_1.Component; } });
    Object.defineProperty(exports, "Control", { enumerable: true, get: function () { return base_1.Control; } });
    Object.defineProperty(exports, "Container", { enumerable: true, get: function () { return base_1.Container; } });
    Object.defineProperty(exports, "Observe", { enumerable: true, get: function () { return base_1.Observe; } });
    Object.defineProperty(exports, "Unobserve", { enumerable: true, get: function () { return base_1.Unobserve; } });
    Object.defineProperty(exports, "ClearObservers", { enumerable: true, get: function () { return base_1.ClearObservers; } });
    Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return base_1.isObservable; } });
    Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return base_1.observable; } });
    Object.defineProperty(exports, "LibPath", { enumerable: true, get: function () { return base_1.LibPath; } });
    Object.defineProperty(exports, "RequireJS", { enumerable: true, get: function () { return base_1.RequireJS; } });
    Object.defineProperty(exports, "I18n", { enumerable: true, get: function () { return base_1.I18n; } });
    Object.defineProperty(exports, "IdUtils", { enumerable: true, get: function () { return base_1.IdUtils; } });
    Object.defineProperty(exports, "Alert", { enumerable: true, get: function () { return alert_1.Alert; } });
    Object.defineProperty(exports, "Button", { enumerable: true, get: function () { return button_1.Button; } });
    Object.defineProperty(exports, "ComboBox", { enumerable: true, get: function () { return combo_box_1.ComboBox; } });
    Object.defineProperty(exports, "DataGrid", { enumerable: true, get: function () { return data_grid_1.DataGrid; } });
    Object.defineProperty(exports, "DataGridCell", { enumerable: true, get: function () { return data_grid_1.DataGridCell; } });
    Object.defineProperty(exports, "Input", { enumerable: true, get: function () { return input_1.Input; } });
    Object.defineProperty(exports, "Icon", { enumerable: true, get: function () { return icon_1.Icon; } });
    Object.defineProperty(exports, "Image", { enumerable: true, get: function () { return image_1.Image; } });
    Object.defineProperty(exports, "Markdown", { enumerable: true, get: function () { return markdown_1.Markdown; } });
    Object.defineProperty(exports, "markdownToPlainText", { enumerable: true, get: function () { return markdown_1.markdownToPlainText; } });
    Object.defineProperty(exports, "MarkdownEditor", { enumerable: true, get: function () { return markdown_editor_1.MarkdownEditor; } });
    Object.defineProperty(exports, "Menu", { enumerable: true, get: function () { return menu_1.Menu; } });
    Object.defineProperty(exports, "ContextMenu", { enumerable: true, get: function () { return menu_1.ContextMenu; } });
    Object.defineProperty(exports, "MenuItem", { enumerable: true, get: function () { return menu_1.MenuItem; } });
    Object.defineProperty(exports, "Module", { enumerable: true, get: function () { return module_1.Module; } });
    Object.defineProperty(exports, "Label", { enumerable: true, get: function () { return label_1.Label; } });
    Object.defineProperty(exports, "Tooltip", { enumerable: true, get: function () { return tooltip_1.Tooltip; } });
    Object.defineProperty(exports, "TreeView", { enumerable: true, get: function () { return tree_view_1.TreeView; } });
    Object.defineProperty(exports, "TreeNode", { enumerable: true, get: function () { return tree_view_1.TreeNode; } });
    Object.defineProperty(exports, "Switch", { enumerable: true, get: function () { return switch_1.Switch; } });
    Object.defineProperty(exports, "Modal", { enumerable: true, get: function () { return modal_1.Modal; } });
    Object.defineProperty(exports, "Popover", { enumerable: true, get: function () { return popover_1.Popover; } });
    Object.defineProperty(exports, "Checkbox", { enumerable: true, get: function () { return checkbox_1.Checkbox; } });
    Object.defineProperty(exports, "Datepicker", { enumerable: true, get: function () { return datepicker_1.Datepicker; } });
    Object.defineProperty(exports, "Upload", { enumerable: true, get: function () { return upload_1.Upload; } });
    Object.defineProperty(exports, "Tabs", { enumerable: true, get: function () { return tab_1.Tabs; } });
    Object.defineProperty(exports, "Tab", { enumerable: true, get: function () { return tab_1.Tab; } });
    Object.defineProperty(exports, "Iframe", { enumerable: true, get: function () { return iframe_1.Iframe; } });
    Object.defineProperty(exports, "Range", { enumerable: true, get: function () { return range_1.Range; } });
    Object.defineProperty(exports, "Radio", { enumerable: true, get: function () { return radio_1.Radio; } });
    Object.defineProperty(exports, "RadioGroup", { enumerable: true, get: function () { return radio_1.RadioGroup; } });
    Object.defineProperty(exports, "Panel", { enumerable: true, get: function () { return layout_1.Panel; } });
    Object.defineProperty(exports, "VStack", { enumerable: true, get: function () { return layout_1.VStack; } });
    Object.defineProperty(exports, "HStack", { enumerable: true, get: function () { return layout_1.HStack; } });
    Object.defineProperty(exports, "CardLayout", { enumerable: true, get: function () { return layout_1.CardLayout; } });
    Object.defineProperty(exports, "GridLayout", { enumerable: true, get: function () { return layout_1.GridLayout; } });
    Object.defineProperty(exports, "StackLayout", { enumerable: true, get: function () { return layout_1.StackLayout; } });
    Object.defineProperty(exports, "Pagination", { enumerable: true, get: function () { return pagination_1.Pagination; } });
    Object.defineProperty(exports, "Progress", { enumerable: true, get: function () { return progress_1.Progress; } });
    Object.defineProperty(exports, "Link", { enumerable: true, get: function () { return link_1.Link; } });
    Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return table_1.Table; } });
    Object.defineProperty(exports, "TableColumn", { enumerable: true, get: function () { return table_1.TableColumn; } });
    Object.defineProperty(exports, "TableCell", { enumerable: true, get: function () { return table_1.TableCell; } });
    Object.defineProperty(exports, "CarouselSlider", { enumerable: true, get: function () { return carousel_1.CarouselSlider; } });
    exports.IPFS = IPFS;
    Object.defineProperty(exports, "moment", { enumerable: true, get: function () { return moment_1.moment; } });
    Object.defineProperty(exports, "Video", { enumerable: true, get: function () { return video_1.Video; } });
    Object.defineProperty(exports, "SchemaDesigner", { enumerable: true, get: function () { return schema_designer_1.SchemaDesigner; } });
    Object.defineProperty(exports, "Nav", { enumerable: true, get: function () { return navigator_1.Nav; } });
    Object.defineProperty(exports, "Breadcrumb", { enumerable: true, get: function () { return breadcrumb_1.Breadcrumb; } });
    Object.defineProperty(exports, "Form", { enumerable: true, get: function () { return form_1.Form; } });
    Object.defineProperty(exports, "ColorPicker", { enumerable: true, get: function () { return color_1.ColorPicker; } });
    Object.defineProperty(exports, "Repeater", { enumerable: true, get: function () { return repeater_1.Repeater; } });
    Object.defineProperty(exports, "Accordion", { enumerable: true, get: function () { return accordion_1.Accordion; } });
    Object.defineProperty(exports, "AccordionItem", { enumerable: true, get: function () { return accordion_1.AccordionItem; } });
});
